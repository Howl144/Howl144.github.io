

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <meta name="google-site-verification" content="elv6HP48K6bVVMeBdbFYkmoi4IBF6JVtH0WaCgUXRNY" />
  <link rel="apple-touch-icon" sizes="76x76" href="/img/rose.png">
  <link rel="icon" href="/img/rose.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Deng Ye">
  <meta name="keywords" content="">
  
    <meta name="description" content="最终效果图为了降低图片存储空间，只能控制一下FPS以及分辨率了，看起来像ppt别介意👀。 Pinkroom-SVGFPinkroom-JBF-Atrous   作业要求总览 实现单帧降噪。   实现两帧间的投影。   实现两帧间的累积。   Bouns 1：实现A-Trous Wavelet加速单帧降噪。  源码暂未公开   前言关于作业的构建以及完整运行流程本文不做太多介绍，网上有很多关于该部">
<meta property="og:type" content="article">
<meta property="og:title" content="Games202 Hw5 JBF and SVGF">
<meta property="og:url" content="https://howl144.github.io/2023/07/21/00019.%20Games202%20Hw5/index.html">
<meta property="og:site_name" content="🥰Howl&#39;s Blog">
<meta property="og:description" content="最终效果图为了降低图片存储空间，只能控制一下FPS以及分辨率了，看起来像ppt别介意👀。 Pinkroom-SVGFPinkroom-JBF-Atrous   作业要求总览 实现单帧降噪。   实现两帧间的投影。   实现两帧间的累积。   Bouns 1：实现A-Trous Wavelet加速单帧降噪。  源码暂未公开   前言关于作业的构建以及完整运行流程本文不做太多介绍，网上有很多关于该部">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://howl144.github.io/img/00019/pinkroom-svgf.gif">
<meta property="article:published_time" content="2023-07-21T00:43:59.000Z">
<meta property="article:modified_time" content="2023-08-11T09:57:44.785Z">
<meta property="article:author" content="Deng Ye">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://howl144.github.io/img/00019/pinkroom-svgf.gif">
  
  
  
  <title>Games202 Hw5 JBF and SVGF - 🥰Howl&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"howl144.github.io","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"MY3hK2j6KKqPNCHItX2Yargj-gzGzoHsz","app_key":"U0dZRBpPFA46kRmFcsltQFF2","server_url":"https://my3hk2j6.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Howl&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Portfolio/">
                <i class="iconfont icon-pen"></i>
                <span>Portfolio</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>Category</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archive</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>About Me</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/post.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.5)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Games202 Hw5 JBF and SVGF"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-07-21 08:43" pubdate>
          July 21, 2023 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          23k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          189 mins
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> views
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Games202 Hw5 JBF and SVGF</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="最终效果图"><a href="#最终效果图" class="headerlink" title="最终效果图"></a>最终效果图</h1><p>为了降低图片存储空间，只能控制一下FPS以及分辨率了，看起来像ppt别介意👀。</p>
<p>Pinkroom-SVGF<br><img src="/img/00019/pinkroom-svgf.gif" srcset="/img/loading.gif" lazyload alt="1"><br>Pinkroom-JBF-Atrous<br><img src="/img/00019/pinkroom-JBF-atrous.gif" srcset="/img/loading.gif" lazyload alt="2">  </p>
<h1 id="作业要求总览"><a href="#作业要求总览" class="headerlink" title="作业要求总览"></a>作业要求总览</h1><ol>
<li>实现单帧降噪。  </li>
<li>实现两帧间的投影。  </li>
<li>实现两帧间的累积。  </li>
<li>Bouns 1：实现A-Trous Wavelet加速单帧降噪。</li>
</ol>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>暂未公开  </p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于作业的构建以及完整运行流程本文不做太多介绍，网上有很多关于该部分内容的教程，重点放在算法本身。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本次作业框架提供了<code>exr文件</code>的读写操作（exr的内容就是1Spp的path tracing得到的结果），我们需要的数据也通过<code>FrameInfo</code>封装好了，需要完成的地方就是<code>denoiser类</code>的成员函数。</p>
<p>关于<code>读取exr</code>需要的注意的地方就是,<code>width</code>和<code>height</code>记得将其初始化一下，否则<code>exr文件</code>读取错误时，内存会直接撑爆，卡的要死。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Buffer2D&lt;Float3&gt; <span class="hljs-title">ReadFloat3Image</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;filename)</span> </span>&#123;<br>    <span class="hljs-type">int</span> width = <span class="hljs-number">0</span>, height = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">float</span> *_buffer = <span class="hljs-built_in">ReadImage</span>(filename, width, height, <span class="hljs-number">3</span>);<br>    ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">float</span> *<span class="hljs-title">ReadImage</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;filename, <span class="hljs-type">int</span> &amp;width, <span class="hljs-type">int</span> &amp;height,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;channel)</span> </span>&#123;<br>    ...<br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">LoadEXR</span>(&amp;out, &amp;width, &amp;height, filename.<span class="hljs-built_in">c_str</span>(), &amp;err);<br>    <span class="hljs-comment">//不初始化，读取失败后width * height得到的值巨大无比。</span><br>    <span class="hljs-type">float</span> *buffer = <span class="hljs-keyword">new</span> <span class="hljs-type">float</span>[width * height * channel];<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后就是<code>debug</code>部分在这里加上断点，可以让你在调试时候通过<strong>堆栈</strong>快速定位问题地方。否则报错只有简短的报错信息，压根不知道是哪错了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">inline</span> T &amp;Buffer2D&lt;T&gt;::<span class="hljs-built_in">operator</span>()(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;y) &#123;<br>    <span class="hljs-keyword">if</span> (!(<span class="hljs-number">0</span> &lt;= x &amp;&amp; x &lt; m_width &amp;&amp; <span class="hljs-number">0</span> &lt;= y &amp;&amp; y &lt; m_height))<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="实现-JBF-A-Trous-Wavelet"><a href="#实现-JBF-A-Trous-Wavelet" class="headerlink" title="实现 JBF A-Trous Wavelet"></a>实现 JBF A-Trous Wavelet</h1><h2 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h2><p>先介绍一下高斯滤波在图形学的应用后面会用到<br>二维高斯函数的定义为：<br>$$<br>f(x,y) &#x3D; \dfrac{1}{2\pi\sigma^{2}}e^{-\dfrac{x^{2}+y^{2}}{2\sigma^{2}}}<br>$$</p>
<p><code>x,y</code> ：是偏移值，$r^2 &#x3D; x^2 + y^2$可以看做距离平方<br><code>σ</code> ：是正态分布的标准偏差，可以决定函数的胖瘦。  </p>
<p>在二维空间中，这个公式生成的曲面的等高线是从中心开始呈正态分布的同心圆。分布不为零的像素组成的卷积矩阵与原始图像做变换。每个像素的值都是周围相邻像素值的加权平均。原始像素的值有最大的高斯分布值，所以有最大的权重，相邻像素随着距离原始像素越来越远，其权重也越来越小。  </p>
<p>一个<code>3 * 3</code>高斯核的偏移图：<br>$$<br>\begin{bmatrix}<br>-1,1 &amp; 0,1 &amp; 1,1 \<br>-1,0 &amp; 0,0 &amp; 1,0 \<br>-1,-1 &amp; 0,-1 &amp; 1,-1<br>\end{bmatrix}<br>$$</p>
<p>假定$\sigma &#x3D; 0.8$，根据偏移值和高斯函数可以得到一个<code>3 * 3</code>高斯核：<br>$$<br>\begin{bmatrix}<br>0.05212 &amp; 0.1138 &amp; 0.05212 \<br>0.1138 &amp; 0.2486 &amp; 0.1138 \<br>0.05212 &amp; 0.1138 &amp; 0.05212<br>\end{bmatrix}<br>$$<br>由于高斯核的大小不能无限大，所以该上面生成的高斯核权重加起来大约只有<code>0.91</code>左右。在次之前需要除以左上角的值使最小值为<code>1</code>，然后取整，最后进行归一化处理，使<code>3 * 3</code>的高斯核总权重为<code>1</code>，得到一个类高斯的滤波核。下面是归一化的高斯核：<br>$$<br>\begin{bmatrix}<br>\dfrac{1}{16} &amp; \dfrac{1}{8} &amp; \dfrac{1}{16} \ \<br>\dfrac{1}{8} &amp; \dfrac{1}{4} &amp; \dfrac{1}{8} \ \<br>\dfrac{1}{16} &amp; \dfrac{1}{8} &amp; \dfrac{1}{16}<br>\end{bmatrix}<br>$$</p>
<h2 id="联合双边滤波"><a href="#联合双边滤波" class="headerlink" title="联合双边滤波"></a>联合双边滤波</h2><p>权重总和为<code>1</code>或不为<code>1</code>的滤波器的实现在课上有提到：<br><img src="/img/00019/implementation-of-filtering.png" srcset="/img/loading.gif" lazyload alt="Alt text"><br><code>w_ij</code> : 遍历到周围像素时，该像素的权重。<br><code>sum_of_weights</code> : 各像素权重总和，如果是上面提到的归一化高斯核，则该值等于<code>1</code>。<br><code>sum_of_weighted_values</code> : 各像素值经过权重处理后的总和。<br><code>C^&#123;input&#125;[j]</code> : 各像素的值，可以是灰度值或者<code>RGB</code>颜色值。<br>总的来说，就是每个像素都会考虑它一定范围内像素值对它的贡献，最后再除以<strong>权重总和</strong>就是该像素的颜色值。这样做优点在于，它不会引起整体能量的降低或升高，不会导致图像整体变暗或变亮。<br>所以我们不需要再关系滤波核的权重，而是关注滤波核的形状，而图像降噪部分最重要的就是滤波核的形状。  </p>
<p>如果只是使用高斯滤波核，则图像的高频信息都会被抹去，保留住了低频信息，这样看起来图像就会变得很模糊：<br><img src="/img/00019/gaussian-filter.png" srcset="/img/loading.gif" lazyload alt="Alt text"><br>而我们还是希望边界不要被糊掉，以及保留一些有用的高频信息，这就引入了新的方法<code>BF(Bilateral Filtering)</code>：<br><img src="/img/00019/bilateral-filtering.png" srcset="/img/loading.gif" lazyload alt="Alt text"><br><code>i</code>，<code>j</code> 表示一个点； <code>k</code>，<code>l</code> 表示另一个点。<br>该方法在类高斯滤波（一切随距离衰减的函数都可以用，所以前面那一坨就去掉了）上增加了一个颜色贡献项，也就说中心周围的像素和中心像素的颜色差异过大就不给予它贡献，这样边界这种高频信息就不会被糊掉。下面就是该方法的效果：<br><img src="/img/00019/bilateral-filtering-result.png" srcset="/img/loading.gif" lazyload alt="Alt text"><br>效果是好了很多，边界也很清晰了，但还是有问题，山体以及水面很多有用的高频信息被当做噪声抹掉了，也就是说该方法分不清噪点和有用的高频信息。  </p>
<p>所以在此基础上，再增加一些新的判断标准就可以保留更多有用的高频信息，这就是引入了<code>JBF/CBF(Joint/Cross Bilateral Filtering)</code>:<br>$$<br>J(i,j) &#x3D; \exp(-\frac{\lVert i-j\lVert ^2}{2\sigma_{p}^2} - \frac{\lVert \widetilde{C}[i] - \widetilde{C}[j] \lVert ^2 }{2\sigma_{c}^2} - \frac{D_{normal}(i,j)^2}{2\sigma_{n}^2} - \frac{D_{plane}(i,j)^2}{2\sigma_{d}^2})<br>$$</p>
<p>其中<code>i</code>，<code>j</code> 为不同的两个像素点。<br>$$<br>D_{normal}(i,j) &#x3D; arccos(Normal[i] \cdot Normal[j])<br>$$</p>
<p>$$<br>D_{plane}(i,j) &#x3D; Normal[i]\cdot \frac{Position[j] - Position[i]}{\lVert Position[j] - Positon[i] \lVert}<br>$$</p>
<p>$\widetilde{C}$为有噪声的输入图像，$D_{normal}$为两法线夹角，$D_{plane}$为深度差值指标。公式中的各个<code>σ</code>值在<code>Denoiser</code>类中有提供。  </p>
<p>该方法新增两个判断标准来源<code>Gbuffer</code>，由于<code>Gbuffer</code>生成的纹理是没有任何噪声的，所以用它们来指导滤波效果非常不错，而且生成<code>Gbuffer</code>的性能消耗几乎可以忽略不计，在第一趟<code>Rasterization</code>生成<code>Primary Ray</code>的时候直接顺带就生成了所需要的<code>Gbuffer</code>。</p>
<p><code>JBF</code>的代码等到后面讲解<code>A-Trous Wavelet</code>单帧降噪加速时在贴上。</p>
<h2 id="两帧间的投影"><a href="#两帧间的投影" class="headerlink" title="两帧间的投影"></a>两帧间的投影</h2><p>这一步主要是找出当前帧的每个像素在上一帧对应是哪个像素，如下图所示：<br><img src="/img/00019/back-projection.png" srcset="/img/loading.gif" lazyload alt="Alt text"><br>我们称这一过程为<code>Back Projection</code>，它实现的具体表达式如下：<br>$$<br>Screen_{i-1} &#x3D; E_{i-1}P_{i-1}V_{i-1}M_{i-1}M_{i}^{-1}World_{i}<br>$$<br> $E_{i-1}$ 是视口变换，闫老师说公式中漏掉了，这里我补上。<br>我们可以通过该式子找到当前帧当前片段对应的上一帧的片段，上述式子中所需要的各种数据在框架中都有提供，具体请后面的代码实现。找到的上一帧信息还有可能无法使用，这一现象我们称作为<code>Temporal Failure</code>，如下图所示，有三种情境会导致投影得到的信息无效。<br><img src="/img/00019/temporal-failure.png" srcset="/img/loading.gif" lazyload alt="Alt text"><br>左边的箱子是上一帧，右边的箱子是当前帧。<br>disocclusion ： 当前帧新出现的物体，由被遮挡的状态变成未被遮挡的状态。  </p>
<p>前两种情况由屏幕空间的范围来约束它，超出范围的直接丢弃（因为上一帧并未记录屏幕外的信息）。对于第三种，我们则用一个叫<code>Object ID</code>的方法来检测<code>Temporal Failure</code>，如果上一帧和当前帧的<code>Object ID</code>不一致则丢弃，说明当前帧该物体属于<code>disocclusion</code>状态。</p>
<p>代码实现如下：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Denoiser_JBF::Reprojection</span><span class="hljs-params">(<span class="hljs-type">const</span> FrameInfo &amp;frameInfo)</span> </span>&#123;<br>    <span class="hljs-type">int</span> height = m_accColor.m_height;<br>    <span class="hljs-type">int</span> width = m_accColor.m_width;<br>    Matrix4x4 pre_World_To_Screen =<br>        m_preFrameInfo.m_matrix[m_preFrameInfo.m_matrix.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel for</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; height; y++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; width; x++) &#123;<br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Reproject</span><br>            <span class="hljs-built_in">m_valid</span>(x, y) = <span class="hljs-literal">false</span>;<br>            <span class="hljs-built_in">m_misc</span>(x, y) = <span class="hljs-built_in">Float3</span>(<span class="hljs-number">0.f</span>);<br><br>            <span class="hljs-type">int</span> id = frameInfo.<span class="hljs-built_in">m_id</span>(x, y);<br>            <span class="hljs-keyword">if</span> (id == <span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            Matrix4x4 world_to_local = <span class="hljs-built_in">Inverse</span>(frameInfo.m_matrix[id]);<br>            Matrix4x4 pre_local_to_world = m_preFrameInfo.m_matrix[id];<br>            <span class="hljs-keyword">auto</span> world_position = frameInfo.<span class="hljs-built_in">m_position</span>(x, y);<br>            <span class="hljs-keyword">auto</span> local_position =<br>                <span class="hljs-built_in">world_to_local</span>(world_position, Float3::EType::Point);<br>            <span class="hljs-keyword">auto</span> pre_world_position =<br>                <span class="hljs-built_in">pre_local_to_world</span>(local_position, Float3::EType::Point);<br>            <span class="hljs-keyword">auto</span> pre_screen_position =<br>                <span class="hljs-built_in">pre_World_To_Screen</span>(pre_world_position, Float3::EType::Point);<br><br>            <span class="hljs-keyword">if</span> (pre_screen_position.x &lt; <span class="hljs-number">0</span> || pre_screen_position.x &gt;= width ||<br>                pre_screen_position.y &lt; <span class="hljs-number">0</span> || pre_screen_position.y &gt;= height) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> pre_id =<br>                    m_preFrameInfo.<span class="hljs-built_in">m_id</span>(pre_screen_position.x, pre_screen_position.y);<br>                <span class="hljs-keyword">if</span> (pre_id == id) &#123;<br>                    <span class="hljs-built_in">m_valid</span>(x, y) = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-built_in">m_misc</span>(x, y) =<br>                        <span class="hljs-built_in">m_accColor</span>(pre_screen_position.x, pre_screen_position.y);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//m_misc是一个临时存储的buffer，如果一趟pass中，读写是同一个buffer，就需要另开一个buffer来避免它们相互干扰。在后面svgf中我们也会经常这么使用。</span><br>    std::<span class="hljs-built_in">swap</span>(m_misc, m_accColor);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中<code>world_to_local</code>对应 $M_{i}^{-1}$，<code>pre_local_to_world</code>对应 $M_{i-1}$，<code>pre_World_To_Screen</code>对应 $E_{i-1}P_{i-1}V_{i-1}$。</p>
<h2 id="两帧间的累积"><a href="#两帧间的累积" class="headerlink" title="两帧间的累积"></a>两帧间的累积</h2><p>上一节中我已经拿到了上一帧有用的历史信息，这一小节则是将当前帧与上一帧进行线性混合，在线性混合之前还需要一次<code>Clamp</code>操作，将上一帧的颜色利用当前帧的均值和方差严格控制在当前帧颜色附近，公式如下：</p>
<p>$$<br>\overline{C}<em>{i} &#x3D; \alpha \overline{C}</em>{i} + (1-\alpha) Clamp(\overline{C}<em>{i-1})<br>$$<br> $\alpha$的值通常取<code>0.2</code>。<br>对于<code>Clamp</code>部分，首先需要计算 $\overline{C}</em>{i}$在<code>7 * 7</code>的邻域内的均值<code>μ</code>和方差<code>σ</code>，然后把上一帧的颜色 $\overline{C}_{i-1}$<code>Clamp</code>在 $(\mu - k\sigma, \mu + k \sigma)$范围内。  </p>
<p>代码实现如下：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Denoiser_JBF::TemporalAccumulation</span><span class="hljs-params">(<span class="hljs-type">const</span> Buffer2D&lt;Float3&gt; &amp;curFilteredColor)</span> </span>&#123;<br>    <span class="hljs-type">int</span> height = m_accColor.m_height;<br>    <span class="hljs-type">int</span> width = m_accColor.m_width;<br>    <span class="hljs-type">int</span> kernelRadius = <span class="hljs-number">3</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel for</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; height; y++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; width; x++) &#123;<br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Temporal clamp</span><br>            Float3 color = <span class="hljs-built_in">m_accColor</span>(x, y);<br>            <span class="hljs-comment">//Set Alpha to 1 when no legal corresponding point was found in the previous frame</span><br>            <span class="hljs-type">float</span> alpha = <span class="hljs-number">1.0f</span>;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">m_valid</span>(x, y)) &#123;<br>                alpha = m_alpha;<br><br>                <span class="hljs-type">int</span> x_start = std::<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, x - kernelRadius);<br>                <span class="hljs-type">int</span> x_end = std::<span class="hljs-built_in">min</span>(width - <span class="hljs-number">1</span>, x + kernelRadius);<br>                <span class="hljs-type">int</span> y_start = std::<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, y - kernelRadius);<br>                <span class="hljs-type">int</span> y_end = std::<span class="hljs-built_in">min</span>(height - <span class="hljs-number">1</span>, y + kernelRadius);<br><br>                <span class="hljs-function">Float3 <span class="hljs-title">mu</span><span class="hljs-params">(<span class="hljs-number">0.f</span>)</span></span>;<br>                <span class="hljs-function">Float3 <span class="hljs-title">sigma</span><span class="hljs-params">(<span class="hljs-number">0.f</span>)</span></span>;<br><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> m = x_start; m &lt;= x_end; m++) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = y_start; n &lt;= y_end; n++) &#123;<br>                        mu += <span class="hljs-built_in">curFilteredColor</span>(m, n);<br>                        <span class="hljs-comment">//sqr：平方</span><br>                        sigma += <span class="hljs-built_in">Sqr</span>(<span class="hljs-built_in">curFilteredColor</span>(x, y) - <span class="hljs-built_in">curFilteredColor</span>(m, n));<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-type">int</span> count = kernelRadius * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 7 * 7</span><br>                count *= count;<br><br>                mu /= <span class="hljs-built_in">float</span>(count);<br>                sigma = <span class="hljs-built_in">SafeSqrt</span>(sigma / <span class="hljs-built_in">float</span>(count));<br>                color = <span class="hljs-built_in">Clamp</span>(color, mu - sigma * m_colorBoxK, mu + sigma * m_colorBoxK);<br>            &#125;<br><br>            <span class="hljs-built_in">m_misc</span>(x, y) = <span class="hljs-built_in">Lerp</span>(color, <span class="hljs-built_in">curFilteredColor</span>(x, y), alpha);<br>        &#125;<br>    &#125;<br>    std::<span class="hljs-built_in">swap</span>(m_misc, m_accColor);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>Clamp</code>是为了减轻<code>Lagging(拖影)</code>现象，如果什么都不做强行使用上一帧的信息，就会导致拖影现象:<br><img src="/img/00019/lagging.png" srcset="/img/loading.gif" lazyload alt="Alt text"></p>
<p>使用了<code>Clamp</code>方法后，拖影现象没了，但是会重新引入噪声，不过相比于拖影效果还是好了很多：<br><img src="/img/00019/noise.png" srcset="/img/loading.gif" lazyload alt="Alt text"></p>
<p>通常<code>Object ID</code>和<code>Clamp</code>方法是一起使用。</p>
<p>即使我们已经做得足够好了，但还是有很多的<code>Temporal Failure</code>，并不是因为几何的原因，而是<code>shading</code>过程中也会出问题，也就是说阴影或者反射这种现象，在用上一帧的信息时，它的<code>motion vector</code>是零，当前帧当前片段就会用上一帧的信息，这就会导致阴影拖尾或者反射延迟的现象：<br>Detached&#x2F;Lagging shadows<br><img src="/img/00019/lagging-shadows.png" srcset="/img/loading.gif" lazyload alt="Alt text"><br>Reflection hysteresis<br><img src="/img/00019/reflection-hysteresis.gif" srcset="/img/loading.gif" lazyload alt="Alt text"></p>
<h2 id="加速单帧降噪"><a href="#加速单帧降噪" class="headerlink" title="加速单帧降噪"></a>加速单帧降噪</h2><h3 id="Separate-Passes"><a href="#Separate-Passes" class="headerlink" title="Separate Passes"></a>Separate Passes</h3><p>在此之前还介绍一种<code>Separate Passes</code>的方法，该方法可以将复杂度从<code>N^2</code>降到<code>2N</code>：<br><img src="/img/00019/image.png" srcset="/img/loading.gif" lazyload alt="Alt text"><br>该方法很适合高斯滤波，因为高斯滤波在定义上就可以拆分成两个方向上函数的乘积形式,滤波过程中相当于先水平方向做一次卷积，然后将结果给到竖直方向再做一次卷积，非常完美：<br><img src="/img/00019/image-1.png" srcset="/img/loading.gif" lazyload alt="Alt text"><br>但问题是<code>BF</code>和<code>JBF</code>的卷积核，不是一个高斯函数，想要将它拆分成水平竖直的函数是几乎不可能，但这里是实时渲染，“约等于”无处不在😆，<code>filter</code>的范围只要不是太大比如<code>32 * 32</code>还是可以勉强用一用的。  </p>
<h3 id="A-Trous-Wavelet"><a href="#A-Trous-Wavelet" class="headerlink" title="A-Trous Wavelet"></a>A-Trous Wavelet</h3><p>上面提到的<code>Separate Passes</code>方法，我还没看到在哪里用上了😅。而<code>A-Trous Wavelet</code>方法在降噪这方面几乎是通吃，应用非常广泛：<br><img src="/img/00019/image-2.png" srcset="/img/loading.gif" lazyload alt="Alt text"><br>这里<code>ppt</code>上的图片不太好理解，我这里引用一下知乎<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/607012514">花桑</a>的图片<br><img src="/img/00019/image-3.png" srcset="/img/loading.gif" lazyload alt="Alt text"><br><code>A-Trous Wavelet</code>方法相当于吧一个非常大范围的<code>filter过程</code>分解成<code>几趟pass</code>来完成，我们需要<code>filter</code>的点位<code>p</code>就是<code>const Float3 p = ipos + Float3(xx, yy,0) * stepSize;</code>其中<code>ipos</code>中心点，<code>xx,yy</code>是偏移值，<code>stepSize</code>则是 $2^{pass-1}$<br>这样<code>3</code>趟<code>5 * 5</code>的滤波就相当于<code>16 * 16</code>的滤波。在实际应用中，我们通常使用一个大小为<code>5 * 5</code>的滤波核，走<code>5</code>趟，来模拟<code>64 * 64</code>的滤波过程。(5 * 5的滤波核，走5趟，filter半径即 $2 \times 2^{5-1}&#x3D;32$)</p>
<p>当然这只是该方法的应用，它的原理其实很复杂，简单概述一下：<br><img src="/img/00019/image-4.png" srcset="/img/loading.gif" lazyload alt="Alt text"><br>对于第一个问题：<br>为什么要用一个逐渐增加的<code>filter</code>范围，不能一上来就是最大范围？<br>图上给出的答案是，逐渐增加的<code>filter</code>范围 &#x3D;&#x3D; 去掉更低的频率。<br>对于第一趟<code>pass</code>，我们<code>filter</code>的过程是将高频信息限制在一个可接受的范围内，往后的每一趟<code>pass</code>都是在前一趟的基础上继续将高频信息限制在一个更低的可接受范围内，所以这里“去掉更低的频率”意思是相比于上一趟<code>pass</code>，去掉比上一趟高频信息更低一点的高频信息。自然这个过程就是<code>filter</code>的范围是逐渐增加，而不能一上来就是<code>filter</code>最大的范围。<br>对于第二个问题：<br>为什么可以安全的跳过一些采样点？<br>图上给出的答案是，采样 &#x3D;&#x3D; 重复搬移频谱。<br>首先对于采样来说，时域上的采样等于原始函数乘上冲击函数。而对应频域上，就是原始频谱卷积冲击频谱，相当于对在频域上对原始频谱进行搬移的操作，而且时域冲击函数的冲击间隔越大，对应频域搬移的间隔就越小：<br><img src="/img/00019/image-5.png" srcset="/img/loading.gif" lazyload alt="Alt text"><br>(a)为原始函数，(b)为该函数经过傅里叶变化后的频谱。<br>(c)为冲击函数，(d)为该函数经过傅里叶变化后的频谱。<br>(e)为原始函数乘上冲击函数的结果。<br>(f)为(b)(d)频谱卷积后的结果。<br>我们知道如果时域采样间隔增加大，频域上频谱混叠就越严重，只有当频谱中高频信息被抹掉后，混叠才不会引起走样。这也是要用一个逐渐增加的<code>filter</code>范围的一个原因。<br><img src="/img/00019/image-6.png" srcset="/img/loading.gif" lazyload alt="Alt text"><br>回到问题上，<code>A-Trous Wavelet</code>的采样间隔为$2^{pass-1}-1$，这种采样间距的好处是搬移的边界正好是上一趟留下的最高频率。<br>所以这种采样可以安全的跳过一些采样点，而不引入走样。<br>结合第一个问题和第二个问题，当前<code>pass</code>会除去一些更低的高频信息，有助于搬移混叠时减少走样现象，以$2^{pass-1}-1$的间隔去采样，由于搬移时左右边界都是上一次留下的最高频信息，所以这种逐渐增大的采样间隔并不会新增走样。<br>更多内容请关注该论文：<br><a target="_blank" rel="noopener" href="https://jo.dreggn.org/home/2010_atrous.pdf">Edge-Avoiding À-Trous Wavelet Transform for fast Global Illumination Filtering</a></p>
<p><code>JBF A-Trous Wavelet</code>的代码实现如下：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Buffer2D&lt;Float3&gt; <span class="hljs-title">Denoiser_JBF::ATrousWaveletFilter</span><span class="hljs-params">(<span class="hljs-type">const</span> FrameInfo &amp;frameInfo)</span> </span>&#123;<br>    <span class="hljs-type">int</span> height = frameInfo.m_beauty.m_height;<br>    <span class="hljs-type">int</span> width = frameInfo.m_beauty.m_width;<br>    Buffer2D&lt;Float3&gt; filteredImage = <span class="hljs-built_in">CreateBuffer2D</span>&lt;Float3&gt;(width, height);<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel for</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; height; y++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; width; x++) &#123;<br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Joint bilateral filter</span><br>            <span class="hljs-comment">// filteredImage(x, y) = frameInfo.m_beauty(x, y);</span><br><br>            <span class="hljs-keyword">auto</span> center_postion = frameInfo.<span class="hljs-built_in">m_position</span>(x, y);<br>            <span class="hljs-keyword">auto</span> center_normal = frameInfo.<span class="hljs-built_in">m_normal</span>(x, y);<br>            <span class="hljs-keyword">auto</span> center_color = frameInfo.<span class="hljs-built_in">m_beauty</span>(x, y);<br><br>            Float3 final_color;<br>            <span class="hljs-keyword">auto</span> total_weight = <span class="hljs-number">.0</span>f;<br><br>            <span class="hljs-type">int</span> passes = <span class="hljs-number">5</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> pass = <span class="hljs-number">0</span>; pass &lt; passes; pass++) &#123;<br><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> filterX = <span class="hljs-number">-2</span>; filterX &lt;= <span class="hljs-number">2</span>; filterX++) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> filterY = <span class="hljs-number">-2</span>; filterY &lt;= <span class="hljs-number">2</span>; filterY++) &#123;<br><br>                        <span class="hljs-type">int</span> m = x + std::<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, pass) * filterX;<br>                        <span class="hljs-type">int</span> n = y + std::<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, pass) * filterY;<br><br>                        <span class="hljs-keyword">auto</span> postion = frameInfo.<span class="hljs-built_in">m_position</span>(m, n);<br>                        <span class="hljs-keyword">auto</span> normal = frameInfo.<span class="hljs-built_in">m_normal</span>(m, n);<br>                        <span class="hljs-keyword">auto</span> color = frameInfo.<span class="hljs-built_in">m_beauty</span>(m, n);<br><br>                        <span class="hljs-keyword">auto</span> d_position = <span class="hljs-built_in">SqrDistance</span>(center_postion, postion) /<br>                                          (<span class="hljs-number">2.0f</span> * m_sigmaCoord * m_sigmaCoord);<br>                        <span class="hljs-keyword">auto</span> d_color = <span class="hljs-built_in">SqrDistance</span>(center_color, color) /<br>                                       (<span class="hljs-number">2.0f</span> * m_sigmaColor * m_sigmaColor);<br>                        <span class="hljs-keyword">auto</span> d_normal = <span class="hljs-built_in">SafeAcos</span>(<span class="hljs-built_in">Dot</span>(center_normal, normal));<br>                        d_normal *= d_normal;<br>                        d_normal /= (<span class="hljs-number">2.0f</span> * m_sigmaNormal * m_sigmaNormal);<br><br>                        <span class="hljs-type">float</span> d_plane = <span class="hljs-number">.0</span>f;<br>                        <span class="hljs-keyword">if</span> (d_position &gt; <span class="hljs-number">0.f</span>) &#123;<br>                            d_plane = <span class="hljs-built_in">Dot</span>(center_normal, <span class="hljs-built_in">Normalize</span>(postion - center_postion));<br>                        &#125;<br>                        d_plane *= d_plane;<br>                        d_plane /= (<span class="hljs-number">2.0f</span> * m_sigmaPlane * m_sigmaPlane);<br><br>                        <span class="hljs-type">float</span> weight =<br>                            std::<span class="hljs-built_in">exp</span>(-d_plane - d_position - d_color - d_normal);<br>                        total_weight += weight;<br>                        final_color += color * weight;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (total_weight == <span class="hljs-number">0</span>)<br>                <span class="hljs-built_in">filteredImage</span>(x, y) = center_color;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-built_in">filteredImage</span>(x, y) = final_color / total_weight;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> filteredImage;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>用该方法<code>filter</code>的效果图：<br>此时的<code>sigmaColor</code>为<code>0.6f</code><br><img src="/img/00019/box-JBF-atrous.gif" srcset="/img/loading.gif" lazyload><br>而<code>Pink Room</code>的<code>sigmaColor</code>需要调为<code>10.0f</code>，否则完全不能看。<br><img src="/img/00019/pinkroom-JBF-atrous.gif" srcset="/img/loading.gif" lazyload>    </p>
<h1 id="实现-SVGF"><a href="#实现-SVGF" class="headerlink" title="实现 SVGF"></a>实现 SVGF</h1><h2 id="论文地址以及论文提供的源码地址"><a href="#论文地址以及论文提供的源码地址" class="headerlink" title="论文地址以及论文提供的源码地址"></a>论文地址以及论文提供的源码地址</h2><p><code>Paper</code> : <a target="_blank" rel="noopener" href="https://research.nvidia.com/sites/default/files/pubs/2017-07_Spatiotemporal-Variance-Guided-Filtering%3A//svgf_preprint.pdf">Spatiotemporal-Variance-Guided-Filtering</a><br><code>Source Code</code> : <a target="_blank" rel="noopener" href="https://github.com/NVIDIAGameWorks/Falcor/tree/master/Source/RenderPasses/SVGFPass">Falcor</a><br>本文部分代码以及图片均来源于此。</p>
<h2 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h2><p><code>SVGF</code>资料不多，我引用一下论文中的图片来讲解：<br><img src="/img/00019/image-8.png" srcset="/img/loading.gif" lazyload alt="Alt text"><br>首先从路径追踪得到直接光和间接光每个像素的颜色，然后通过除以像素上的纹理信息（Demodulate Albedo）得到像素的<code>Irradiance</code>（辐照度）：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">float3 <span class="hljs-title">demodulate</span><span class="hljs-params">(float3 c, float3 albedo)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> c / <span class="hljs-built_in">max</span>(albedo, <span class="hljs-built_in">float3</span>(<span class="hljs-number">0.001</span>, <span class="hljs-number">0.001</span>, <span class="hljs-number">0.001</span>));<br>&#125;<br><br>float3 illumination = <span class="hljs-built_in">demodulate</span>(gColor[ipos].rgb - gEmission[ipos].rgb, gAlbedo[ipos].rgb);<br></code></pre></td></tr></table></figure>
<p>接着对分别对直接光照和间接光照的<code>Irradiance</code>信息进行时间和空间上的混合<code>Filter</code>来重建因为样本极度稀疏所丢失的信息（Reconstruction Filter）。对<code>Irradiance</code>进行<code>Filter</code>之后，再把纹理信息叠加回来（Modulate Albedo）：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">float4 <span class="hljs-title">main</span><span class="hljs-params">(FullScreenPassVsOut vsOut)</span> : SV_TARGET0</span><br><span class="hljs-function">&#123;</span><br>    <span class="hljs-type">const</span> int2 ipos = <span class="hljs-built_in">int2</span>(vsOut.posH.xy);<br><br>    <span class="hljs-keyword">return</span> gAlbedo[ipos] * gIllumination[ipos] + gEmission[ipos];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样做的好处是，纹理的细节并不会因为<code>Filter</code>的强度过于大而丢失掉。在<code>Pipeline</code>的最后，采用现在引擎里非常流行的<code>Temporal AA</code>，更进一步的消除画面上残留的抖动，保证结果序列帧间的稳定。   </p>
<p>由于作业5，提供的<code>EXR文件</code>中只包含了直接光和间接光结合在一起的完整结果，我在进行<code>Reconstruction Filter</code>过程中也是直接对该结果进行的<code>Filter</code>，所以画面有些地方会糊掉会很正常。  </p>
<p>至于<code>Tone Mapping</code>和<code>TAA</code>我均未实现，我们的重点是<code>Reconstruction Filter</code>。</p>
<h2 id="Reconstruction-Filter"><a href="#Reconstruction-Filter" class="headerlink" title="Reconstruction Filter"></a>Reconstruction Filter</h2><p><img src="/img/00019/image-9.png" srcset="/img/loading.gif" lazyload alt="Alt text"><br>重建执行三个主要步骤：在时间上累积我们的<code>1 spp</code>路径跟踪输入以提高有效采样率，使用这些时间上增强的颜色样本来估计局部亮度方差，以及使用这些方差估计来驱动分层的<code>“a-trous小波滤波器”</code>。  </p>
<h3 id="Temporal-Filtering"><a href="#Temporal-Filtering" class="headerlink" title="Temporal Filtering"></a>Temporal Filtering</h3><p><code>Temporal Filter</code>和上文提到的“两帧间的累积”很相似，公式如下：<br>$$<br>C_{i} &#x3D; \alpha C_{i} + (1-\alpha)C_{i-1}<br>$$<br>为了尽可能多的囊括历史帧里的样本信息，<code>Temporal Filter</code>并不像<code>JBF</code>那样通过<code>Color Clamping</code>来防止<code>Ghosting</code>这种问题。所以在做<code>Sample Reprojection</code>的时候需要检查范围，深度，法线，模型索引等，去尽可能的丢弃无效的历史样本:  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (loc.x &lt; <span class="hljs-number">0</span> || loc.x &gt;= width || loc.y &lt; <span class="hljs-number">0</span> || loc.y &gt;= height)<br>    <span class="hljs-comment">//丢弃</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Denoiser_SVGF::isReprjValid</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">float</span> depth,<span class="hljs-type">const</span> <span class="hljs-type">float</span> preDepth,<span class="hljs-type">const</span> <span class="hljs-type">float</span> fwidthZ,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> Float3 normal, <span class="hljs-type">const</span> Float3 preNormal,<span class="hljs-type">const</span> <span class="hljs-type">float</span> fwidthNormal,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">int</span> meshId,<span class="hljs-type">const</span> <span class="hljs-type">int</span> preMeshId</span></span><br><span class="hljs-params"><span class="hljs-function">)</span> </span>&#123;<br>    <span class="hljs-comment">// check if deviation of depths is acceptable</span><br>    <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">fabs</span>(depth - preDepth) / (fwidthZ + <span class="hljs-number">1e-2</span>) &gt; <span class="hljs-number">10.0f</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// check normals for compatibility</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Distance</span>(normal, preNormal) / (fwidthNormal + <span class="hljs-number">1e-2</span>) &gt; <span class="hljs-number">16.0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// Since the grayscale is the result of direct path-tracing, there is a mutual contribution that can occur without meshid.</span><br>    <span class="hljs-comment">//To mitigate this, add meshid, which can cause other problems such as artifacts.</span><br>    <span class="hljs-keyword">if</span> (meshId != preMeshId)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>代码中的<code>fwidthZ，fwidthNormal</code>为深度或法线<a target="_blank" rel="noopener" href="https://developer.download.nvidia.com/cg/fwidth.html">在x，y方向上的偏导和</a>。其计算方法如下：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> Float3 normal = frameInfo.<span class="hljs-built_in">m_normal</span>(x, y);<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> ddxN = <span class="hljs-built_in">Distance</span>(frameInfo.<span class="hljs-built_in">m_normal</span>(x + <span class="hljs-number">1</span>, y), normal);<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> ddyN = <span class="hljs-built_in">Distance</span>(frameInfo.<span class="hljs-built_in">m_normal</span>(x, y + <span class="hljs-number">1</span>), normal);<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> fwidthNormal = ddxN + ddyN;<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> depth = frameInfo.<span class="hljs-built_in">m_depth</span>(x, y);<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> ddxZ = std::<span class="hljs-built_in">fabs</span>(frameInfo.<span class="hljs-built_in">m_depth</span>(x + <span class="hljs-number">1</span>, y) - depth);<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> ddyZ = std::<span class="hljs-built_in">fabs</span>(frameInfo.<span class="hljs-built_in">m_depth</span>(x, y + <span class="hljs-number">1</span>) - depth);<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> fwidthZ = ddxZ + ddyZ;<br></code></pre></td></tr></table></figure>
<p><code>Temporal Filter</code>公式中的$\alpha$是根据寻找历史样本的成功次数来定的，最大为<code>1</code>，最小自定：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// this adjusts the alpha for the case where insufficient history is available.</span><br><span class="hljs-comment">// It boosts the temporal accumulation to give the samples equal weights in the beginning.</span><br><span class="hljs-type">const</span> <span class="hljs-type">float</span> alpha = success ? std::<span class="hljs-built_in">fmax</span>(m_Alpha, <span class="hljs-number">1.0</span> / historyLength) : <span class="hljs-number">1.0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> alphaMoments = success ? std::<span class="hljs-built_in">fmax</span>(m_MomentsAlpha, <span class="hljs-number">1.0</span> / historyLength) : <span class="hljs-number">1.0</span>;<br><br><span class="hljs-comment">// compute first two moments of luminance</span><br>Float3 moments;<br>moments.x = <span class="hljs-built_in">Luminance</span>(illumination);<br>moments.y = moments.x * moments.x;<br><br><span class="hljs-comment">// temporal integration of the moments</span><br>moments = <span class="hljs-built_in">Lerp</span>(prevMoments, moments, alphaMoments);<br><br><span class="hljs-type">float</span> variance = std::<span class="hljs-built_in">fmax</span>(<span class="hljs-number">0.f</span>, moments.y - moments.x * moments.x);<br><span class="hljs-comment">// temporal integration of illumination</span><br><span class="hljs-built_in">m_accColor</span>(x, y) = <span class="hljs-built_in">Lerp</span>(prevIllumination, illumination, alpha);<br><span class="hljs-built_in">m_curFrameVariance</span>(x,y) = variance;<br><span class="hljs-built_in">m_moments</span>(x, y) = moments;<br><span class="hljs-built_in">m_tmpHisLength</span>(x,y) = historyLength;<br></code></pre></td></tr></table></figure>
<p>是的，不仅仅是颜色需要<code>Temporal Filter</code>，<code>Moments</code>也需要，方差的计算依赖它，通过在时间上积累<code>Luminance</code>的<code>First</code>和<code>Second Moment</code>, $\mu^{\prime}<em>{1i}$和 $\mu^{\prime}</em>{2i}$，方差的计算公式如下：<br>$$<br>\sigma^{\prime2}<em>{i}&#x3D;\mu^{\prime}</em>{2i}-\mu^{\prime2}_{1i}<br>$$<br><code>Moments Temporal Filter</code>对应上图中紫色块的处理过程。</p>
<h3 id="Variance-Estimation"><a href="#Variance-Estimation" class="headerlink" title="Variance Estimation"></a>Variance Estimation</h3><p>由于摄像机运动、影视效果和视口变换出界都会导致<code>disocclusion事件</code>，从而影响方差估计的质量。所以我们要对出现<code>disocclusion事件</code>的前<code>4</code>帧进行空间上的<code>7 * 7</code>双边滤波，该滤波核权重由深度，法线，灰度值决定。在此期间也对<code>illumination</code>做一次<code>Filter</code>，两者是同时进行，几乎没有额外开销。代码实现如下：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Denoiser_SVGF::VarianceEstimation</span><span class="hljs-params">(<span class="hljs-type">const</span> FrameInfo &amp;frameInfo)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> height = frameInfo.m_beauty.m_height;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> width = frameInfo.m_beauty.m_width;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> radius = <span class="hljs-number">3</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel for</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; height; y++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; width; x++) &#123;<br><br>            <span class="hljs-type">const</span> Float3 ipos = <span class="hljs-built_in">Float3</span>(x, y, <span class="hljs-number">0</span>);<br>            <span class="hljs-type">float</span> h = <span class="hljs-built_in">m_historyLength</span>(ipos.x, ipos.y);<br>            <span class="hljs-keyword">if</span> (h &lt; <span class="hljs-number">4.0</span>)&#123;<span class="hljs-comment">// not enough temporal history available</span><br>                <span class="hljs-type">float</span> sumWIllumination = <span class="hljs-number">0.0</span>;<br>                Float3 sumIllumination = <span class="hljs-built_in">Float3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>                Float3 sumMoments = <span class="hljs-built_in">Float3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>                <span class="hljs-type">const</span> Float3 illuminationCenter = <span class="hljs-built_in">m_accColor</span>(ipos.x, ipos.y);<br>                <span class="hljs-type">const</span> <span class="hljs-type">float</span> lIlluminationCenter = <span class="hljs-built_in">Luminance</span>(illuminationCenter);<br><br>                <span class="hljs-type">const</span> Float3 nCenter = frameInfo.<span class="hljs-built_in">m_normal</span>(ipos.x, ipos.y);<br>                <span class="hljs-type">const</span> <span class="hljs-type">float</span> zCenter = frameInfo.<span class="hljs-built_in">m_depth</span>(ipos.x, ipos.y);<br>                <span class="hljs-comment">// depth-gradient estimation from screen-space derivatives</span><br>                <span class="hljs-type">float</span> dgrad_x = std::<span class="hljs-built_in">fmax</span>(<span class="hljs-number">1e-8</span>, std::<span class="hljs-built_in">fabs</span>(frameInfo.<span class="hljs-built_in">m_depth</span>(ipos.x + <span class="hljs-number">1</span>, ipos.y) - zCenter)) * <span class="hljs-number">3.0</span>;<br>                <span class="hljs-type">float</span> dgrad_y = std::<span class="hljs-built_in">fmax</span>(<span class="hljs-number">1e-8</span>, std::<span class="hljs-built_in">fabs</span>(frameInfo.<span class="hljs-built_in">m_depth</span>(ipos.x, ipos.y + <span class="hljs-number">1</span>) - zCenter)) * <span class="hljs-number">3.0</span>;<br>                <span class="hljs-type">float</span> maxDgrad = std::<span class="hljs-built_in">fmax</span>(dgrad_x, dgrad_y);<br><br>                <span class="hljs-comment">// compute first and second moment spatially. This code also applies cross-bilateral</span><br>                <span class="hljs-comment">// filtering on the input illumination.</span><br><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> yy = -radius; yy &lt;= radius; yy++) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> xx = -radius; xx &lt;= radius; xx++) &#123;<br>                        <span class="hljs-type">const</span> Float3 p = ipos + <span class="hljs-built_in">Float3</span>(xx, yy,<span class="hljs-number">0</span>);<br>                        <span class="hljs-type">bool</span> inside = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">if</span> (p.x &gt;= <span class="hljs-number">0</span> &amp;&amp; p.y &gt;= <span class="hljs-number">0</span> &amp;&amp; p.x &lt; width &amp;&amp; p.y &lt; height)<br>                            inside = <span class="hljs-literal">true</span>;<br><br>                        <span class="hljs-keyword">if</span> (inside) &#123;<br>                            <span class="hljs-type">const</span> Float3 illuminationP = <span class="hljs-built_in">m_accColor</span>(p.x, p.y);<br>                            <span class="hljs-type">const</span> Float3 momentsP = <span class="hljs-built_in">m_moments</span>(p.x, p.y);<br>                            <span class="hljs-type">const</span> <span class="hljs-type">float</span> lIlluminationP = <span class="hljs-built_in">Luminance</span>(illuminationP);<br>                            <span class="hljs-type">const</span> <span class="hljs-type">float</span> zP = frameInfo.<span class="hljs-built_in">m_depth</span>(p.x, p.y);<br>                            <span class="hljs-type">const</span> Float3 nP = frameInfo.<span class="hljs-built_in">m_normal</span>(p.x,p.y);<br><br>                            <span class="hljs-comment">// calculate the normal, depth and luminance weights</span><br>                            <span class="hljs-type">float</span> nw = <span class="hljs-built_in">normalWeight</span>(nCenter, nP);<br>                            <span class="hljs-type">float</span> dw = <span class="hljs-built_in">depthWeight</span>(zCenter, zP, maxDgrad,xx, yy);<br>                            <span class="hljs-type">float</span> lw = <span class="hljs-built_in">luminanceWeight</span>(lIlluminationCenter,<br>                                                       lIlluminationP, <span class="hljs-number">1.0</span>);<br>                            <span class="hljs-type">float</span> w = nw * dw * lw;<br>                            sumWIllumination += w;<br>                            sumIllumination += illuminationP * w;<br>                            sumMoments += momentsP * w;<br>                        &#125;<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-comment">// Clamp sum to &gt;0 to avoid NaNs.</span><br>                sumWIllumination = std::<span class="hljs-built_in">fmax</span>(sumWIllumination, <span class="hljs-number">1e-6</span>f);<br>                sumIllumination /= sumWIllumination;<br>                sumMoments /= sumWIllumination;<br><br>                <span class="hljs-comment">// compute variance using the first and second moments</span><br>                <span class="hljs-type">float</span> variance = sumMoments.y - sumMoments.x * sumMoments.x;<br><br>                <span class="hljs-comment">// give the variance a boost for the first frames</span><br>                <span class="hljs-keyword">if</span> (h != <span class="hljs-number">0</span>)<br>                    variance *= <span class="hljs-number">4.0</span> / h;<br><br>                <span class="hljs-built_in">m_tmpColor</span>(ipos.x, ipos.y) = sumIllumination;<br>                <span class="hljs-built_in">m_curFrameVariance</span>(ipos.x, ipos.y) = variance;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// do nothing</span><br>                <span class="hljs-built_in">m_tmpColor</span>(ipos.x, ipos.y) = <span class="hljs-built_in">m_accColor</span>(ipos.x, ipos.y);<br>            &#125;<br>        &#125;<br>    &#125;<br>    std::<span class="hljs-built_in">swap</span>(m_tmpColor, m_accColor);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>本质上来说我们只对出现了<code>disocclusion事件</code>的前几帧进行空间上的方差估计，直到时间累积收集了足够的数据来进行稳定的估计。权重计算函数在下一节讲。</p>
<h3 id="Edge-Stopping-Functions"><a href="#Edge-Stopping-Functions" class="headerlink" title="Edge-Stopping Functions"></a>Edge-Stopping Functions</h3><h4 id="Depth"><a href="#Depth" class="headerlink" title="Depth"></a>Depth</h4><p>真实的场景在几何尺度上有很大的变化，尤其是在开阔的景观中。使得全局边缘停止函数不受控制。因此，我们对表面深度设定了一个局部线性模型，并且测量其表面深度的偏差。我们使用剪切空间深度（只要是线性深度即可，本文使用的深度信息应该属于view space）的屏幕空间偏导数来估计局部深度模型。该权重函数为：<br>$$<br>w_{z}&#x3D;exp(-\dfrac{\left| z(p)-z(q) \right|}{\sigma_{z} \left| \nabla z(p) \cdot (p-q) \right|+\epsilon})<br>$$<br>根据经验$\sigma_{z}$为<code>1.0</code>可以得到比较好的效果，用来控制深度的影响是大还是小。<br>$\nabla z$是屏幕坐标下深度的梯度，$\epsilon$是防止除以零。代码实现如下：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">Denoiser_SVGF::depthWeight</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">float</span> center_depth, <span class="hljs-type">const</span> <span class="hljs-type">float</span> depth,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">const</span> <span class="hljs-type">float</span> dgrad, </span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">const</span> <span class="hljs-type">float</span> offset_x, <span class="hljs-type">const</span> <span class="hljs-type">float</span> offset_y)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span> eps = <span class="hljs-number">1e-8</span>;<br>    Float3 offset&#123;offset_x, offset_y,<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">exp</span>( (-std::<span class="hljs-built_in">fabs</span>(center_depth - depth)) / (std::<span class="hljs-built_in">fabs</span>( m_phiDepth * dgrad * <span class="hljs-built_in">Length</span>(offset)+ eps)) );<br>&#125;<br></code></pre></td></tr></table></figure>
<p>本应该是$\nabla z(p) \cdot (p-q)$即梯度点乘偏移，梯度和偏移都是二维向量。但是这里的写法是，取梯度中较大的一个偏导数作为一维梯度值 然后乘上 偏移向量的长度。其结果相差不大，至于论文源码为什么要这么算目前不得而知，两种算法得到的结果我都看了一下几乎没区别，读者有兴趣可以去试下。</p>
<h4 id="Normal"><a href="#Normal" class="headerlink" title="Normal"></a>Normal</h4><p>法线权重比较简单，法线夹角小权重大，反之权重小。公式如下：<br>$$<br>w_{n}&#x3D;max(0,n(p)\cdot n(q))^{\sigma_{n}}<br>$$<br>$\sigma_{n}$按经验来说为<code>128</code>效果比较好，用来控制法线的权重。<br>代码实现如下：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">Denoiser_SVGF::normalWeight</span><span class="hljs-params">(<span class="hljs-type">const</span> Float3 &amp;center_normal, <span class="hljs-type">const</span> Float3 &amp;normal)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">pow</span>(std::<span class="hljs-built_in">fmax</span>(<span class="hljs-number">0.0</span>, <span class="hljs-built_in">Dot</span>(center_normal, normal)), m_phiNormal);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="Luminance"><a href="#Luminance" class="headerlink" title="Luminance"></a>Luminance</h4><p>亮度边缘停止函数的一个关键方面是它能够通过其局部标准差重新归一化亮度，来自动适应所有亮度。但是，在低样本数下操作会在我们对方差和标准差的估计中引入不稳定性；这可能会引入走样现象。为了避免这些问题，我们使用<code>3 * 3</code>高斯核对方差图像进行预滤波，这显著提高了重建质量。亮度边缘停止函数变为：<br>$$<br>w_{l}&#x3D;exp(-\dfrac{|l_{i}(p)-l_{i}(q)|}{\sigma_{l}\sqrt{g_{3\times3}(Var(l_{i}(p)))}+\epsilon})<br>$$<br>根据经验$\sigma_{l}$为<code>4</code>效果比较好，用于控制亮度的影响。<br>由于亮度方差往往会随着后续迭代而减少，因此$w_{l}$的影响会随着每次迭代而增加，从而防止过度模糊。<br>需要注意的是，这个高斯预滤波器仅用于驱动亮度边缘停止函数，而不用于传播到小波变换下的一次迭代的方差中。<br>代码实现如下：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">Denoiser_SVGF::computeVarianceCenter</span><span class="hljs-params">(<span class="hljs-type">const</span> Float3&amp; ipos,<span class="hljs-type">const</span> <span class="hljs-type">int</span> width,<span class="hljs-type">const</span> <span class="hljs-type">int</span> height)</span> </span>&#123;<br>    <span class="hljs-type">float</span> sum = <span class="hljs-number">0.f</span>;<br>    <br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span> kernel[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">1.0</span> / <span class="hljs-number">4.0</span>, <span class="hljs-number">1.0</span> / <span class="hljs-number">8.0</span>&#125;, &#123;<span class="hljs-number">1.0</span> / <span class="hljs-number">8.0</span>, <span class="hljs-number">1.0</span> / <span class="hljs-number">16.0</span>&#125;&#125;;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> radius = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> yy = -radius; yy &lt;= radius; yy++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> xx = -radius; xx &lt;= radius; xx++) &#123;<br>            Float3 p = ipos + <span class="hljs-built_in">Float3</span>(xx, yy,<span class="hljs-number">0</span>);<br>            p.x = std::<span class="hljs-built_in">fmin</span>(std::<span class="hljs-built_in">fmax</span>(p.x, <span class="hljs-number">0.0</span>), width - <span class="hljs-number">1.0</span>);<br>            p.y = std::<span class="hljs-built_in">fmin</span>(std::<span class="hljs-built_in">fmax</span>(p.y, <span class="hljs-number">0.0</span>), height - <span class="hljs-number">1.0</span>);<br>            <span class="hljs-type">const</span> <span class="hljs-type">float</span> k = kernel[std::<span class="hljs-built_in">abs</span>(xx)][std::<span class="hljs-built_in">abs</span>(yy)];<br>            sum += <span class="hljs-built_in">m_curFrameVariance</span>(p.x,p.y) * k;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">float</span> variance = <span class="hljs-built_in">computeVarianceCenter</span>(ipos,width,height);<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">Denoiser_SVGF::luminanceWeight</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">float</span> center_lum, <span class="hljs-type">const</span> <span class="hljs-type">float</span> lum,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">const</span> <span class="hljs-type">float</span> variance</span></span><br><span class="hljs-params"><span class="hljs-function">)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span> eps = <span class="hljs-number">1e-10</span>;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">exp</span>( (-std::<span class="hljs-built_in">fabs</span>(center_lum - lum)) /<br>               (m_phiColor * std::<span class="hljs-built_in">sqrt</span>(std::<span class="hljs-built_in">fmax</span>(<span class="hljs-number">0.0</span>, variance) + eps)));<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>kernel</code>是 $\sigma$为0.8的高斯滤波核，上文有提到。</p>
<h3 id="Edge-avoiding-A-trous-wavelet-transform"><a href="#Edge-avoiding-A-trous-wavelet-transform" class="headerlink" title="Edge-avoiding A-trous wavelet transform"></a>Edge-avoiding A-trous wavelet transform</h3><p><code>Reconstruction Filter</code>的最后最重要的一步，<code>Reproject</code>（Temporal Filtering）以及<code>Variance Estimation</code>都是为了这一步做铺垫。上文说到光栅化的<code>G-buffer</code>不包含随机噪声，使我们能够使用<code>G-buffer</code>来定义边缘停止函数，这些函数可以用来鉴别像素是否在同一表面，从而进行相互贡献。该论文的实现也使用了<code>A-trous wavelet</code>方法（上文有提及），权重函数 $w(p,q)$使用的是一个<code>5 * 5</code>的联合双边滤波核。公式如下：<br>$$<br>\hat{c}<em>{i+1(p)}&#x3D;\dfrac{\sum</em>{q\in\Omega}h(q)\cdot w(p,q)\cdot \hat{c}<em>{i}(q)}{\sum</em>{q\in\Omega}h(q)\cdot w(p,q)}<br>$$<br>$h(q)$是一个类高斯滤波核，论文和本此实现使用的 $h(q)$权重系数不太一样不过没关系，都是随距离衰减的函数就行。 $\Omega$是滤波器中被收集的像素集合（就是每一趟中踩到的像素点的集合）<br>$\hat{c}<em>{i+1(p)}$和 $\hat{c}</em>{i(p)}$则是滤波后的输出颜色以及滤波前的输入颜色。  </p>
<p>该论文新颖的权重函数 $w(p,q)$使用的是深度、世界空间法线以及<code>Filter</code>后输入的<code>Luminance</code>，公式如下：<br>$$<br>w_{i}(p,q)&#x3D;w_{z}\cdot w_{n}\cdot w_{l}<br>$$<br>这几个函数在上一节我已经详细解释了。</p>
<p>在应用<code>A-trous wavelet</code>过程中，我们会基于亮度方差的局部估计来调整亮度边缘停止函数。然后根据<code>A-trous wavelet</code>来<code>Filter</code>时间上累计的颜色，并假设我们采样到的方差样本是不相关的（相互独立），则我们向下一次<code>A-trous wavelet</code>传递方差的公式为：<br>$$<br>Var(\hat{c}<em>{i+1(p)})&#x3D;\dfrac{\sum</em>{q\in\Omega}h(q)^{2}\cdot w(p,q)^{2}\cdot Var(\hat{c}<em>{i}(q))}{(\sum</em>{q\in\Omega}h(q)\cdot w(p,q))^{2}}<br>$$<br>我们会使用这个结果来控制下一次<code>A-trous wavelet</code>的边缘停止函数。<br>代码实现如下：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Denoiser_SVGF::ATrousWaveletFilter</span><span class="hljs-params">(<span class="hljs-type">const</span> FrameInfo &amp;frameInfo,<span class="hljs-type">const</span> <span class="hljs-type">int</span> stepSize)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> height = frameInfo.m_beauty.m_height;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> width = frameInfo.m_beauty.m_width;<br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span> kernelWeights[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span> / <span class="hljs-number">3.0</span>, <span class="hljs-number">1.0</span> / <span class="hljs-number">6.0</span>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel for</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; height; y++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; width; x++) &#123;<br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> SVGF</span><br>            <span class="hljs-type">const</span> Float3 ipos = <span class="hljs-built_in">Float3</span>(x, y, <span class="hljs-number">0</span>);<br>            <span class="hljs-type">const</span> Float3 illuminationCenter = <span class="hljs-built_in">m_accColor</span>(ipos.x, ipos.y);<br>            <span class="hljs-type">const</span> <span class="hljs-type">float</span> lIlluminationCenter = <span class="hljs-built_in">Luminance</span>(illuminationCenter);<br><br>            <span class="hljs-comment">//variance,filtered using 3 * 3 gaussin blur</span><br>            <span class="hljs-type">const</span> <span class="hljs-type">float</span> var = <span class="hljs-built_in">computeVarianceCenter</span>(ipos,width,height);<br><br>            <span class="hljs-type">const</span> <span class="hljs-type">float</span> zCenter = frameInfo.<span class="hljs-built_in">m_depth</span>(ipos.x, ipos.y);<br>            <span class="hljs-type">const</span> Float3 nCenter = frameInfo.<span class="hljs-built_in">m_normal</span>(ipos.x, ipos.y);<br><br>            <span class="hljs-type">float</span> dgrad_x = std::<span class="hljs-built_in">fmax</span>(<span class="hljs-number">1e-8</span>, std::<span class="hljs-built_in">fabs</span>(frameInfo.<span class="hljs-built_in">m_depth</span>(ipos.x + <span class="hljs-number">1</span>, ipos.y) - zCenter)) * stepSize;<br>            <span class="hljs-type">float</span> dgrad_y = std::<span class="hljs-built_in">fmax</span>(<span class="hljs-number">1e-8</span>, std::<span class="hljs-built_in">fabs</span>(frameInfo.<span class="hljs-built_in">m_depth</span>(ipos.x, ipos.y + <span class="hljs-number">1</span>) - zCenter)) * stepSize;<br>            <br>            <span class="hljs-type">float</span> maxDgrad = std::<span class="hljs-built_in">fmax</span>(dgrad_x, dgrad_y);<br><br>            <span class="hljs-comment">//explicitly store/accumulate center pixel with weight 1 to prevent issues</span><br>            <span class="hljs-comment">//with the edge-stopping functions</span><br>            <span class="hljs-type">float</span> sumWIllumination = <span class="hljs-number">1.0</span>;<br>            <span class="hljs-type">float</span> sumVariance = <span class="hljs-built_in">m_curFrameVariance</span>(ipos.x, ipos.y);<br>            Float3 sumIllumination = illuminationCenter;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> yy = <span class="hljs-number">-2</span>; yy &lt;= <span class="hljs-number">2</span>; yy++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> xx = <span class="hljs-number">-2</span>; xx &lt;= <span class="hljs-number">2</span>; xx++) &#123;<br>                    <span class="hljs-type">const</span> Float3 p = ipos + <span class="hljs-built_in">Float3</span>(xx, yy,<span class="hljs-number">0</span>) * stepSize;<br>                    <span class="hljs-type">bool</span> inside = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">if</span> (p.x &gt;= <span class="hljs-number">0</span> &amp;&amp; p.y &gt;= <span class="hljs-number">0</span> &amp;&amp; p.x &lt; width &amp;&amp; p.y &lt; height)<br>                        inside = <span class="hljs-literal">true</span>;<br><br>                    <span class="hljs-type">const</span> <span class="hljs-type">float</span> kernel = kernelWeights[std::<span class="hljs-built_in">abs</span>(xx)] * kernelWeights[std::<span class="hljs-built_in">abs</span>(yy)];<br><br>                    <span class="hljs-keyword">if</span> (inside &amp;&amp;<br>                        (xx != <span class="hljs-number">0</span> ||<br>                         yy != <span class="hljs-number">0</span>)) <span class="hljs-comment">// skip center pixel, it is already accumulated</span><br>                    &#123;<br>                        <span class="hljs-type">const</span> Float3 illuminationP = <span class="hljs-built_in">m_accColor</span>(p.x,p.y);<br>                        <span class="hljs-type">const</span> <span class="hljs-type">float</span> lIlluminationP = <span class="hljs-built_in">Luminance</span>(illuminationP);<br>                        <span class="hljs-type">const</span> <span class="hljs-type">float</span> zP = frameInfo.<span class="hljs-built_in">m_depth</span>(p.x,p.y);<br>                        <span class="hljs-type">const</span> Float3 nP = frameInfo.<span class="hljs-built_in">m_normal</span>(p.x,p.y);<br>                        <span class="hljs-type">const</span> <span class="hljs-type">float</span> varP = <span class="hljs-built_in">m_curFrameVariance</span>(p.x,p.y);<br><br>                        <span class="hljs-comment">// calculate the normal, depth and luminance weights</span><br>                        <span class="hljs-type">float</span> nw = <span class="hljs-built_in">normalWeight</span>(nCenter, nP);<br>                        <span class="hljs-type">float</span> dw = <span class="hljs-built_in">depthWeight</span>(zCenter, zP, maxDgrad, xx, yy);<br>                        <span class="hljs-type">float</span> lw = <span class="hljs-built_in">luminanceWeight</span>(lIlluminationCenter, lIlluminationP, var);<br><br>                        <span class="hljs-type">const</span> <span class="hljs-type">float</span> wIllumination = nw * dw * lw * kernel;<br><br>                        <span class="hljs-comment">// alpha channel contains the variance, therefore the weights need</span><br>                        <span class="hljs-comment">// to be squared, see paper for the formula(4.3 (1) (2))</span><br>                        sumWIllumination += wIllumination;<br>                        sumIllumination += <span class="hljs-built_in">Float3</span>(wIllumination) * illuminationP;<br>                        sumVariance += wIllumination * wIllumination * varP;<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// renormalization is different for variance, check paper for the formula</span><br>            <span class="hljs-built_in">m_tmpColor</span>(ipos.x, ipos.y) = sumIllumination / sumWIllumination;<br>            <span class="hljs-built_in">m_tmpCurFrameVar</span>(ipos.x, ipos.y) = sumVariance / (sumWIllumination * sumWIllumination);<br>        &#125;<br>    &#125;<br>    std::<span class="hljs-built_in">swap</span>(m_tmpColor,m_accColor);<br>    std::<span class="hljs-built_in">swap</span>(m_tmpCurFrameVar,m_curFrameVariance);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>Step Size</code>为$2^{i},i\in([0,4] \cap \mathbb{Z})$  </p>
<p>Cornell Box效果如下：<br><img src="/img/00019/box-svgf.gif" srcset="/img/loading.gif" lazyload alt="1"><br>Pink Room效果如下:<br><img src="/img/00019/pinkroom-svgf.gif" srcset="/img/loading.gif" lazyload alt="2"><br>这是降噪前的图片：<br><img src="/img/00019/image-10.png" srcset="/img/loading.gif" lazyload alt="Alt text"><br><img src="/img/00019/image-11.png" srcset="/img/loading.gif" lazyload alt="Alt text">  </p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Games202/" class="category-chain-item">Games202</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Games202 Hw5 JBF and SVGF</div>
      <div>https://howl144.github.io/2023/07/21/00019. Games202 Hw5/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Deng Ye</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>July 21, 2023</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/02/19/00006.%20c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B9%8B%E8%99%9A%E8%A1%A8%EF%BC%8C%E8%99%9A%E8%A1%A8%E6%8C%87%E9%92%88%E7%AD%89/" title="c++对象模型之虚表，虚表指针，thunk，多态，多重继承this指针偏移，多重继承virtual析构函数，多重虚继承下的访问虚基类成员变量时虚表的工作原理">
                        <span class="hidden-mobile">c++对象模型之虚表，虚表指针，thunk，多态，多重继承this指针偏移，多重继承virtual析构函数，多重虚继承下的访问虚基类成员变量时虚表的工作原理</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        Views: 
        <span id="leancloud-site-pv"></span>
        
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        Visitors: 
        <span id="leancloud-site-uv"></span>
        
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
