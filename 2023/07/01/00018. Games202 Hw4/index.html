

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <meta name="google-site-verification" content="elv6HP48K6bVVMeBdbFYkmoi4IBF6JVtH0WaCgUXRNY" />
  <link rel="apple-touch-icon" sizes="76x76" href="/img/rose.png">
  <link rel="icon" href="/img/rose.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Deng Ye">
  <meta name="keywords" content="">
  
    <meta name="description" content="最终效果图 每组下面一排球是没用Kulla Conty的对照组，所有球的金属度都为1,粗糙度最小0.05，最大0.95,可以明显看到对照组随着粗糙度增大，会越来越暗，而使用了Kulla Conty的实验组，亮度不会随着粗糙度的增加而衰减，为了使现象更明显这里吧HDR tonemapping功能禁用了！  下面是金材质的Kulla-Conty Approximation效果：  作业总览">
<meta property="og:type" content="article">
<meta property="og:title" content="Games202 Hw4 IBL and Kulla Conty">
<meta property="og:url" content="https://howl144.github.io/2023/07/01/00018.%20Games202%20Hw4/index.html">
<meta property="og:site_name" content="🥰Howl&#39;s Blog">
<meta property="og:description" content="最终效果图 每组下面一排球是没用Kulla Conty的对照组，所有球的金属度都为1,粗糙度最小0.05，最大0.95,可以明显看到对照组随着粗糙度增大，会越来越暗，而使用了Kulla Conty的实验组，亮度不会随着粗糙度的增加而衰减，为了使现象更明显这里吧HDR tonemapping功能禁用了！  下面是金材质的Kulla-Conty Approximation效果：  作业总览">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://howl144.github.io/img/00018/result.png">
<meta property="article:published_time" content="2023-06-30T23:34:10.000Z">
<meta property="article:modified_time" content="2023-08-23T14:54:00.890Z">
<meta property="article:author" content="Deng Ye">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://howl144.github.io/img/00018/result.png">
  
  
  
  <title>Games202 Hw4 IBL and Kulla Conty - 🥰Howl&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"howl144.github.io","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"MY3hK2j6KKqPNCHItX2Yargj-gzGzoHsz","app_key":"U0dZRBpPFA46kRmFcsltQFF2","server_url":"https://my3hk2j6.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Howl&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Portfolio/">
                <i class="iconfont icon-pen"></i>
                <span>Portfolio</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>Category</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archive</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>About Me</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/post.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.5)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Games202 Hw4 IBL and Kulla Conty"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-07-01 07:34" pubdate>
          July 1, 2023 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          30k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          251 mins
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> views
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Games202 Hw4 IBL and Kulla Conty</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="最终效果图">最终效果图</h1>
<p>每组下面一排球是没用<code>Kulla Conty</code>的对照组，所有球的金属度都为<code>1</code>,粗糙度最小<code>0.05</code>，最大<code>0.95</code>,可以明显看到对照组随着粗糙度增大，会越来越暗，而使用了<code>Kulla Conty</code>的实验组，亮度不会随着粗糙度的增加而衰减，为了使现象更明显这里吧<code>HDR tonemapping</code>功能禁用了！
<img src="/img/00018/result.png" srcset="/img/loading.gif" lazyload alt="0" /><br />
下面是金材质的<code>Kulla-Conty Approximation</code>效果：<br />
<img src="/img/00018/image-15.png" srcset="/img/loading.gif" lazyload alt="1" /></p>
<h1 id="作业总览">作业总览</h1>
<ol type="1">
<li>实现预计算<span class="math inline">\(E(\mu)\)</span></li>
<li>实现预计算<span class="math inline">\(E_{avg}\)</span></li>
<li>正确实现PBR材质</li>
<li>正确实现Kulla-Conty材质</li>
<li>提高1：实现重要性采样的预计算方法<br />
</li>
<li>提高2：在预计算<span
class="math inline">\(E(\mu)\)</span>时，使用<code>Split Sum</code>完成预计算工作</li>
</ol>
<p>个人扩展部分：<code>Image Based Lighting</code></p>
<h1 id="源码">源码</h1>
<p>暂未公开</p>
<h1 id="webgl代码框架的理解">Webgl代码框架的理解</h1>
<p>这部分代码主要解释我们需要的地方，太过于细节的地方本节内容不做解释，只去理解那些能帮助我实现想要效果的代码。</p>
<h2 id="模型加载">模型加载</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> pbrSphere1Transform = <span class="hljs-title function_">setTransform</span>(<span class="hljs-number">360</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">180</span>, <span class="hljs-number">180</span>, <span class="hljs-number">180</span>, <span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>, <span class="hljs-number">0</span>);<br>	<span class="hljs-title function_">loadGLTF</span>(renderer, <span class="hljs-string">&#x27;assets/ball/&#x27;</span>, <span class="hljs-string">&#x27;ball&#x27;</span>, <span class="hljs-string">&#x27;PBRMaterial&#x27;</span>, pbrSphere1Transform,irradianceMap,prefilterMap,pbrBrdfLutObj,metallic,<span class="hljs-number">0.95</span>);<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadGLTF</span>(<span class="hljs-params">renderer, path, name, objMaterial, transform,irradianceMap,prefilterMap,pbrBrdfLut, metallic=<span class="hljs-number">1.0</span>, roughness=<span class="hljs-number">0.2</span></span>)&#123;<br>    ...<br>	<span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">GLTFLoader</span>(manager)<br>		.<span class="hljs-title function_">setPath</span>(path)<br>		.<span class="hljs-title function_">load</span>(name + <span class="hljs-string">&#x27;.gltf&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">gltf</span>) &#123;<br>			gltf.<span class="hljs-property">scene</span>.<span class="hljs-title function_">traverse</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">child</span>) &#123;<br>				<span class="hljs-keyword">if</span> (child.<span class="hljs-property">isMesh</span>) &#123;<br>                    ...<br>					<span class="hljs-keyword">let</span> colorMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Texture</span>(renderer.<span class="hljs-property">gl</span>);<br>					...<br>                    <span class="hljs-comment">//gold : 0.94423,0.77611,0.37217</span><br>                    <span class="hljs-keyword">let</span> kd = [<span class="hljs-number">1.00</span>,<span class="hljs-number">1.00</span>, <span class="hljs-number">1.00</span>]; <span class="hljs-comment">//albedo</span><br>                    colorMap.<span class="hljs-title class_">CreateConstantTexture</span>(renderer.<span class="hljs-property">gl</span>, kd, <span class="hljs-literal">true</span>);<br>					<span class="hljs-keyword">let</span> material;<br>					<span class="hljs-keyword">switch</span> (objMaterial) &#123;<br>						<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;KullaContyMaterial&#x27;</span>:<br>							material = <span class="hljs-title function_">buildKullaContyMaterial</span>(colorMap,metallic,roughness,irradianceMap,prefilterMap,pbrBrdfLut,kullaContyBrdflut,kullaContyEavglut,<span class="hljs-string">&quot;./src/shaders/kullaContyShader/KullaContyVertex.glsl&quot;</span>, <span class="hljs-string">&quot;./src/shaders/kullaContyShader/KullaContyFragment.glsl&quot;</span>);<br>							<span class="hljs-keyword">break</span>;<br>						<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;PBRMaterial&#x27;</span>:<br>							material = <span class="hljs-title function_">buildPBRMaterial</span>(colorMap,metallic,roughness,irradianceMap,prefilterMap,pbrBrdfLut,<span class="hljs-string">&quot;./src/shaders/pbrShader/PBRVertex.glsl&quot;</span>, <span class="hljs-string">&quot;./src/shaders/pbrShader/PBRFragment.glsl&quot;</span>);<br>							<span class="hljs-keyword">break</span>;<br>					&#125;<br>					material.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>						<span class="hljs-keyword">let</span> meshRender = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MeshRender</span>(renderer.<span class="hljs-property">gl</span>, mesh, data,objMaterial);<br>						renderer.<span class="hljs-title function_">addMeshRender</span>(meshRender);<br>					&#125;);<br>				&#125;<br>			&#125;);<br>		&#125;);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>模型加载主要就看这部分，打了省略的部分不需要去理解。<br />
<code>colorMap</code>获取创建的纹理<code>ID</code>,<code>kD</code>是<code>albedo</code>，只为了观察能量损失和补充直接填<code>1.0</code>就行，<code>CreateConstantTexture</code>用<code>albedo</code>创建一张宽高为<code>1</code>的纹理。<br />
<code>buildKullaContyMaterial</code>是一个异步函数，函数执行完成后就会进入回调部分<code>material.then((data))</code>,<code>data</code>才是函数的返回值。<br />
<code>child.isMesh</code>会判断模型的子节点是否为<code>mesh</code>节点，经过<code>debug</code>发现，该<code>ball</code>模型有<code>4</code>个子节点，也就说会进入回调部分<code>material.then((data))</code>4次。</p>
<h2 id="shader编译">shader编译</h2>
<p>在理解框架<code>shader</code>编译之前需要把材质类型熟悉一下，以<code>PBRMaterial.js</code>为例:<br />
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Material</span> &#123;<br>    #flatten_uniforms;<br>    #flatten_attribs;<br>    #vsSrc;<br>    #fsSrc;<br>    <span class="hljs-comment">// Uniforms is a map, attribs is a Array</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">uniforms, attribs, vsSrc, fsSrc, frameBuffer</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">uniforms</span> = uniforms;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">attribs</span> = attribs;<br>        <span class="hljs-variable language_">this</span>.#vsSrc = vsSrc;<br>        <span class="hljs-variable language_">this</span>.#fsSrc = fsSrc;<br><br>        <span class="hljs-variable language_">this</span>.#flatten_uniforms = [<span class="hljs-string">&#x27;uViewMatrix&#x27;</span>,<span class="hljs-string">&#x27;uModelMatrix&#x27;</span>, <span class="hljs-string">&#x27;uProjectionMatrix&#x27;</span>, <span class="hljs-string">&#x27;uCameraPos&#x27;</span>, <span class="hljs-string">&#x27;uLightPos&#x27;</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> uniforms) &#123;<br>            <span class="hljs-variable language_">this</span>.#flatten_uniforms.<span class="hljs-title function_">push</span>(k);<br>        &#125;<br>        <span class="hljs-variable language_">this</span>.#flatten_attribs = attribs;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">frameBuffer</span> = frameBuffer;<br>    &#125;<br>    <span class="hljs-title function_">setMeshAttribs</span>(<span class="hljs-params">extraAttribs</span>) &#123;<br>    <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; extraAttribs.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-variable language_">this</span>.#flatten_attribs.<span class="hljs-title function_">push</span>(extraAttribs[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-title function_">compile</span>(<span class="hljs-params">gl</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Shader</span>(gl, <span class="hljs-variable language_">this</span>.#vsSrc, <span class="hljs-variable language_">this</span>.#fsSrc,<br>            &#123;<br>                <span class="hljs-attr">uniforms</span>: <span class="hljs-variable language_">this</span>.#flatten_uniforms,<br>                <span class="hljs-attr">attribs</span>: <span class="hljs-variable language_">this</span>.#flatten_attribs<br>            &#125;);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PBRMaterial</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Material</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">albedo, metallic,roughness,irradianceMap,prefilterMap,pbrBrdfLut, vertexShader, fragmentShader</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(&#123;<br>            <span class="hljs-string">&#x27;uAlbedoMap&#x27;</span>:          &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;texture&#x27;</span>, <span class="hljs-attr">value</span>: albedo &#125;,<br>            <span class="hljs-string">&#x27;uMetallic&#x27;</span>:        &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;1f&#x27;</span>, <span class="hljs-attr">value</span>: metallic &#125;,<br>            ...<br>            <span class="hljs-comment">// &#x27;uLightPos[4]&#x27;: &#123; type: &#x27;3fv&#x27;, value: null &#125;,</span><br>            <span class="hljs-comment">// &#x27;uLightColors[4]&#x27;: &#123; type: &#x27;3fv&#x27;, value: null &#125;,</span><br>        &#125;, [], vertexShader, fragmentShader);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">buildPBRMaterial</span>(<span class="hljs-params">albedo, metallic,roughness,irradianceMap,prefilterMap,pbrBrdfLut, vertexPath, fragmentPath</span>) &#123;<br>    <span class="hljs-keyword">let</span> vertexShader = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getShaderString</span>(vertexPath);<br>    <span class="hljs-keyword">let</span> fragmentShader = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getShaderString</span>(fragmentPath);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PBRMaterial</span>(albedo, metallic,roughness,irradianceMap,prefilterMap,pbrBrdfLut, vertexShader, fragmentShader);<br>&#125;<br></code></pre></td></tr></table></figure>
各种材质类都是继承自父类<code>Material</code>,子类部分只负责填写对应<code>shader</code>需要<code>uniform</code>的变量，子类用<code>super</code>关键字来对父类进行初始化，随后填写<code>uniform</code>数据全部被保存入父类私有变量<code>#flatten_uniforms</code>中，父类还包含了一些常用<code>uniform</code>变量<code>'uViewMatrix','uModelMatrix'...</code>,这些名字在不同的<code>vertex</code>和<code>fragment</code>中名字都是统一的,可自行修改，数组<code>uniform</code>变量需要自己手动设置，框架没有对这类变量进行解析。<br />
<code>this.#vsSrc</code>和<code>this.#fsSrc</code>保存的<code>shader</code>文件路径，<code>#this.attribs</code>保存的<code>vertexShader</code>的<code>location</code>变量名字，比如:<br />
<code>layout (location = 0) in vec3 aVertexPosition;</code>中的<code>aVertexPosition</code>，所以在<code>vertexShader</code>中不要更改它的名字，名字都是来源于<code>mesh</code>节点，在<code>MeshRender.js</code>文件中会判断<code>mesh</code>节点是否包含该属性名字，有的话就调用该材质的<code>setMeshAttribs</code>函数将名字存入<code>#this.attribs</code>。<br />
在调用<code>compile()</code>函数的时候，<code>shader</code>路径，<code>uniform</code>变量名，<code>attribs</code>变量名字会一同传入<code>new</code>出来的<code>shader</code>对象。<br />
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shader</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">gl, vsSrc, fsSrc, shaderLocations</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">gl</span> = gl;<br>        <span class="hljs-keyword">const</span> vs = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compileShader</span>(vsSrc, gl.<span class="hljs-property">VERTEX_SHADER</span>);<br>        <span class="hljs-keyword">const</span> fs = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compileShader</span>(fsSrc, gl.<span class="hljs-property">FRAGMENT_SHADER</span>);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">program</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addShaderLocations</span>(&#123;<br>            <span class="hljs-attr">glShaderProgram</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">linkShader</span>(vs, fs),<br>        &#125;, shaderLocations);<br>    &#125;<br>    <span class="hljs-title function_">compileShader</span>(<span class="hljs-params">shaderSource, shaderType</span>) &#123;<br>        <span class="hljs-keyword">const</span> gl = <span class="hljs-variable language_">this</span>.<span class="hljs-property">gl</span>;<br>        <span class="hljs-keyword">var</span> shader = gl.<span class="hljs-title function_">createShader</span>(shaderType);<br>        ...<br>        <span class="hljs-keyword">return</span> shader;<br>    &#125;;<br>    <span class="hljs-title function_">linkShader</span>(<span class="hljs-params">vs, fs</span>) &#123;<br>        <span class="hljs-keyword">const</span> gl = <span class="hljs-variable language_">this</span>.<span class="hljs-property">gl</span>;<br>        <span class="hljs-keyword">var</span> prog = gl.<span class="hljs-title function_">createProgram</span>();<br>        ...<br>        <span class="hljs-keyword">return</span> prog;<br>    &#125;;<br>    <span class="hljs-title function_">addShaderLocations</span>(<span class="hljs-params">result, shaderLocations</span>) &#123;<br>        <span class="hljs-keyword">const</span> gl = <span class="hljs-variable language_">this</span>.<span class="hljs-property">gl</span>;<br>        result.<span class="hljs-property">uniforms</span> = &#123;&#125;;<br>        result.<span class="hljs-property">attribs</span> = &#123;&#125;;<br>        <span class="hljs-keyword">if</span> (shaderLocations &amp;&amp; shaderLocations.<span class="hljs-property">uniforms</span> &amp;&amp; shaderLocations.<span class="hljs-property">uniforms</span>.<span class="hljs-property">length</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; shaderLocations.<span class="hljs-property">uniforms</span>.<span class="hljs-property">length</span>; ++i) &#123;<br>                result.<span class="hljs-property">uniforms</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(result.<span class="hljs-property">uniforms</span>, &#123;<br>                    [shaderLocations.<span class="hljs-property">uniforms</span>[i]]: gl.<span class="hljs-title function_">getUniformLocation</span>(result.<span class="hljs-property">glShaderProgram</span>, shaderLocations.<span class="hljs-property">uniforms</span>[i]),<br>                &#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (shaderLocations &amp;&amp; shaderLocations.<span class="hljs-property">attribs</span> &amp;&amp; shaderLocations.<span class="hljs-property">attribs</span>.<span class="hljs-property">length</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; shaderLocations.<span class="hljs-property">attribs</span>.<span class="hljs-property">length</span>; ++i) &#123;<br>                result.<span class="hljs-property">attribs</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(result.<span class="hljs-property">attribs</span>, &#123;<br>                    [shaderLocations.<span class="hljs-property">attribs</span>[i]]: gl.<span class="hljs-title function_">getAttribLocation</span>(result.<span class="hljs-property">glShaderProgram</span>, shaderLocations.<span class="hljs-property">attribs</span>[i]),<br>                &#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
shader对象在构造函数中就完成了所有事情，<code>gl.createProgram()</code>这个函数返回shader的ID，该ID存储在<code>addShaderLocations()</code>这个函数中result对象里面，<code>&#123; glShaderProgram: this.linkShader(vs, fs) &#125;</code>这里是对result对象的初始化，后面又加了两个成员变量<code>result.uniforms</code>和<code>result.attribs</code>。<br />
重点是这个函数<code>addShaderLocations()</code>,<code>result.uniforms</code>和<code>result.attribs</code>存储的是一系列键值对，<code>key</code>是之前传入的uniform变量名，<code>value</code>是location后得到ID,<code>result.attribs</code>同理。<br />
所以在<code>MeshRender</code>对象中，进行<code>gl.useProgram()</code>,<code>gl.uniform()</code>,<code>gl.enableVertexAttribArray()</code>操作时，只需要所以用变量名来索引<code>shader.program</code>的shaderID，uniformID,attribsID以及即可,该<code>program</code>就对应上面说的<code>result</code>的内容。<br />
知道这些以后我们就可以自行对shader进行<code>uniform</code>,和<code>useProgram</code>操作,对于需要手动设置<code>uniform变量</code>如下：<br />
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>; l &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">lights</span>.<span class="hljs-property">length</span>; l++) &#123;<br>    ...<br>    <span class="hljs-comment">// Camera pass</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">meshes</span>.<span class="hljs-property">length</span>; i++) &#123;<br>        <br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">meshes</span>[i].<span class="hljs-property">materialName</span> == <span class="hljs-string">&quot;KullaContyMaterial&quot;</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">meshes</span>[i].<span class="hljs-property">materialName</span> == <span class="hljs-string">&quot;PBRMaterial&quot;</span>)&#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable constant_">ID</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">meshes</span>[i].<span class="hljs-property">shader</span>.<span class="hljs-property">program</span>.<span class="hljs-property">glShaderProgram</span>;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">gl</span>.<span class="hljs-title function_">useProgram</span>(<span class="hljs-variable constant_">ID</span>);<br>            gl.<span class="hljs-title function_">uniform3fv</span>(gl.<span class="hljs-title function_">getUniformLocation</span>(<br>                <span class="hljs-variable constant_">ID</span>, <span class="hljs-string">&quot;uLightPos&quot;</span> + <span class="hljs-string">&quot;[&quot;</span> + l + <span class="hljs-string">&quot;]&quot;</span>), <br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">lights</span>[l].<span class="hljs-property">entity</span>.<span class="hljs-property">lightPos</span>);<br>            gl.<span class="hljs-title function_">uniform3fv</span>(gl.<span class="hljs-title function_">getUniformLocation</span>(<br>                <span class="hljs-variable constant_">ID</span>, <span class="hljs-string">&quot;uLightColors&quot;</span> + <span class="hljs-string">&quot;[&quot;</span> + l + <span class="hljs-string">&quot;]&quot;</span>), <br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">lights</span>[l].<span class="hljs-property">entity</span>.<span class="hljs-property">lightRadiance</span>);<br>        &#125;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">meshes</span>[i].<span class="hljs-title function_">draw</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">camera</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
好的，框架核心的东西大概都讲完了，其他的地方根据上面说的内容，多看几遍就没任何问题了，下面讲下IBL。</p>
<h1 id="ibl">IBL</h1>
<p>IBL的实现流程如下：<br />
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//ibl</span><br><span class="hljs-keyword">let</span> envCubemap,irradianceMap,prefilterMap;<br><span class="hljs-keyword">let</span> pbrBrdfLutObj;<br><span class="hljs-keyword">let</span> hdrObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Texture</span>(gl);<br><span class="hljs-comment">//加载HDR文件</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">loadTexture</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>		<span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">RGBELoader</span>().<span class="hljs-title function_">load</span>(<span class="hljs-string">&quot;assets/winter_sky_1k.hdr&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">texture</span>) &#123;<br>			<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;HDR Loaded&quot;</span>);<br>			<span class="hljs-title function_">resolve</span>(texture);<br>		&#125;);<br>	&#125;);<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">integral</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-keyword">let</span> hdrData = <span class="hljs-keyword">await</span> <span class="hljs-title function_">loadTexture</span>();<br>	<span class="hljs-keyword">let</span> data = hdrData.<span class="hljs-property">image</span>.<span class="hljs-property">data</span>;<br>	<span class="hljs-keyword">let</span> width = hdrData.<span class="hljs-property">image</span>.<span class="hljs-property">width</span>;<br>	<span class="hljs-keyword">let</span> height = hdrData.<span class="hljs-property">image</span>.<span class="hljs-property">height</span>;<br>	gl.<span class="hljs-title function_">bindTexture</span>(gl.<span class="hljs-property">TEXTURE_2D</span>, hdrObj.<span class="hljs-property">texture</span>);<br>	gl.<span class="hljs-title function_">texImage2D</span>(gl.<span class="hljs-property">TEXTURE_2D</span>, <span class="hljs-number">0</span>, gl.<span class="hljs-property">RGBA</span>, width, height, <span class="hljs-number">0</span>, gl.<span class="hljs-property">RGBA</span>, gl.<span class="hljs-property">UNSIGNED_BYTE</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(data));<br>	<span class="hljs-comment">////debug texture</span><br>	<span class="hljs-comment">// gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,</span><br>	<span class="hljs-comment">// 	new Uint8Array([0, 0, 255, 255]));</span><br>	gl.<span class="hljs-title function_">texParameteri</span>(gl.<span class="hljs-property">TEXTURE_2D</span>, gl.<span class="hljs-property">TEXTURE_WRAP_S</span>, gl.<span class="hljs-property">CLAMP_TO_EDGE</span>);<br>	gl.<span class="hljs-title function_">texParameteri</span>(gl.<span class="hljs-property">TEXTURE_2D</span>, gl.<span class="hljs-property">TEXTURE_WRAP_T</span>, gl.<span class="hljs-property">CLAMP_TO_EDGE</span>);<br>	gl.<span class="hljs-title function_">texParameteri</span>(gl.<span class="hljs-property">TEXTURE_2D</span>, gl.<span class="hljs-property">TEXTURE_MIN_FILTER</span>, gl.<span class="hljs-property">LINEAR</span>);<br>	gl.<span class="hljs-title function_">texParameteri</span>(gl.<span class="hljs-property">TEXTURE_2D</span>, gl.<span class="hljs-property">TEXTURE_MAG_FILTER</span>, gl.<span class="hljs-property">LINEAR</span>);<br>	gl.<span class="hljs-title function_">bindTexture</span>(gl.<span class="hljs-property">TEXTURE_2D</span>, <span class="hljs-literal">null</span>);<br>	<span class="hljs-title function_">getErrorMessage</span>(gl,<span class="hljs-string">&quot;engine.js&quot;</span>);<br>	<span class="hljs-keyword">let</span> ibl = <span class="hljs-keyword">new</span> <span class="hljs-title function_">IBL</span>(gl,hdrObj.<span class="hljs-property">texture</span>);<br>	<span class="hljs-keyword">await</span> ibl.<span class="hljs-title function_">init</span>();<br>	envCubemap = ibl.<span class="hljs-title function_">caculateEnvCubemap</span>();<br>	irradianceMap = ibl.<span class="hljs-title function_">caculateIrradianceMap</span>();<br>	prefilterMap = ibl.<span class="hljs-title function_">caculatePrefilterMap</span>();<br>	pbrBrdfLutObj = ibl.<span class="hljs-title function_">caculateLut</span>();<br>&#125;<br><span class="hljs-keyword">await</span> <span class="hljs-title function_">integral</span>();<br></code></pre></td></tr></table></figure>
主要就是加载<code>HDR</code>文件，将<code>HDR</code>的内容载入一张<code>2D纹理</code>中(hdrObj)，然后根据纹理生成<code>environmentCubemap</code>(envCubemap),然后根据<code>Cubemap</code>预计算漫反射项(irradianceMap)的光照部分，镜面反射项的光照部分(prefilterMap)以及对BRDF本身的预计算(pbrBrdfLutObj)，然后在shader中直接查表完成环境光<code>Cook-Torrance</code>反射模型的积分。<br />
注意<code>gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE,new Uint8Array(data));</code>这个函数读取数据的类型不能像<code>Opengl</code>那样填<code>gl.FLOAT</code>,不然会报错,可以用这个函数来检测<code>getErrorMessage()</code>。反正我这是不行，你们可以自行测试。</p>
<h2 id="从等距柱状投影到立方体贴图">从等距柱状投影到立方体贴图</h2>
<p><code>HDR</code>文件载入<code>2D纹理</code>后就是<code>等距柱状投影图(Equirectangular Map)</code>,我们要做的就是将这张<code>2D纹理</code>转换成<code>Cubemap</code>。<br />
这里用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/UV_mapping">UV
mapping</a>中的技术,从球面上找到UV坐标。从<code>笛卡尔坐标系</code>转<code>球坐标系</code>然后映射到<code>[0,1]</code>区间去采样等距柱状图，在右手坐标系进行，<code>phi</code>逆时针旋转。公式如下：<br />
<span class="math display">\[
u=0.5+\frac{\arctan(p_{z},p_{x})}{2\pi}  \\
v=0.5+\frac{\arcsin(p_{y})}{\pi}  \tag{1}
\]</span> 解释如下：<br />
<img src="/img/00018/uv-mapping.png" srcset="/img/loading.gif" lazyload alt="2" /> 代码如下:<br />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> vec2 invAtan = <span class="hljs-built_in">vec2</span>(<span class="hljs-number">0.1591</span>, <span class="hljs-number">0.3183</span>);<br><span class="hljs-comment">// hdr文件存储每个浮点值的方式</span><br><span class="hljs-comment">// 每个通道存储 8 位，再以 alpha 通道存放指数</span><br><span class="hljs-comment">// 因此利用这种方式解码</span><br><span class="hljs-function">vec3 <span class="hljs-title">hdrDecode</span><span class="hljs-params">(vec4 encoded)</span></span>&#123;<br>    <span class="hljs-type">float</span> exponent = encoded.a * <span class="hljs-number">256.0</span> - <span class="hljs-number">128.0</span>;<br>    vec3 mantissa = encoded.rgb;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">exp2</span>(exponent) * mantissa;<br>&#125;<br><span class="hljs-function">vec2 <span class="hljs-title">SampleSphericalMap</span><span class="hljs-params">(vec3 v)</span></span><br><span class="hljs-function"></span>&#123;<br>    vec2 uv = <span class="hljs-built_in">vec2</span>(<span class="hljs-built_in">atan</span>(v.z, v.x), <span class="hljs-built_in">asin</span>(v.y));<br>    uv *= invAtan;<br>    uv += <span class="hljs-number">0.5</span>;<br>    <span class="hljs-keyword">return</span> uv;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;		<br>    vec2 uv = <span class="hljs-built_in">SampleSphericalMap</span>(<span class="hljs-built_in">normalize</span>(WorldPos));<br>    vec4 enCodeColor = <span class="hljs-built_in">texture</span>(uEquirectangularMap,uv).rgba;<br>    vec3 deCodeColor = <span class="hljs-built_in">hdrDecode</span>(enCodeColor);<br>    fragColor = <span class="hljs-built_in">vec4</span>(<span class="hljs-built_in">vec3</span>(deCodeColor), <span class="hljs-number">1.0</span>);<br>&#125;<br>```  <br><br>## 环境光Cook-Torrance反射方程的预计算  <br><br>快速浏览一下反射方程：  <br>$$<br>L_&#123;o&#125;(p,w_&#123;o&#125;)=\int_&#123;\Omega&#125;^&#123;&#125;(kd\frac&#123;c&#125;&#123;\pi&#125;+ks\frac&#123;DFG&#125;&#123;<span class="hljs-number">4</span>(w_&#123;o&#125;\cdot n)(w_&#123;i&#125;\cdot n)&#125;)L_&#123;i&#125;(p,w_&#123;i&#125;)n\cdot w_&#123;i&#125;dw_&#123;i&#125; \tag&#123;<span class="hljs-number">2</span>&#125;<br>$$<br>该公式的解释可以参考[Opengl Pbr](https:<span class="hljs-comment">//learnopengl-cn.github.io/07%20PBR/01%20Theory/)。值得一提的是公式中`ks`和`Fresnel`项指代的同一件事情，所以`ks`可以省略，其中`o`代表出射方向也就是我们看到的方向，`i`是入射方向即光照方向。</span><br><br>### 漫反射光照的预计算  <br><br>仔细观察会发现`BRDF`的漫反射`kd`和镜面`ks`项是相互独立的，我们可以将积分分成两部分： <br>$$<br>L_&#123;o&#125;(p,w_&#123;o&#125;)=\int_&#123;\Omega&#125;(kd\frac&#123;c&#125;&#123;\pi&#125;)L_&#123;i&#125;(p,w_&#123;i&#125;)n\cdot w_&#123;i&#125;dw_&#123;i&#125;+\int_&#123;\Omega&#125;(\frac&#123;DFG&#125;&#123;<span class="hljs-number">4</span>(w_&#123;o&#125;\cdot n)(w_&#123;i&#125;\cdot n)&#125;)L_&#123;i&#125;(p,w_&#123;i&#125;)n\cdot w_&#123;i&#125;dw_&#123;i&#125; \tag&#123;<span class="hljs-number">3</span>&#125;<br>$$<br>前这部分才是本节的重点，让我们在化简一下(颜色`c`,漫反射率`kd`,和`π`在整个积分是常数)：  <br>$$<br>L_&#123;o&#125;(p,w_&#123;o&#125;)=(kd\frac&#123;c&#125;&#123;\pi&#125;)\int_&#123;\Omega&#125;L_&#123;i&#125;(p,w_&#123;i&#125;)n\cdot w_&#123;i&#125;dw_&#123;i&#125; \tag&#123;<span class="hljs-number">4</span>&#125;<br>$$<br>经过简化有可以发现，积分目前只跟`wi`有关(假设物体上的点p位于立方体中间，`N`为`p`与立方体上某点的连线)，由于是漫反射在半球上的积分，其入射方向是均匀的来自半球的四面八方。  <br>积分参考`Opengl`的方法：对于立方体贴图的每个纹素，在`纹素所代表的方向`的半球Ω内生成固定数量的采样向量，并对采样结果取平均值。数量固定的采样向量将均匀地分布在半球内部。注意，积分是连续函数，在采样向量数量固定的情况下离散地采样只是一种近似计算方法，我们采样的向量越多，就越接近正确的结果。   <br>纹素所代表的方向的半球`Ω`内生成固定数量的采样向量，图解如下：  <br>![<span class="hljs-number">3</span>](/img/<span class="hljs-number">00018</span>/irradiance.png)  <br>反射方程的积分`∫`是围绕立体角`dw`旋转，而这个立体角相当难以处理。为了避免对难处理的立体角求积分，我们使用球坐标`θ`和`ϕ`来代替立体角。公式如下：  <br>$$<br>L_&#123;o&#125;(p,\phi_&#123;o&#125;,\theta_&#123;o&#125;)=kd\frac&#123;c&#125;&#123;\pi&#125;\int_&#123;\phi=<span class="hljs-number">0</span>&#125;^&#123;<span class="hljs-number">2</span>\pi&#125;\int_&#123;\theta=<span class="hljs-number">0</span>&#125;^&#123;\frac&#123;<span class="hljs-number">1</span>&#125;&#123;<span class="hljs-number">2</span>&#125;\pi&#125;L_&#123;i&#125;(p,\phi_&#123;i&#125;,\theta_&#123;i&#125;)\<span class="hljs-built_in">cos</span>(\theta_&#123;i&#125;)\<span class="hljs-built_in">sin</span>(\theta_&#123;i&#125;)d\theta d\phi\\<br>=kd\frac&#123;c&#125;&#123;\pi&#125;\frac&#123;<span class="hljs-number">2</span>\pi&#125;&#123;n1&#125;\frac&#123;\pi&#125;&#123;<span class="hljs-number">2</span>\cdot n2&#125;\sum_&#123;m=<span class="hljs-number">0</span>&#125;^&#123;n1&#125;\sum_&#123;n=<span class="hljs-number">0</span>&#125;^&#123;n2&#125;L_&#123;i&#125;(p,\phi_&#123;m&#125;,\theta_&#123;n&#125;)\<span class="hljs-built_in">cos</span>(\theta_&#123;n&#125;)\<span class="hljs-built_in">sin</span>(\theta_&#123;n&#125;)\\<br>=kd\frac&#123;c\pi&#125;&#123;n1\cdot n2&#125;\sum_&#123;m=<span class="hljs-number">0</span>&#125;^&#123;n1&#125;\sum_&#123;n=<span class="hljs-number">0</span>&#125;^&#123;n2&#125;L_&#123;i&#125;(p,\phi_&#123;m&#125;,\theta_&#123;n&#125;)\<span class="hljs-built_in">cos</span>(\theta_&#123;n&#125;)\<span class="hljs-built_in">sin</span>(\theta_&#123;n&#125;) \tag&#123;<span class="hljs-number">5</span>&#125;<br>$$<br>该结果由蒙特卡洛积分所得，`φ`的概率密度为`<span class="hljs-number">1</span>/<span class="hljs-number">2</span>PI`，`θ`的概率密度为`<span class="hljs-number">2</span>/PI`，其中添加的`<span class="hljs-built_in">sin</span>(θ)`是为了权衡较高半球区域的较小采样区域的贡献度如图：  <br>![<span class="hljs-number">4</span>](/img/<span class="hljs-number">00018</span>/image.png)  <br>给定每个片段的积分球坐标，对半球进行离散采样，过程代码如下：  <br>``` cpp<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> PI = <span class="hljs-number">3.14159265359</span>;<br><span class="hljs-type">void</span> <span class="hljs-built_in">main</span>()<br>&#123;		<br>    vec3 N = <span class="hljs-built_in">normalize</span>(WorldPos);<br>    vec3 irradiance = <span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0</span>);   <br>    <span class="hljs-comment">// tangent space calculation from origin point</span><br>    vec3 up    = <span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>);<br>    vec3 right = <span class="hljs-built_in">normalize</span>(<span class="hljs-built_in">cross</span>(up, N));<br>    up         = <span class="hljs-built_in">normalize</span>(<span class="hljs-built_in">cross</span>(N, right));<br>    <span class="hljs-type">float</span> sampleDelta = <span class="hljs-number">0.025</span>;<br>    <span class="hljs-type">float</span> nrSamples = <span class="hljs-number">0.0f</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">float</span> phi = <span class="hljs-number">0.0</span>; phi &lt; <span class="hljs-number">2.0</span> * PI; phi += sampleDelta)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">float</span> theta = <span class="hljs-number">0.0</span>; theta &lt; <span class="hljs-number">0.5</span> * PI; theta += sampleDelta)<br>        &#123;<br>            <span class="hljs-comment">// spherical to cartesian (in tangent space)</span><br>            vec3 tangentSample = <span class="hljs-built_in">vec3</span>(<span class="hljs-built_in">sin</span>(theta) * <span class="hljs-built_in">cos</span>(phi),  <span class="hljs-built_in">sin</span>(theta) * <span class="hljs-built_in">sin</span>(phi), <span class="hljs-built_in">cos</span>(theta));<br>            <span class="hljs-comment">// tangent space to world</span><br>            vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * N; <br>            irradiance += <span class="hljs-built_in">texture</span>(uEnvironmentMap, sampleVec).rgb * <span class="hljs-built_in">cos</span>(theta) * <span class="hljs-built_in">sin</span>(theta);<br>            nrSamples++;<br>        &#125;<br>    &#125;<br>    irradiance = PI * irradiance * (<span class="hljs-number">1.0</span> / <span class="hljs-built_in">float</span>(nrSamples));<br>    FragColor = <span class="hljs-built_in">vec4</span>(irradiance, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
球坐标系转笛卡尔坐标系，得到的是切线空间的向量，需要用<code>TBN</code>矩阵将该向量转至世界空间。最后得到漫反射辐照度贴图如下：<br />
<img src="/img/00018/image-1.png" srcset="/img/loading.gif" lazyload alt="5" /><br />
糊的很，根本没有细节可言。</p>
<h3 id="splitsum和ggx重要性采样">SplitSum和GGX重要性采样</h3>
<p>为了理解，我们回顾一下反射方程，但这次只关注镜面反射部分（在上一节中已经剥离了漫反射部分）：<br />
<span class="math display">\[
L_{o}(p,w_{o})=\int_{\Omega}(\frac{DFG}{4(w_{o}\cdot n)(w_{i}\cdot
n)})L_{i}(p,w_{i})n\cdot w_{i}dw_{i} \tag{6}
\]</span>
对这部分积分进行预计算有个棘手的地方，它不仅依赖<code>wi</code>还依赖<code>wo</code>，我们不可能吧<code>wi</code>和<code>wo</code>的每种组合都进行预计算(wi(θ，φ),wo(θ，φ),F0,roughness,一共六个维度也无法预计算)，所以<code>Epic Games</code>提出了一个新的解决方法<a
target="_blank" rel="noopener" href="http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf">split
sum</a>：<br />
<span class="math display">\[
\int_{\Omega}(\frac{DFG}{4(w_{o}\cdot n)(w_{i}\cdot
n)})L_{i}(p,w_{i})n\cdot w_{i}dw_{i} \\
\approx\frac{1}{N}\sum_{k=1}^{N}\frac{L_{i}(p,w_{ik})f_{r}(p,w_{ik},w_{ok})\cos(\theta_{ik})}{p(w_{ik},w_{ok})}
\\
\approx(\frac{1}{N}\sum_{k=1}^{N}L_{i}(p,w_{ik}))(\frac{1}{N}\sum_{k=1}^{N}\frac{f_{r}(p,w_{ik},w_{ok})\cos(\theta_{ik})}{p(w_{ik},w_{ok})})
\tag{7}
\]</span>
该式子左边是一个求和，右边是蒙特卡洛积分，左右分别为两维度，可以直接查表。左边wi是两维度好理解，右边两维度我在后面章节解释。我们分别对这两部分进行预计算就可以解决上面棘手的部分。<br />
但是它们都是建立在<code>GGX重要性采样</code>的基础上，先介绍一下重要性采样：<br />
我们使用球面坐标生成均匀分布在半球<code>Ω</code>上的采样向量，以对环境贴图进行卷积。虽然这个方法非常适用于辐照度，但对于镜面反射效果较差。镜面反射依赖于表面的粗糙度，反射光线可能比较松散，也可能比较紧密，但是一定会围绕着反射向量<code>r</code>，除非表面极度粗糙:<br />
<img src="/img/00018/image-2.png" srcset="/img/loading.gif" lazyload alt="6" /><br />
所有可能出射的反射光构成的形状称为镜面波瓣。随着粗糙度的增加，镜面波瓣的大小增加；随着入射光方向不同，形状会发生变化。因此，镜面波瓣的形状高度依赖于材质。
在微表面模型里给定入射光方向，则镜面波瓣指向微平面的半向量的反射方向。考虑到大多数光线最终会反射到一个基于半向量的镜面波瓣内，采样时以类似的方式选取采样向量是有意义的，因为大部分其余的向量都被浪费掉了。根据表面粗糙度生成法线<code>N</code>，然后以镜面反射的形式计算出采样方向的过程称为<code>重要性采样</code>。<br />
要理解重要性采样需要先理解<a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Inverse_transform_sampling">逆变换采样</a>，逆变换采样是用range为[0,1]之间的均匀随机数来生成服从pdf的样本，其过程如下：<br />
1.从均匀分布<code>U[0,1]</code>中产生一个随机数<code>ui</code><br />
2.计算<span
class="math inline">\(x_{i}=F_{X}^{-1}(u_{i})\)</span>作为采样结果<br />
其中<span
class="math inline">\(F_{X}(x)\)</span>为<code>CDF</code>(累积分布函数)所有的<code>CDF</code>中，在<code>x</code>趋近最小值时，<code>CDF</code>趋近于<code>0</code>，当<code>x</code>趋近最大值时，<code>CDF</code>趋近与<code>1</code>。<br />
<span
class="math inline">\(f_{X}(x)\)</span>为随机变量<code>X</code>的<code>pdf</code>(概率密度函数)。这是它们的关系<span
class="math inline">\(F_{X}(x)=\int_{-\infty}^{x}f_{X}(u)du\)</span><br />
<span
class="math inline">\(F_{X}^{-1}(x)\)</span>为<code>cdf</code>的反函数，只有单调非减的函数才有反函数。
<code>GGX重要性采样</code>用的概率密度函数为<a
target="_blank" rel="noopener" href="https://www.reedbeta.com/blog/hows-the-ndf-really-defined/">D(h)dot(n,h)</a>，其在球坐标系下的概率密度函数为：
<span class="math display">\[
p_{h}(\theta,\phi)=\frac{\alpha^{2}\cos(\theta)\sin(\theta)}{\pi((\alpha^{2}-1)\cos^{2}(\theta)+1)^{2}}
\tag{8}
\]</span> 分别求θ和φ的边缘概率密度函数(pdf)： <span
class="math display">\[
p_{h}(\theta)=\int_{0}^{2\pi}p_{h}(\theta,\phi)d\phi=\frac{2\alpha^{2}\cos(\theta)\sin(\theta)}{((\alpha^{2}-1)\cos^{2}(\theta)+1)^{2}}
\tag{9}
\]</span> <span class="math display">\[
p_{h}(\phi)=\int_{0}^{\frac{\pi}{2}}\frac{\alpha^{2}\cos(\theta)\sin(\theta)}{\pi((\alpha^2-1)\cos^{2}(\theta)+1)^{2}}d\theta
\\
=-\frac{\alpha^{2}}{2\pi}\int_{0}^{\frac{\pi}{2}}\frac{-2\cos(\theta)\sin(\theta)}{((\alpha^2-1)\cos^{2}(\theta)+1)^{2}}d\theta
\\
=\frac{\alpha^{2}}{2\pi}\int_{\frac{\pi}{2}}^{0}\frac{1}{(\alpha^2-1)\cos^{2}(\theta)+1)^{2}}d(\cos^{2}\theta)
\\
=\frac{\alpha^{2}}{2\pi}\int_{0}^{1}\frac{1}{((\alpha^{2}-1)t+1)^{2}}dt
\\
\]</span> 令<code>x=(α^2-1)t+1</code> <span class="math display">\[
=\frac{\alpha^{2}}{2\pi(\alpha^2-1)}\int_{1}^{\alpha^2}\frac{1}{x^{2}}dx
\\
=\frac{\alpha^{2}}{2\pi(1-\alpha^2)}\frac{1}{x}\vert_{1}^{\alpha^2} \\
=\frac{1}{2\pi} \tag{10}
\]</span> 再分别求<code>θ</code>和<code>φ</code>的累计分布函数(cdf):
<span class="math display">\[
P_{h}(\phi)=\int_{0}^{\phi}\frac{1}{2\pi}dt=\frac{\phi}{2\pi} \tag{11}
\]</span> <span class="math display">\[
P_{h}(\theta)=\int_{0}^{\theta}\frac{2\alpha^{2}\cos(t)\sin(t)}{((\alpha^{2}-1)\cos^{2}(t)+1)^{2}}dt
\\
=\alpha^{2}\int_{\theta}^{0}\frac{1}{(\alpha^2-1)\cos^{2}(t)+1)^{2}}d(\cos^{2}(t))
\\
=\frac{\alpha^2}{\alpha^2-1}\int_{\alpha^2}^{(\alpha^2-1)\cos^{2}(\theta)+1}-\frac{1}{x^{2}}dx
\\
=\frac{\alpha^2}{\alpha^2-1}\frac{1}{x}\vert_{\alpha^{2}}^{(\alpha^2-1)\cos^{2}(\theta)+1}
\\
=\frac{\alpha^{2}}{\alpha^{2}-1}\cdot
(\frac{1}{(\alpha^2-1)\cos^{2}(\theta)+1}-\frac{1}{\alpha^{2}}) \tag{12}
\]</span>
反函数就是函数值域<code>Y</code>和定义域<code>X</code>的映射关系翻转一下。
均匀的从<code>U[0,1]</code>中取出两个随机数<span
class="math inline">\(X_{1}\)</span>和<span
class="math inline">\(X_{2}\)</span>,则我们要的采样<code>θ</code>和<code>φ</code>为：<br />
<span class="math display">\[
\phi=2\pi X_{1} \tag{13}
\]</span> <span class="math display">\[
\theta=\arccos\sqrt{\frac{1-X_{2}}{X_{2}(\alpha^{2}-1)+1}} \tag{14}
\]</span> 对应代码实现如下：<br />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vec3 <span class="hljs-title">ImportanceSampleGGX</span><span class="hljs-params">(vec2 Xi, vec3 N, <span class="hljs-type">float</span> roughness)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">float</span> a = roughness*roughness;	<br>	<span class="hljs-type">float</span> phi = <span class="hljs-number">2.0</span> * PI * Xi.x;<br>	<span class="hljs-type">float</span> cosTheta = <span class="hljs-built_in">sqrt</span>((<span class="hljs-number">1.0</span> - Xi.y) / (<span class="hljs-number">1.0</span> + (a*a - <span class="hljs-number">1.0</span>) * Xi.y));<br>	<span class="hljs-type">float</span> sinTheta = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span> - cosTheta*cosTheta);<br>	<span class="hljs-comment">// from spherical coordinates to cartesian coordinates - halfway vector</span><br>	vec3 H;<br>	H.x = <span class="hljs-built_in">cos</span>(phi) * sinTheta;<br>	H.y = <span class="hljs-built_in">sin</span>(phi) * sinTheta;<br>	H.z = cosTheta;<br>	<span class="hljs-comment">// from tangent-space H vector to world-space sample vector</span><br>	vec3 up          = <span class="hljs-built_in">abs</span>(N.z) &lt; <span class="hljs-number">0.999</span> ? <span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>) : <span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);<br>	vec3 tangent   = <span class="hljs-built_in">normalize</span>(<span class="hljs-built_in">cross</span>(up, N));<br>	vec3 bitangent = <span class="hljs-built_in">cross</span>(N, tangent);<br>	vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">normalize</span>(sampleVec);<br>&#125;<br></code></pre></td></tr></table></figure> ### 镜面反射光照的预计算</p>
<p>上节内容提到用<code>Split Sum</code>来分割镜面反射的光照和BRDF部分以避免去求wi和wo所有组合下的积分。本节重要点放在镜面反射光照的预计算，我们再看下这部分的公式：<br />
<span class="math display">\[
\frac{1}{N}\sum_{k=1}^{N}L_{i}(p,w_{ik}) \tag{15}
\]</span>
这里可以看做是一次求和取平均。还有一个问题就是，这里的wi不仅需要<code>GGX重要性采样</code>得到的符合<code>D(h)dot(n,h)概率密度函数</code>的微表面法线方向，还需要视角方向<code>V</code>,但是我们并不能提前知道<code>V</code>是什么方向，这里<code>Epic Games</code>再一次假设，即<code>v=r=n</code>。这种各向同性假设是第二个近似来源，不幸的是，这意味在掠入射角时不会得到长反射效果：<br />
<img src="/img/00018/image-3.png" srcset="/img/loading.gif" lazyload alt="7" /><br />
与分裂和近似相比，这实际上是我们<code>IBL</code>解的较大误差源。代码中通过<code>cosθlk</code>加权可以获得更好的结果：<br />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;		<br>    vec3 N = <span class="hljs-built_in">normalize</span>(WorldPos);<br>    <span class="hljs-comment">// make the simplifying assumption that V equals R equals the normal </span><br>    vec3 R = N;<br>    vec3 V = R;<br>    <span class="hljs-type">const</span> uint SAMPLE_COUNT = <span class="hljs-number">1024u</span>;<br>    vec3 prefilteredColor = <span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0</span>);<br>    <span class="hljs-type">float</span> totalWeight = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">for</span>(uint i = <span class="hljs-number">0u</span>; i &lt; SAMPLE_COUNT; ++i)<br>    &#123;<br>        <span class="hljs-comment">// generates a sample vector that&#x27;s biased towards the preferred alignment direction (importance sampling).</span><br>        vec2 Xi = <span class="hljs-built_in">Hammersley</span>(i, SAMPLE_COUNT);<br>        vec3 H = <span class="hljs-built_in">ImportanceSampleGGX</span>(Xi, N, uRoughness);<br>        vec3 L  = <span class="hljs-built_in">normalize</span>(<span class="hljs-number">2.0</span> * <span class="hljs-built_in">dot</span>(V, H) * H - V);<br>        <span class="hljs-comment">//COS weight can increase image quality</span><br>        <span class="hljs-type">float</span> NdotL = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(N, L), <span class="hljs-number">0.0</span>);<br>        <span class="hljs-keyword">if</span>(NdotL &gt; <span class="hljs-number">0.0</span>)<br>        &#123;<br>            <span class="hljs-comment">// sample from the environment&#x27;s mip level based on roughness/pdf</span><br>            <span class="hljs-type">float</span> D   = <span class="hljs-built_in">DistributionGGX</span>(N, H, uRoughness);<br>            <span class="hljs-type">float</span> NdotH = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(N, H), <span class="hljs-number">0.0</span>);<br>            <span class="hljs-type">float</span> HdotV = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(H, V), <span class="hljs-number">0.0</span>);<br>            <span class="hljs-type">float</span> pdf = D * NdotH / (<span class="hljs-number">4.0</span> * HdotV) + <span class="hljs-number">0.0001</span>; <br>            <span class="hljs-type">float</span> resolution = <span class="hljs-number">512.0</span>; <span class="hljs-comment">// resolution of source cubemap (per face)</span><br>            <span class="hljs-type">float</span> saTexel  = <span class="hljs-number">4.0</span> * PI / (<span class="hljs-number">6.0</span> * resolution * resolution);<br>            <span class="hljs-type">float</span> saSample = <span class="hljs-number">1.0</span> / (<span class="hljs-built_in">float</span>(SAMPLE_COUNT) * pdf + <span class="hljs-number">0.0001</span>);<br>            <span class="hljs-comment">//sample solid angle ratio to pixel solid angle</span><br>            <span class="hljs-type">float</span> mipLevel = uRoughness == <span class="hljs-number">0.0</span> ? <span class="hljs-number">0.0</span> : <span class="hljs-number">0.5</span> * <span class="hljs-built_in">log2</span>(saSample / saTexel);        <br>            prefilteredColor += <span class="hljs-built_in">textureLod</span>(uEnvironmentMap, L, mipLevel).rgb * NdotL;<br>            totalWeight      += NdotL;<br>        &#125;<br>    &#125;<br>    prefilteredColor = prefilteredColor / totalWeight;<br>    FragColor = <span class="hljs-built_in">vec4</span>(prefilteredColor, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure> 代码中的<code>pdf</code>推导过程如下，图片来源于<a
target="_blank" rel="noopener" href="https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf">2007年论文</a>：<br />
<span class="math display">\[
p_{o}(\theta,\phi)=p_{h}(\theta,\phi)\cdot\lVert\frac{\partial
w_{h}}{\partial w_{o}}\rVert \tag{16}
\]</span> <img src="/img/00018/pdf-derivation.png" srcset="/img/loading.gif" lazyload alt="8" /><br />
<span class="math display">\[
\lVert\frac{\partial w_{h}}{\partial w_{o}}\rVert=\frac{\vert o\cdot
h\vert}{\lVert\vec{h}\rVert^{2}} \\
=\frac{\vert o\cdot h\vert}{\lVert 2(o\cdot h)h\rVert^{2}}
=\frac{\vert o\cdot h\vert}{4(o\cdot h)^{2}\lVert
h\rVert^{2}}=\frac{1}{4\vert o\cdot h\vert} \tag{17}
\]</span>
其中<code>i</code>，<code>o</code>和<code>没箭头的h</code>，都是归一化后的向量。这只是反射模型的<code>pdf</code>，以同样的计算方法论文作者还给出了折射的<code>pdf</code>，感兴趣可以去看下。需要注意的是这里推导涉及的i，o和代码中的v，L没关系，只是单纯用来推导的,一般来说我们视<code>i</code>为光照方向，<code>o</code>为视角方向。</p>
<p>代码中<a
target="_blank" rel="noopener" href="https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-20-gpu-based-importance-sampling">采样</a>是对<code>uEnvironmentMap</code>的<code>mipmap</code>来采样，而不是直接去获取清晰度最高的<code>uEnvironmentMap</code>,这样做的原因是<code>pdf</code>越低，样本所对应的环境贴图中平均像素数就越多，使用的<code>mipmap</code>层级应该越大，这可以做到少采样数量达到多采样数量的效果，并减少伪影。我们用与样本相关的实体角来定义这种关系，计算方法是<code>pdf</code>与样本总数<code>N</code>之间乘积的倒数：<br />
<span class="math display">\[
\Omega_{s}=\frac{1}{N\cdot p_{L}(\theta,\phi)} \tag{18}
\]</span>
该式子表示采样方向所对应的环境贴图中像素数的多少(采样立体角的大小)。我们还需要知道立方体贴图中一个像素对应的立体角是多大,我们这里是求单位球表面积比上立方体分辨率：<br />
<span class="math display">\[
\Omega_{p}=\frac{d(u)}{w\cdot h} \tag{19}
\]</span>
原文这个<code>d(u)</code>是计算从半球的单位面积到纹理上的单位面积的变化速率（换句话说，计算映射的畸变率），原文<code>d(u)</code>是应用在另一种采样方式，不是在立方体贴图上面进行的采样，和我们这里不一样，我们这里直接算立方体贴图上一个像素对应的立体角大小就行。那<code>d(u)</code>直接就是单位球的表面积<code>4π</code>。<br />
最后用下面这个公式计算<code>mipmap</code>层数：<br />
<span class="math display">\[
level=max[\frac{1}{2}\log_{2}\frac{\Omega_{s}}{\Omega_{p}},0] \tag{20}
\]</span>
最后计算完的<code>prefilteredColor</code>根据粗糙度<code>[0,1]</code>，分别存入<code>prefilterMap</code>的<code>5</code>层<code>mipmap</code>中，在最后<code>shading</code>过程中，根据粗糙度来获取<code>prefilteredColor</code>层数。代码如下：<br />
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js">gl.<span class="hljs-title function_">bindFramebuffer</span>(gl.<span class="hljs-property">FRAMEBUFFER</span>, captureFBO);<br><span class="hljs-keyword">const</span> maxMipLevels = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> mip = <span class="hljs-number">0</span>; mip &lt; maxMipLevels; ++mip)<br>&#123;<br>    <span class="hljs-comment">// reisze framebuffer according to mip-level size.</span><br>    <span class="hljs-keyword">let</span> mipWidth  = <span class="hljs-number">128</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">0.5</span>, mip);<br>    <span class="hljs-keyword">let</span> mipHeight = <span class="hljs-number">128</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">0.5</span>, mip);<br>    gl.<span class="hljs-title function_">bindRenderbuffer</span>(gl.<span class="hljs-property">RENDERBUFFER</span>, captureRBO);<br>    gl.<span class="hljs-title function_">renderbufferStorage</span>(gl.<span class="hljs-property">RENDERBUFFER</span>, gl.<span class="hljs-property">DEPTH_COMPONENT24</span>, mipWidth, mipHeight);<br>    gl.<span class="hljs-title function_">viewport</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mipWidth, mipHeight);<br>    <span class="hljs-keyword">let</span> roughness = mip / (maxMipLevels - <span class="hljs-number">1</span>);<br>    gl.<span class="hljs-title function_">uniform1f</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">prefilterShader</span>.<span class="hljs-property">program</span>.<span class="hljs-property">uniforms</span>[<span class="hljs-string">&quot;uRoughness&quot;</span>],roughness);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; ++i)<br>    &#123;<br>        gl.<span class="hljs-title function_">uniformMatrix4fv</span>(<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">prefilterShader</span>.<span class="hljs-property">program</span>.<span class="hljs-property">uniforms</span>[<span class="hljs-string">&quot;uViewMatrix&quot;</span>],<br>            <span class="hljs-literal">false</span>,<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">captureViews</span>[i]);<br>        gl.<span class="hljs-title function_">framebufferTexture2D</span>(gl.<span class="hljs-property">FRAMEBUFFER</span>, gl.<span class="hljs-property">COLOR_ATTACHMENT0</span>, gl.<span class="hljs-property">TEXTURE_CUBE_MAP_POSITIVE_X</span> + i, <span class="hljs-variable language_">this</span>.<span class="hljs-property">prefilterMap</span>, mip);<br>        gl.<span class="hljs-title function_">clear</span>(gl.<span class="hljs-property">COLOR_BUFFER_BIT</span> | gl.<span class="hljs-property">DEPTH_BUFFER_BIT</span>);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">renderCube</span>();<br>    &#125;<br>&#125;<br>gl.<span class="hljs-title function_">bindFramebuffer</span>(gl.<span class="hljs-property">FRAMEBUFFER</span>, <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure> 一切顺利的话，会得到下面的图片：<br />
<img src="/img/00018/image-6.png" srcset="/img/loading.gif" lazyload alt="9" /></p>
<h3 id="预计算brdf">预计算BRDF</h3>
<p>有了上面的基础，这部分内容就比较简单了，快速看一遍公式：<br />
<span class="math display">\[
\frac{1}{N}\sum_{k=1}^{N}\frac{f_{r}(p,w_{ik},w_{ok})\cos(\theta_{ik})}{p(w_{ik},w_{ok})}
\tag{21}
\]</span>
上文说到镜面反射方程有六个维度<code>wi(θ，φ)</code>,<code>wo(θ，φ)</code>,<code>F0</code>,<code>roughness</code>,由于光照部分我们已经处理过了，而此时<code>BRDF</code>的<code>wi</code>和<code>wo</code>都是和<code>n</code>绑定在一起的，那这里<code>BRDF</code>就只剩下<code>4</code>个维度<code>wi·n</code>,<code>wo·n</code>,<code>F0</code>,<code>roughness</code>,由于重要性采样可以由<code>wo</code>生成服从<code>D(h)dot(n,h)</code>概率密度函数的<code>wi</code>，则维度可以再降到3个<code>wo·n</code>,<code>F0</code>,<code>roughness</code>，再将<code>Fresnel</code>项拆分成两部分，<code>F0</code>也可以移出积分范围，维度再降到2个<code>wo·n</code>,<code>roughness</code>，这样就可以愉快的打表了😆！下面是拆分过程，我这里把<code>k</code>角标去掉了方便观看：<br />
<span class="math display">\[
\frac{1}{N}\sum_{k=1}^{N}\frac{f_{r}(p,w_{i},w_{o})\cos(\theta_{i})}{p(w_{i},w_{o})}
\\
=\frac{1}{N}\sum_{k=1}^{N}\frac{f_{r}(p,w_{i},w_{o})F(w_{o},h)\cos(\theta_{i})}{F(w_{o},h)p(w_{i},w_{o})}
\\
=\frac{1}{N}\sum_{k=1}^{N}\frac{f_{r}(p,w_{i},w_{o})}{F(w_{o},h)p(w_{i},w_{o})}(F0+(1-F0)(1-w_{o}\cdot
h)^{5})\cos(\theta_{i})
\]</span> 这里用<code>α</code>代替<code>(1-wo·h)^5</code>:<br />
<span class="math display">\[
=\frac{1}{N}\sum_{k=1}^{N}\frac{f_{r}(p,w_{i},w_{o})}{F(w_{o},h)p(w_{i},w_{o})}(F0+(1-F0)\alpha)\cos(\theta_{i})
\\
=\frac{1}{N}\sum_{k=1}^{N}\frac{f_{r}(p,w_{i},w_{o})}{F(w_{o},h)p(w_{i},w_{o})}(F0*(1-\alpha)+\alpha)\cos(\theta_{i})
\\
=\frac{1}{N}\sum_{k=1}^{N}\frac{f_{r}(p,w_{i},w_{o})}{F(w_{o},h)p(w_{i},w_{o})}F0*(1-\alpha)\cos(\theta_{i})+\frac{1}{N}\sum_{k=1}^{N}\frac{f_{r}(p,w_{i},w_{o})}{F(w_{o},h)p(w_{i},w_{o})}\alpha\cos(\theta_{i})
\tag{22}
\]</span> 可以看到这两部分都包含一个共同项：<br />
<span class="math display">\[
\frac{f_{r}(p,w_{i},w_{o})}{F(w_{o},h)p(w_{i},w_{o})}\cos(\theta_{i})
\]</span>
我们将其化简一下,其中<code>pdf=D * NdotH / (4.0 * VdotH)</code>：<br />
<span class="math display">\[
=\frac{DG\cos(\theta_{i})}{4\cos(\theta_{o})\cos(\theta_{i})}\frac{4(o\cdot
h)}{D(n\cdot h)} \\
=\frac{G(o\cdot h)}{(o\cdot n)(n\cdot h)} \tag{23}
\]</span> 带入(22)式中得：<br />
<span class="math display">\[
F0*\frac{1}{N}\sum_{k=1}^{N}\frac{G(o\cdot h)}{(o\cdot n)(n\cdot
h)}(1-(1-(w_{o}\cdot h)^{5}))+\frac{1}{N}\sum_{k=1}^{N}\frac{G(o\cdot
h)}{(o\cdot n)(n\cdot h)}(1-(w_{o}\cdot h)^{5}) \tag{24}
\]</span> 代码实现如下：<br />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vec2 <span class="hljs-title">IntegrateBRDF</span><span class="hljs-params">(<span class="hljs-type">float</span> NdotV, <span class="hljs-type">float</span> roughness)</span></span><br><span class="hljs-function"></span>&#123;<br>    vec3 V;<br>    V.x = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span> - NdotV*NdotV);<br>    V.y = <span class="hljs-number">0.0</span>;<br>    V.z = NdotV;<br>    <span class="hljs-type">float</span> A = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-type">float</span> B = <span class="hljs-number">0.0</span>; <br>    vec3 N = <span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    <span class="hljs-type">const</span> uint SAMPLE_COUNT = <span class="hljs-number">1024u</span>;<br>    <span class="hljs-keyword">for</span>(uint i = <span class="hljs-number">0u</span>; i &lt; SAMPLE_COUNT; ++i)<br>    &#123;<br>        <span class="hljs-comment">// generates a sample vector that&#x27;s biased towards the</span><br>        <span class="hljs-comment">// preferred alignment direction (importance sampling).</span><br>        vec2 Xi = <span class="hljs-built_in">Hammersley</span>(i, SAMPLE_COUNT);<br>        vec3 H = <span class="hljs-built_in">ImportanceSampleGGX</span>(Xi, N, roughness);<br>        vec3 L = <span class="hljs-built_in">normalize</span>(<span class="hljs-number">2.0</span> * <span class="hljs-built_in">dot</span>(V, H) * H - V);<br>        <span class="hljs-type">float</span> NdotL = <span class="hljs-built_in">max</span>(L.z, <span class="hljs-number">0.0</span>);<br>        <span class="hljs-type">float</span> NdotH = <span class="hljs-built_in">max</span>(H.z, <span class="hljs-number">0.0</span>);<br>        <span class="hljs-type">float</span> VdotH = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(V, H), <span class="hljs-number">0.0</span>);<br>        <span class="hljs-keyword">if</span>(NdotL &gt; <span class="hljs-number">0.0</span>)<br>        &#123;<br>            <span class="hljs-type">float</span> G = <span class="hljs-built_in">GeometrySmith</span>(N, V, L, roughness);<br>            <span class="hljs-type">float</span> G_Vis = (G * VdotH) / (NdotH * NdotV);<br>            <span class="hljs-type">float</span> Fc = <span class="hljs-built_in">pow</span>(<span class="hljs-number">1.0</span> - VdotH, <span class="hljs-number">5.0</span>);<br>            <span class="hljs-comment">//pdf = D * NdotH / (4.0 * HdotV); </span><br>            A += (<span class="hljs-number">1.0</span> - Fc) * G_Vis;<br>            B += Fc * G_Vis;<br>        &#125;<br>    &#125;<br>    A /= <span class="hljs-built_in">float</span>(SAMPLE_COUNT);<br>    B /= <span class="hljs-built_in">float</span>(SAMPLE_COUNT);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">vec2</span>(A, B);<br>&#125;<br></code></pre></td></tr></table></figure> 如果一切顺利，会得到这样一张纹理：<br />
<img src="/img/00018/image-4.png" srcset="/img/loading.gif" lazyload alt="10" /><br />
代码中debug出的样子如下：<br />
<img src="/img/00018/image-5.png" srcset="/img/loading.gif" lazyload alt="11" /></p>
<h2 id="完成ibl反射">完成IBL反射</h2>
<p>对上面完成的三部分预计算纹理进行查表，即环境光Cook-Torrance反射方程的积分值。代码如下：<br />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vec3 <span class="hljs-title">fresnelSchlickRoughness</span><span class="hljs-params">(vec3 F0, vec3 V, vec3 N,<span class="hljs-type">float</span> roughness)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> F0 + (<span class="hljs-built_in">max</span>(<span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0</span> - roughness), F0) - F0) * <span class="hljs-built_in">pow</span>(<span class="hljs-number">1.0</span> - <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(N,V),<span class="hljs-number">0.0</span>), <span class="hljs-number">5.0</span>);<br>&#125; <br>...<br><span class="hljs-comment">//以环境光作为IBL</span><br>vec3 F = <span class="hljs-built_in">fresnelSchlickRoughness</span>(F0,V,N,uRoughness);<br>vec3 kD = (<span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0</span>) - F) * (<span class="hljs-number">1.0</span> - uMetallic);<br><span class="hljs-comment">//漫反射光照项</span><br>vec3 irradiance = <span class="hljs-built_in">texture</span>(uIrradianceMap,N).rgb;<br>vec3 diffuse = irradiance * albedo;<br><span class="hljs-comment">//以确保不会对一个没有数据的mip级别采样</span><br><span class="hljs-type">const</span> <span class="hljs-type">float</span> MAX_REFLECTION_LOD = <span class="hljs-number">4.0</span>;<br><span class="hljs-comment">//镜面反射光照项</span><br>vec3 prefilteredColor = <span class="hljs-built_in">textureLod</span>(uPrefilterMap,R,uRoughness * MAX_REFLECTION_LOD).rgb;<br><span class="hljs-comment">//BRDF项</span><br>vec2 brdf = <span class="hljs-built_in">texture</span>(uPbrBrdfLUT,<span class="hljs-built_in">vec2</span>(<span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(N,V),<span class="hljs-number">0.0</span>),uRoughness)).rg;<br><span class="hljs-comment">//split sum</span><br>vec3 specular = prefilteredColor * (F0 * brdf.r + brdf.g);<br><span class="hljs-comment">//环境光Cook-Torrance反射方程的积分值</span><br>vec3 ambient = (kD * diffuse + specular) * uAo;<br></code></pre></td></tr></table></figure>
使用<code>fresnelSchlickRoughness</code>函数，是由于环境光来自在半球内所有围绕着法线<code>N</code>的方向，没有单一的半向量去决定菲涅尔因子。为了仍然能模拟菲涅尔，这里采用了法线和视线的夹角。之前的算法采用了受表面粗糙度影响的微平面半向量，作为菲涅尔方程的输入。这里我们加入粗糙度来权衡这一损失。<br />
然后将<code>ambient</code>加到正常的<code>PBR</code>模型上就大功告成了：<br />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vec3 albedo = <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">texture</span>(uAlbedoMap, vTexCoords).rgb,<span class="hljs-built_in">vec3</span>(<span class="hljs-number">2.2</span>));<br><br>vec3 N = <span class="hljs-built_in">normalize</span>(vNormal);<br>vec3 V = <span class="hljs-built_in">normalize</span>(uCameraPos - vWorldPos);<br>vec3 R = <span class="hljs-built_in">reflect</span>(-V, N);<br><br>vec3 F0 = <span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.04</span>); <br>F0 = <span class="hljs-built_in">mix</span>(F0, albedo, uMetallic);<br>vec3 Lo = <span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0</span>);<br><span class="hljs-keyword">for</span> (uint i = <span class="hljs-number">0u</span>;i &lt; <span class="hljs-number">4u</span>;++i)&#123;<br>    vec3 L = <span class="hljs-built_in">normalize</span>(uLightPos[i] - vWorldPos);<br>    vec3 H = <span class="hljs-built_in">normalize</span>(V + L);<br>    <span class="hljs-comment">// float distance = length(uLightPos[i] - vWorldPos);</span><br>    <span class="hljs-comment">// float attenuation = 1.0 / (distance * distance); </span><br>    vec3 radiance = uLightColors[i] * <span class="hljs-number">1.0</span>;<br>    <span class="hljs-comment">//Cook-Torrance BRDF</span><br>    <span class="hljs-type">float</span> NDF = <span class="hljs-built_in">DistributionGGX</span>(N, H, uRoughness);   <br>    <span class="hljs-type">float</span> G   = <span class="hljs-built_in">GeometrySmith</span>(N, V, L, uRoughness); <br>    vec3 F    = <span class="hljs-built_in">fresnelSchlick</span>(F0, V, H);<br>    <span class="hljs-type">float</span> NdotL = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(N,L),<span class="hljs-number">0.0</span>);<br>    <span class="hljs-type">float</span> NdotV = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(N,V),<span class="hljs-number">0.0</span>);<br>    vec3 numerator    = NDF * G * F; <br>    <span class="hljs-type">float</span> denominator = <span class="hljs-built_in">max</span>((<span class="hljs-number">4.0</span> * NdotL * NdotV), <span class="hljs-number">0.0000001</span>);<br>    vec3 specular = numerator / denominator;<br>    <span class="hljs-comment">//Reference opengl pbr</span><br>    vec3 diffuse = (<span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0</span>)-F) * (<span class="hljs-number">1.0</span> - uMetallic) * albedo / PI;<br>    <span class="hljs-comment">// Lo += ( diffuse + specular) * radiance * NdotL;</span><br>    Lo += (specular) * radiance * NdotL;<br>&#125;<br>...<br>vec3 color = ambient + Lo;<br><span class="hljs-comment">// HDR tonemapping</span><br>color = color / (color + <span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0</span>));<br><span class="hljs-comment">// gamma correct</span><br>color = <span class="hljs-built_in">pow</span>(color, <span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0</span>/<span class="hljs-number">2.2</span>)); <br>FragColor = <span class="hljs-built_in">vec4</span>(color, <span class="hljs-number">1.0</span>);<br></code></pre></td></tr></table></figure>
为了对比<code>kulla Conty</code>方法这里吧<code>diffuse</code>项去掉。
一切顺利的话，会得到下面的效果：<br />
<img src="/img/00018/image-7.png" srcset="/img/loading.gif" lazyload alt="12" /></p>
<h1 id="kulla-conty-approximation">Kulla Conty Approximation</h1>
<h2 id="预计算eμ和e_avg">预计算E(μ)和E_avg</h2>
<p>在引入<code>Kulla Conty</code>方法之前，我们看下<code>Cook-Torrance</code>反射方程的<code>G</code>项：<br />
<img src="/img/00018/image-8.png" srcset="/img/loading.gif" lazyload alt="13" /><br />
<code>G</code>项考虑了微表面模型的自遮挡现象，在垂直角度看微表面时，几乎没有自遮挡现象，而在掠射角方向看向微表面时，自遮挡现象就会很严重，这是符合物理现象的。但是<code>G</code>项只考虑了光线在微表面上一次反射后的结果，这就导致必定会有一部分参与后续弹射的光线未被考虑进去，当粗糙度越高，沟壑越大后续弹射的光线占比越大能量损失就越多。而<code>kulla conty</code>方法就是为了弥补这部分损失的能量。</p>
<p>考虑<code>Kulla Conty</code>方法时，首先我们需要知道有多少能量丢失了，如果只考虑一次反射，那丢失的能量就是<code>1 - 一次反射</code>。而微表面反射模型本来也就是只考虑了一次的反射，我们假设所有入射方向<code>Li</code>的<code>radiance</code>都为<code>1</code>，则一次反射后我们能看到的能量为：
<span class="math display">\[
E(p,w_o)=\int_{\Omega+}\frac{DG}{4(w_o\cdot n)(w_i\cdot n)}n\cdot
w_idw_i \tag{25}
\]</span>
由于这里考虑的全反射，<code>F</code>自然就<code>1</code>，然后我们设<code>μi=cos(wi)</code>:<br />
<span class="math display">\[
E(\mu_o)=\int_{0}^{2\pi}\int_{0}^{1}f(\mu_o,\mu_i,\phi)\mu_id\mu_id\phi
\tag{26}
\]</span>
这里<code>θ</code>由<code>π/2</code>到<code>0</code>。闫老师课上讲的是用<code>sinθ</code>去替换，但是后面计算<code>sinθ</code>说不通，而不论<code>sinθ</code>替换还是<code>conθ</code>，其推导出的公式都是一样，不同的是<code>sinθ</code>，<code>θ</code>由<code>0</code>到<code>π/2</code>。</p>
<p>得到了<code>E(μo)</code>后，那我们就可以设计另一个<code>BRDF</code>使得其积分的结果为<code>1-E(μo)</code>，然后将结果加到原有的<code>BRDF</code>上面，这样就不会有能量损失了。<br />
这个新设计的<code>BRDF</code>就是：<br />
<span class="math display">\[
f_{ms}(\mu_o,\mu_i)=\frac{(1-E(\mu_o))(1-E(\mu_i))}{\pi(1-E_{avg})}
\tag{27}
\]</span>
其中<code>E_avg</code>是函数<code>E(μ)</code>在区间<code>[0,1]</code>的平均值：<br />
<span class="math display">\[
E_{avg}=\frac{\int_{0}^{1}E(\mu)\mu d\mu}{\int_{0}^{1}\mu d\mu} \\
=2\int_{0}^{1}E(\mu)\mu d\mu \tag{28}
\]</span> 其正确性参考课堂上给的过程： <img src="/img/00018/image-9.png" srcset="/img/loading.gif" lazyload
alt="14" /><br />
该新设计的<code>BRDF</code>中有两个积分值，我们同样采用打表的形式，把积分值存到一张纹理中。<code>E(μ)</code>的积分值我们同样使用重要性采样来保证结果的正确性，其代码实现如下：<br />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Vec3f <span class="hljs-title">IntegrateBRDF</span><span class="hljs-params">(Vec3f V, <span class="hljs-type">float</span> roughness)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> sample_count = <span class="hljs-number">1024</span>;<br>    <span class="hljs-type">float</span> A = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-type">float</span> B = <span class="hljs-number">0.0</span>;<br>    Vec3f N = <span class="hljs-built_in">Vec3f</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sample_count; i++) &#123;<br>        Vec2f Xi = <span class="hljs-built_in">Hammersley</span>(i, sample_count);<br>        Vec3f H = <span class="hljs-built_in">ImportanceSampleGGX</span>(Xi, N, roughness);<br>        Vec3f L = <span class="hljs-built_in">normalize</span>(H * <span class="hljs-number">2.0f</span> * <span class="hljs-built_in">dot</span>(V, H) - V);<br>        <span class="hljs-type">float</span> NoL = std::<span class="hljs-built_in">max</span>(L.z, <span class="hljs-number">0.0f</span>);<br>        <span class="hljs-type">float</span> NoH = std::<span class="hljs-built_in">max</span>(H.z, <span class="hljs-number">0.0f</span>);<br>        <span class="hljs-type">float</span> VoH = std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(V, H), <span class="hljs-number">0.0f</span>);<br>        <span class="hljs-type">float</span> NoV = std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(N, V), <span class="hljs-number">0.0f</span>);<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> To calculate (fr * ni) / p_o here - Bonus 1</span><br>        <span class="hljs-type">float</span> Fc = <span class="hljs-built_in">pow</span>(<span class="hljs-number">1.0f</span> - VoH, <span class="hljs-number">5.0f</span>);<br>        <span class="hljs-type">float</span> G = <span class="hljs-built_in">GeometrySmith</span>(roughness, NoV, NoL);<br>        <span class="hljs-type">float</span> G_Vis  = VoH * G / (NoV * NoH);<br><br>        <span class="hljs-comment">// //no split sum </span><br>        <span class="hljs-comment">// A += G_Vis;</span><br><br>        <span class="hljs-comment">// Split Sum - Bonus 2</span><br>        A += (<span class="hljs-number">1.0</span> - Fc) * G_Vis;<br>        B += Fc * G_Vis;<br>    &#125;<br>    <span class="hljs-comment">// return &#123; A / sample_count, A / sample_count, A / sample_count &#125;; // No split sum version</span><br>    <span class="hljs-keyword">return</span> &#123; A / sample_count, B / sample_count, <span class="hljs-number">0.0</span> &#125;;  <span class="hljs-comment">// Split sum</span><br>&#125;<br></code></pre></td></tr></table></figure>
其实这里严谨来说不叫<code>Split Sum</code>，该方法是对光照的剥离，我在上面章节有提到。但是作业要求有<code>Split Sum</code>的提高部分，我猜测应该是想让我们这样实现吧。但是仔细考虑的话其实也没必要这么实现，因为计算一次反射的能量，其<code>Fresenl</code>项为<code>1</code>即全反射，这里也不需要将<code>F0</code>剥离来使参数降维。就这样吧，这样得到的纹理如下：<br />
Split Sum<br />
<img src="/img/00018/image-10.png" srcset="/img/loading.gif" lazyload alt="15" /><br />
Not Split Sum<br />
<img src="/img/00018/image-11.png" srcset="/img/loading.gif" lazyload alt="16" /></p>
<p><code>E_avg</code>的预计算就比较简单了，代码如下：<br />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Vec3f <span class="hljs-title">IntegrateEmu</span><span class="hljs-params">(Vec3f V, <span class="hljs-type">float</span> roughness, <span class="hljs-type">float</span> NdotV, Vec3f Ei)</span> </span>&#123;<br>    Vec3f Eavg = <span class="hljs-built_in">Vec3f</span>(<span class="hljs-number">0.0f</span>);<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> sample_count = <span class="hljs-number">1024</span>;<br>    Vec3f N = <span class="hljs-built_in">Vec3f</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sample_count; i++) &#123;<br>        Vec2f Xi = <span class="hljs-built_in">Hammersley</span>(i, sample_count);<br>        Vec3f H = <span class="hljs-built_in">ImportanceSampleGGX</span>(Xi, N, roughness);<br>        Vec3f L = <span class="hljs-built_in">normalize</span>(H * <span class="hljs-number">2.0f</span> * <span class="hljs-built_in">dot</span>(V, H) - V);<br>        <span class="hljs-type">float</span> NoL = std::<span class="hljs-built_in">max</span>(L.z, <span class="hljs-number">0.0f</span>);<br>        <span class="hljs-comment">// float pdf = 1;//跟roughness没关系</span><br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> To calculate Eavg here</span><br>        Eavg +=  Ei * <span class="hljs-number">2.0f</span> * NoL ;<span class="hljs-comment">//Ei * 2.0f * NoL, NoL : cos thetai</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> Eavg / sample_count;<br>&#125;<br></code></pre></td></tr></table></figure> 得到纹理如下：<br />
Split Sum<br />
<img src="/img/00018/image-12.png" srcset="/img/loading.gif" lazyload alt="17" /><br />
Not Split Sum<br />
<img src="/img/00018/image-13.png" srcset="/img/loading.gif" lazyload alt="18" /></p>
<h2 id="完成kulla-conty-approximation">完成Kulla Conty
Approximation</h2>
<p>我们拿到已经预计算好的<code>E(μ)</code>和<code>E_avg</code>，现在就可以将新设计的<code>BRDF</code>积分值算出来了，代码实现如下：<br />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//split sum</span><br><span class="hljs-function">vec3 <span class="hljs-title">MultiScatterBRDF</span><span class="hljs-params">(<span class="hljs-type">float</span> NdotL, <span class="hljs-type">float</span> NdotV, vec3 F)</span></span><br><span class="hljs-function"></span>&#123;<br>  vec3 albedo = <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">texture</span>(uAlbedoMap, vTexCoords).rgb,<span class="hljs-built_in">vec3</span>(<span class="hljs-number">2.2</span>));<br><br>  <span class="hljs-comment">// A split-sum result in which R-channel repesent F interger term</span><br>  vec3 E_o = <span class="hljs-built_in">texture</span>(uKullaContyBrdflut, <span class="hljs-built_in">vec2</span>(NdotL, uRoughness)).xyz;<br>  vec3 E_i = <span class="hljs-built_in">texture</span>(uKullaContyBrdflut, <span class="hljs-built_in">vec2</span>(NdotV, uRoughness)).xyz;<br>  <span class="hljs-comment">// Split sum result add here.</span><br>  vec3 Emu_o = F * E_o.x + <span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0</span>) * E_o.y;<br>  vec3 Emu_i = F * E_i.x + <span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0</span>) * E_i.y;<br>  vec3 E_avg = <span class="hljs-built_in">texture</span>(uKullaContyEavglut, <span class="hljs-built_in">vec2</span>(<span class="hljs-number">0</span>, uRoughness)).xyz;<br>  vec3 E_avgss = F * E_avg.x + <span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0</span>) * E_avg.y;<br>  ... <br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> To calculate fms and missing energy here</span><br>  vec3 F_ms = (<span class="hljs-number">1.0</span> - Emu_o) * (<span class="hljs-number">1.0</span> - Emu_i) / (PI * (<span class="hljs-number">1.0</span> - E_avgss));<br>  ...<br>  <span class="hljs-keyword">return</span> F_ms;<br>&#125;<br></code></pre></td></tr></table></figure>
目前来说，还只能补偿<code>albedo</code>为<code>1</code>情况下的能量。如果物体本身自带颜色，那还要考虑因为物体本身吸收能量而引起的能量损失。首先要定一个平均<code>Fresenl</code>项，来表示不同入射方向下打到微表面，平均被反射出去的能量占比多少。公式如下：<br />
<span class="math display">\[
F_{avg}=\frac{\int_{0}^{1}F(\mu)\mu d\mu}{\int_{0}^{1}\mu d\mu} \\
=2\int_{0}^{1}F(\mu)\mu d\mu \tag{29}
\]</span> 这篇<a
target="_blank" rel="noopener" href="https://blog.selfshadow.com/publications/s2017-shading-course/imageworks/s2017_pbs_imageworks_slides_v2.pdf">论文</a>中，给出了该公式硬编码下的代码：<br />
<img src="/img/00018/image-14.png" srcset="/img/loading.gif" lazyload alt="19" /><br />
其中<code>r</code>是<code>albedo</code>，入射角为0度时给的值。<code>g</code>是<code>EdgeTint</code>边缘色调，入射角为80度给的值。这篇<a
target="_blank" rel="noopener" href="https://groups.google.com/g/alshaders/c/IZTbaqJMQBo">文章</a>教了我们怎么生成这两个值，我生成了金材质的<code>R</code>和<code>G</code>。<code>R(0.94423,0.77611,0.37217)</code>，<code>G(0.94806,0.86104,0.60760)</code>。</p>
<p>有了<code>平均Fresenl</code>项，我们现在从新认识一下<code>E_avg</code>：含义为不考虑菲涅尔项时，不同入射角度打到微表面时，离开表面后平均能被你看到的能量。</p>
<p>那考虑上物体本身会吸收的颜色，我们能看到一次反射后的平均能量为<span
class="math inline">\(F_{avg}E_{avg}\)</span>，则发生一次反射后没有出去的平均能量为<span
class="math inline">\(F_{avg}(1-E_{avg})\)</span>，然后这部分能量再次发生反射后我们能看到的平均能量为<span
class="math inline">\(F_{avg}(1-E_{avg})F_{avg}E_{avg}\)</span>，总结出<code>K</code>次反射后我们能看到的平均能量为<span
class="math inline">\(F_{avg}^{k}(1-E_{avg})^{k}F_{avg}E_{avg}\)</span>，最后将这部分能量全部加起来，就是一个级数，其数学公式为：<br />
<span class="math display">\[
((F_{avg}(1-E_{avg}))^{0}+(F_{avg}^{}(1-E_{avg}))^{1}+(F_{avg}(1-E_{avg}))^{k})*F_{avg}E_{avg}
\tag{30}
\]</span>
前面部分是一个等比数列，由于<code>F_avg</code>和<code>1-E_avg</code>都是小于<code>1</code>的数，所以结果为：<br />
<span class="math display">\[
=\frac{F_{avg}E_{avg}}{1-F_{avg}(1-E_{avg})} \tag{31}
\]</span>
课堂上的讲解图片如下，需要注意的是这里的<code>one bounce</code>指的是两次反射：<br />
<img src="/img/00018/image-16.png" srcset="/img/loading.gif" lazyload alt="20" /><br />
这个公式就是颜色项，我们直接乘上之前没有考虑颜色时的能量补偿项，代码实现如下：<br />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vec3 <span class="hljs-title">MultiScatterBRDF</span><span class="hljs-params">(<span class="hljs-type">float</span> NdotL, <span class="hljs-type">float</span> NdotV)</span></span><br><span class="hljs-function"></span>&#123;<br>  vec3 albedo = <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">texture</span>(uAlbedoMap, vTexCoords).rgb,<span class="hljs-built_in">vec3</span>(<span class="hljs-number">2.2</span>));<br>  vec3 E_o = <span class="hljs-built_in">texture</span>(uKullaContyBrdflut, <span class="hljs-built_in">vec2</span>(NdotL, uRoughness)).xyz;<br>  vec3 E_i = <span class="hljs-built_in">texture</span>(uKullaContyBrdflut, <span class="hljs-built_in">vec2</span>(NdotV, uRoughness)).xyz;<br>  vec3 E_avg = <span class="hljs-built_in">texture</span>(uKullaContyEavglut, <span class="hljs-built_in">vec2</span>(<span class="hljs-number">0</span>, uRoughness)).xyz;<br>  <span class="hljs-comment">//gold</span><br>  vec3 edgetint = <span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.94806</span>,<span class="hljs-number">0.86104</span>,<span class="hljs-number">0.60760</span>);<br>  vec3 F_avg = <span class="hljs-built_in">AverageFresnel</span>(albedo, edgetint);<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> To calculate fms and missing energy here</span><br>  vec3 F_ms = (<span class="hljs-number">1.0</span> - E_o) * (<span class="hljs-number">1.0</span> - E_i) / (PI * (<span class="hljs-number">1.0</span> - E_avg));<br>  vec3 F_add = F_avg * E_avg / (<span class="hljs-number">1.0</span> - F_avg * (<span class="hljs-number">1.0</span> - E_avg));<br>  <span class="hljs-keyword">return</span> F_add * F_ms;<br>&#125;<br></code></pre></td></tr></table></figure> 效果如下：<br />
<img src="/img/00018/image-15.png" srcset="/img/loading.gif" lazyload alt="21" /></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Games202/" class="category-chain-item">Games202</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Games202 Hw4 IBL and Kulla Conty</div>
      <div>https://howl144.github.io/2023/07/01/00018. Games202 Hw4/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Deng Ye</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>July 1, 2023</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/07/21/00019.%20Games202%20Hw5/" title="Games202 Hw5 JBF and SVGF">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Games202 Hw5 JBF and SVGF</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/02/19/00006.%20c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B9%8B%E8%99%9A%E8%A1%A8%EF%BC%8C%E8%99%9A%E8%A1%A8%E6%8C%87%E9%92%88%E7%AD%89/" title="c++对象模型之虚表，虚表指针，thunk，多态，多重继承this指针偏移，多重继承virtual析构函数，多重虚继承下的访问虚基类成员变量时虚表的工作原理">
                        <span class="hidden-mobile">c++对象模型之虚表，虚表指针，thunk，多态，多重继承this指针偏移，多重继承virtual析构函数，多重虚继承下的访问虚基类成员变量时虚表的工作原理</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        Views: 
        <span id="leancloud-site-pv"></span>
        
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        Visitors: 
        <span id="leancloud-site-uv"></span>
        
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
