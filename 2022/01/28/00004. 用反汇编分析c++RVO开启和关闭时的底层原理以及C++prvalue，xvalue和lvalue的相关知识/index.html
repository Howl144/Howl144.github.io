

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <meta name="google-site-verification" content="elv6HP48K6bVVMeBdbFYkmoi4IBF6JVtH0WaCgUXRNY" />
  <link rel="apple-touch-icon" sizes="76x76" href="/img/rose.png">
  <link rel="icon" href="/img/rose.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Deng Ye">
  <meta name="keywords" content="">
  
    <meta name="description" content="前言 本篇文章为笔者的读书笔记，未经允许请勿转载。本篇文章主要讲述C++prvalue，xvalue和lvalue的相关知识，会用到部分intel式和ATT式汇编的知识。我会在文章末尾给出测试代码的反汇编代码以及右值引用（Rvalue references）官方文档 :)。   三五法则 三五法则：有析构就应该有拷贝构造函数和拷贝赋值运算法（3）。c++11下，一个类还可以有移动构造函数和移动赋值">
<meta property="og:type" content="article">
<meta property="og:title" content="用反汇编分析c++RVO开启和关闭时的底层原理以及C++prvalue，xvalue和lvalue的相关知识">
<meta property="og:url" content="https://howl144.github.io/2022/01/28/00004.%20%E7%94%A8%E5%8F%8D%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90c++RVO%E5%BC%80%E5%90%AF%E5%92%8C%E5%85%B3%E9%97%AD%E6%97%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8AC++prvalue%EF%BC%8Cxvalue%E5%92%8Clvalue%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="🥰Howl&#39;s Blog">
<meta property="og:description" content="前言 本篇文章为笔者的读书笔记，未经允许请勿转载。本篇文章主要讲述C++prvalue，xvalue和lvalue的相关知识，会用到部分intel式和ATT式汇编的知识。我会在文章末尾给出测试代码的反汇编代码以及右值引用（Rvalue references）官方文档 :)。   三五法则 三五法则：有析构就应该有拷贝构造函数和拷贝赋值运算法（3）。c++11下，一个类还可以有移动构造函数和移动赋值">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://howl144.github.io/img%5C00004%5Cindex.png">
<meta property="article:published_time" content="2022-01-28T00:51:32.000Z">
<meta property="article:modified_time" content="2023-08-06T10:39:56.900Z">
<meta property="article:author" content="Deng Ye">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://howl144.github.io/img%5C00004%5Cindex.png">
  
  
  
  <title>用反汇编分析c++RVO开启和关闭时的底层原理以及C++prvalue，xvalue和lvalue的相关知识 - 🥰Howl&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"howl144.github.io","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"MY3hK2j6KKqPNCHItX2Yargj-gzGzoHsz","app_key":"U0dZRBpPFA46kRmFcsltQFF2","server_url":"https://my3hk2j6.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Howl&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/portfolio/">
                <i class="iconfont icon-pen"></i>
                <span>Portfolio</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>Category</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archive</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>About Me</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/post.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.5)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="用反汇编分析c++RVO开启和关闭时的底层原理以及C++prvalue，xvalue和lvalue的相关知识"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-01-28 08:51" pubdate>
          January 28, 2022 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          17k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          144 mins
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> views
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">用反汇编分析c++RVO开启和关闭时的底层原理以及C++prvalue，xvalue和lvalue的相关知识</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p><strong>本篇文章为笔者的读书笔记，未经允许请勿转载。</strong><br>本篇文章主要讲述C++prvalue，xvalue和lvalue的相关知识，会用到部分intel式和ATT式汇编的知识。我会在文章末尾给出测试代码的反汇编代码以及右值引用（Rvalue references）官方文档 :)。</p>
</blockquote>
<hr>
<h1 id="三五法则"><a href="#三五法则" class="headerlink" title="三五法则"></a>三五法则</h1><blockquote>
<p>三五法则：有析构就应该有拷贝构造函数和拷贝赋值运算法（3）。<br>c++11下，一个类还可以有移动构造函数和移动赋值运算符（3+2）。<br>三五法则时候一般情况，如果不想某个函数被普通或者友元使用可以将其定义为&#x3D;delete或者在private里面声明但不定义，具体参考C++ primer p449。<br>移动函数的出现提高了类内存转让的效率，而支承这一技术的基础就是prvalue,xvalue,lvalue.<br>(xvalue和prvalue统称为rvalue，lvalue和xvalue统称为glvalue。只需要记住上面说的三种就可以，这两个统称可以不用记)。<br>这三种值的出现场合和特点在后文详细说明。</p>
</blockquote>
<hr>
<h1 id="未开启RVO优化与xvalue和prvalue的关系"><a href="#未开启RVO优化与xvalue和prvalue的关系" class="headerlink" title="未开启RVO优化与xvalue和prvalue的关系"></a>未开启RVO优化与xvalue和prvalue的关系</h1><blockquote>
<p>关闭RVO的方法:<br>eg:<code>clang++ -g -fno-elide-constructors /home/dengye/test/test.cpp -o /home/dengye/test/test</code><br>先设计一个三五法则的类，再分析关闭和开启RVO时程序的堆栈分布图。<br>废话不多说开整！</p>
</blockquote>
<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> val=<span class="hljs-number">0</span>):<span class="hljs-built_in">bVal</span>(val)&#123;&#125;<br>    <span class="hljs-comment">// B(const B&amp; tmp):bVal(tmp.bVal)&#123;&#125;</span><br>    ~<span class="hljs-built_in">B</span>()&#123;&#125;<br>    <span class="hljs-type">int</span> bVal;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>):<span class="hljs-built_in">ptrb</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>(tmp))<br>    &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;构造函数&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-type">const</span> Foo&amp; src):<span class="hljs-built_in">ptrb</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>(*(src.ptrb)))<span class="hljs-comment">//会继续调用B的拷贝构造函数</span><br>    &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;拷贝构造函数&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br>    Foo&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Foo&amp; src)<br>    &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;拷贝赋值函数&quot;</span>&lt;&lt;std::endl;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;src)<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//防止自己给自己赋值。</span><br>        <span class="hljs-keyword">delete</span> ptrb;<span class="hljs-comment">//先把自己的这块内存干掉</span><br>        ptrb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>(*(src.ptrb));<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    <br>    &#125;<br>    <span class="hljs-built_in">Foo</span>(Foo&amp;&amp; src) <span class="hljs-keyword">noexcept</span> :<span class="hljs-built_in">ptrb</span>(src.ptrb)<span class="hljs-comment">//noexcept:通知标准库我们这个移动构造函数不抛出任何异常（如果编译器确认函数不会抛出异常，它就能执行某些特殊的优化操作，而这些操作不适合用于可能出错的代码），例如我们希望在vector重新分配内存这类情况下对我们自定义类型的对象进行移动而不是拷贝，就必须显式地告诉标准库我们的移动构造函数可以安全使用。《c++primer》p474，690。</span><br>    &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;移动构造函数&quot;</span>&lt;&lt;std::endl;        <br>        src.ptrb = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//记得将原来指向堆内存的指针置空.</span><br>    &#125;<br>    Foo&amp; <span class="hljs-keyword">operator</span>=(Foo&amp;&amp; src) <span class="hljs-keyword">noexcept</span><br>    &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;移动赋值函数&quot;</span>&lt;&lt;std::endl;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;src)<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">delete</span> ptrb;<br>        ptrb = src.ptrb;<span class="hljs-comment">//这里不需要在new，直接从src那里拿来</span><br>        src.ptrb = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//记得置空</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">Foo</span>()<br>    &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;析构函数&quot;</span>&lt;&lt;std::endl;<br>        <span class="hljs-keyword">delete</span> ptrb;<span class="hljs-comment">//删一个空指针没任何反应</span><br>    &#125;<br>    B *ptrb;<br>&#125;;<br><span class="hljs-function">Foo <span class="hljs-title">RVO_test</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Foo <span class="hljs-title">foo</span><span class="hljs-params">(val)</span></span>;<br>    <span class="hljs-keyword">return</span> foo;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Foo fooRvo = <span class="hljs-built_in">RVO_test</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>在分析之前我先把该程序的内存分布图画出来帮大家理解，见下图：</p>
</blockquote>
<h2 id="像这种random-offset的出现，就是为了避免溢出攻击。画这张图要用到nm命令（寻找代码段，bss段和data段的起始地址），gdb的vmmap命令（寻找堆栈的起始和结束地址）。灰色部分表示这些范围在进程虚拟地址空间中不可用，也就是说，没有为这些区域创建页表（page-table）。"><a href="#像这种random-offset的出现，就是为了避免溢出攻击。画这张图要用到nm命令（寻找代码段，bss段和data段的起始地址），gdb的vmmap命令（寻找堆栈的起始和结束地址）。灰色部分表示这些范围在进程虚拟地址空间中不可用，也就是说，没有为这些区域创建页表（page-table）。" class="headerlink" title="&gt;像这种random offset的出现，就是为了避免溢出攻击。画这张图要用到nm命令（寻找代码段，bss段和data段的起始地址），gdb的vmmap命令（寻找堆栈的起始和结束地址）。灰色部分表示这些范围在进程虚拟地址空间中不可用，也就是说，没有为这些区域创建页表（page table）。"></a><img src="/img/00004/1.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&gt;像这种random offset的出现，就是为了避免溢出攻击。画这张图要用到<code>nm</code>命令（寻找代码段，bss段和data段的起始地址），gdb的<code>vmmap</code>命令（寻找堆栈的起始和结束地址）。灰色部分表示这些范围在进程虚拟地址空间中不可用，也就是说，没有为这些区域创建页表（page table）。</h2><h2 id="反汇编配合堆栈图分析流程"><a href="#反汇编配合堆栈图分析流程" class="headerlink" title="反汇编配合堆栈图分析流程"></a>反汇编配合堆栈图分析流程</h2><p><strong>友情提醒：请配合附件中的反汇编代码进行分析。</strong><br><img src="/img/00004/2.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><img src="/img/00004/3.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<blockquote>
<p>到达这一步以前发生的事情有：main函数开辟出了0x20字节的空间，将rbp-0x18的地址（临时对象prvalue）给了rdi，然后将0x64给了esi，接着调用了RVO_test(int)函数，还没push rbp。</p>
</blockquote>
<hr>
<p><img src="/img/00004/4.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p><img src="/img/00004/5.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<blockquote>
<p>到达这一步以前发生的事情有：RVO_test(int)函数开辟了0x30字节的空间，rdi寄存器存着临时对象prvalue的地址，然后将其赋给了rbp-0x8，rbp-0x20，rbp-0x28，又将0x64赋给了rbp-0xc（形参val），最后在临时对象foo的地址上进行了构造。</p>
</blockquote>
<hr>
<p><img src="/img/00004/6.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p><img src="/img/00004/7.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<blockquote>
<p>到达这一步以前发生的事情有：编译器将rbp-0x18（局部对象foo）的内容移动到了临时对象的里面。此时局部对象的指针数据成员指向空，在RVO_test(int)函数返回时，会析构这个局部对象，而delete一个空指针没任何反应。最后RVO_test(int)函数将rbp-0x28地址上的内容赋给rax作为返回值。</p>
</blockquote>
<hr>
<p><img src="/img/00004/8.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p><img src="/img/00004/9.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<blockquote>
<p>到达这一步以前发生的事情有：RVO_test(int)函数回收了0x30字节的空间，pop rbp时会将保存的main函数的rbp地址取出来放到rbp栈基址寄存器里面，同时rsp会+8，指向要跳转的代码段。最后一步没执行，不难看出ret是让rip指令寄存器指向rsp的内容，即跳转到&lt;main+29&gt;。</p>
</blockquote>
<hr>
<p><img src="/img/00004/10.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p><img src="/img/00004/11.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<blockquote>
<p>到达这一步以前发生的事情有：临时对象的内容被移动赋值函数转移到了main函数的局部对象fooRvo。然后临时对象就被析构了，接着main函数将返回值0赋给rbp-0x4所指的空间，最后fooRvo对象也被析构。程序随之结束。</p>
</blockquote>
<hr>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote>
<p>无RVO返回优化，编译器会生成一个prvalue或者xvalue的<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/implicit_conversion">临时对象（Temporary materialization）</a>（《深度探索c++对象模型》p267），取决于prvalue是否出现在丢弃值表达式（<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/expressions#Discarded-value_expressions">Discarded-value expressions</a>）里。像这样写<code>Foo fooRvo = RVO_test(100);</code>RVO_test(100)产生的临时对象就是prvalue，这种prvalue被称为”有一个结果对象”（<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/value_category">such prvalue is said to have a result object</a>）。而这样写<code>Foo fooRvo;fooRvo = RVO_test(100);</code>RVO_test(100)产生的临时对象就是xvalue，原因就是prvalue出现在了丢弃值表达式里。这种表达式包括了任何完整表达式语句（<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/expressions#Discarded-value_expressions">Such expressions include the full expression of any expression statement</a>）。然后临时对象的地址会被传入到RVO_test(int)函数中，该函数中的局部对象foo在返回时触发移动构造函数将foo的内存转让给临时对象。为什么会触发移动构造函数呢？归功于return语句，一个拷贝操作发生在return语句时，会被忽略或者被对待成rvalue，目的在于选择一个重载后的构造函数（Note:A copy operation associated with a return statement may be elided or considered as an rvalue for the purpose of overload resolution in selecting a constructor (12.8). —end note,本句子出自<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/compiler_support/11">c++标准手册文档-N2118的6.6.3 - The return statement</a>）。由于右值引用可以接受一个rvalue，这个被return转化后的rvalue选择了移动构造函数。至此临时对象被构造出来，RVO_test(int)函数的局部对象foo被析构。而临时对象prvalue，由于赋值运算符的存在，会去调用移动构造函数，（细心的小伙伴肯定要问为啥不是调用重载后的移动赋值函数，很简单！赋值运算符在定义处表现出来的形式为构造而不是拷贝）。待main函数中的fooRvo对象被构造出来后，临时对象也被析构。最后fooRvo对象被析构。<br>.<br>这是clang编译器下运行完代码的结果:<br><img src="/img/00004/12.png" srcset="/img/loading.gif" lazyload alt="这是运行完代码的结果"></p>
<p>注意：MSVC编译有接住这个民间概念，也就说<code>Foo fooRvo = RVO_test(100);</code>这条语句中，RVO_test产生的临时对象会被fooRvo对象接住，从而不执行对临时对象的析构。或者说fooRvo的空间和临时对象的空间合二为一了。我平时写代码都是用的clang编译器，以前刚开始学c++是在MSVC所以这里就稍微提及一下MSVC的不同之处。<br>.<br>这是MSVC编译器下运行完代码的结果：<br><img src="/img/00004/13.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
</blockquote>
<hr>
<h1 id="开启RVO优化"><a href="#开启RVO优化" class="headerlink" title="开启RVO优化"></a>开启RVO优化</h1><blockquote>
<p>代码还是用上面的代码</p>
</blockquote>
<p><img src="/img/00004/14.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><img src="/img/00004/15.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<blockquote>
<p>上面已经带着大家分析过一遍了，这里就直接跳到最后看结果。<br>对比关闭RVO来说，RVO_test(int)函数的局部对象就是直接构造到fooRvo对象里面去了，中间一个移动构造都没有。通过分析反汇编代码不难发现，它为了优化返回局部对象，直接让fooRvo对象的内存接管了局部对象foo的，可以说是合二为一了。但是有一个问题，局部对象foo一定要执行析构函数呀！别急，它这里妙手回春一手，将一字节的标志位放在了RVO_test(int)函数的栈帧中，然后通过判断标志位跳过对局部对象foo的析构函数执行。这玩意儿有点像加了if的goto :)。<br>.<br>这是clang编译器下运行完代码的结果:<br><img src="/img/00004/16.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>有关临时对象的认识可以参考《深度探索c++对象模型》p267</p>
</blockquote>
<hr>
<h1 id="xvalue-prvalue和lvalue"><a href="#xvalue-prvalue和lvalue" class="headerlink" title="xvalue,prvalue和lvalue"></a>xvalue,prvalue和lvalue</h1><blockquote>
<p>这里笔者就帮大家把坑填上，相信大家对上面测试代码分析过后会对prvalue和xvalue有个初步的印象，即函数返回时可能会涉及到它们。<br>对于这三种值的概述：<br>每一个c++的表达式（作用在运算对象上的重载操作符，字面常量，一个变量名，”a &#x3D; b”（an assignment expression），etc.）都会有两个独立的属性：一种类型，一个值的类别。每个表达式都有一些非引用类型，并且每个表达式都恰好属于三个主要值类别中的一个:prvalue、xvalue和lvalue。这三种值没有一个确切的定义，或者说你要废很大功夫去定义它们，亦或者描述个大概即可。<br>下面我们来看这三种值类型的概要定义以及特性（完整请参考<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/value_category">Value categories</a>）：<br>（补充一句，检测表达式的值类别的相关代码，我放在了附录中，感兴趣的读者可以自行验证感到疑惑的地方）</p>
</blockquote>
<ul>
<li>lvalue<blockquote>
<p>lvalue：所谓左值，从历史的角度来考虑，它可以出现在一个赋值表达式的左边。资源可以被重用（resources can be reused）。有空间地址但不能被移动</p>
<ul>
<li>一般有名字，除了 unamed lvalue（<code>*ptr </code>是一个没有名字的lvalue，一个返回值为lvalue reference的函数调用表达式也是没名字的lvalue），如果有单独的一个 identifier 来表示它，它一定是 lvalue</li>
<li>可以用 &amp; 符号取其地址，除了bit field（<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/bit_field">The type of a bit field can only be integral or enumeration type.</a>）</li>
<li>一个函数或者重载操作符的返回值为lvalue reference<br>例如 <code>std::getline(std::cin, str) or std::cout &lt;&lt; 1 or str1 = str2 or ++iter</code></li>
<li>其生命周期为其所在的 scope</li>
<li>一些内置操作符表达式<br>内置前自增自减，解引用，内置下标表达式（<code>a[n]</code>是一个lvalue的情况下），类类型的内置成员访问表达式（除了访问枚举数据成员和非静态成员函数，还有一些特例请参考<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/value_category">Primary categories</a>），逗号表达式（最右边的操作数为lvalue的情况下），三元条件表达式（第二个和第三个操作数为lvalue的情况下）</li>
<li>将表达式强制转换为左值引用类型和右值引用函数署名类型（<a target="_blank" rel="noopener" href="https://en.cppreference.com/book/intro/functions">The signature of a function</a>）<br>例如 <code>static_cast&lt;int&amp;&gt;(x)</code><br>例如 <code>static_cast&lt;void (&amp;&amp;)(int)&gt;(x)</code></li>
<li>在所有 literal 中，只有 string literal 是 lvalue：<code>cout &lt;&lt; &amp;&quot;dy&quot; &lt;&lt; endl</code>;（其他 literal 是 rvalue：<code>cout &lt;&lt; &amp;&#39;d&#39; &lt;&lt; endl</code>; 非法）</li>
</ul>
<h2 id="lvalue的特性："><a href="#lvalue的特性：" class="headerlink" title="lvalue的特性："></a>lvalue的特性：</h2></blockquote>
</li>
</ul>
<blockquote>
<ul>
<li>可以通过取址运算符获取其地址，<code>&amp;++i[1]</code> and <code>&amp;std::endl </code>像这样的表达式都是合法的</li>
<li>可修改的左值可用作内置赋值和<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/operator_assignment#Builtin_compound_assignment">内置复合赋值运算</a>符的左操作数</li>
<li>可以用来初始化左值引用，这个左值引用将是lvalue的别名。</li>
<li>lvalue可以被隐式地转换为prvalue就像lvalue-to-rvalue, array-to-pointer, or function-to-pointer的隐式转换。（<code>int ival1 = 1;int ival2 = -ival1;</code>，这里减号可以lvalue隐式转换成prvalue）</li>
<li>可以是多态的（<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/object#Polymorphic_objects">Polymorphic</a>），它所对应的<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/type#Dynamic_type">动态类型</a>和静态类型可以不一样，例如：一个指向子类的父类指针</li>
<li>可以是<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/type#Incomplete_type">不完整类型</a>，只要表达式允许。例如：由前置声明但未定义的类类型</li>
</ul>
</blockquote>
<ul>
<li>xvalue<blockquote>
<p>xvalue：一个将要到期的值（生命周期被延长），资源可以被重用的对象。有空间地址可以被移动。</p>
<ul>
<li>一个函数调用或者重载操作符函数表达式的返回值为rvalue reference<br>例如 <code>std::move(x)</code>；</li>
<li>将表达式的类型强制转换为右值引用类型。<br>例如<code>(int&amp;&amp;)a</code>，<code>static_cast&lt;int&amp;&amp;&gt;(a)</code>。</li>
<li>内置下标表达式（<code>a[n]</code>为一个xvalue的情况下）。</li>
<li>类类型的内置成员访问表达式。<br>例如<code>a.m</code>是一个 xvalue，a是xvalue，m是非引用类型的非静态数据成员。<br>以及 <code>a.*mp </code>是一个 xvalue。a是xvalue，mp 叫做 pointer to data member（《c++primer》p739）。</li>
<li>三元条件表达式（第二个和第三个操作数为xvalue的情况下）</li>
<li>指定临时对象的任何表达式（除了prvalue initializes an object的情况）(since C++17)<h2 id="xvalue的特性："><a href="#xvalue的特性：" class="headerlink" title="xvalue的特性："></a>xvalue的特性：</h2></li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li>可以被绑定到右值引用和const左值引用，同时生命周期被延长到这个引用的作用域结束</li>
<li>xvalue可以具有多态性（<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/object#Polymorphic_objects">Polymorphic</a>）</li>
<li>非类类型的xvalue可以被const和volatile修饰（<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/cv">cv type qualifiers</a>）</li>
<li>xvalue可以被隐式地转换为prvalue就像lvalue-to-rvalue, array-to-pointer, or function-to-pointer的隐式转换<br>（<code>int ival = 1;if((int&amp;&amp;)ival)&#123;putchar(&#39;Y&#39;);&#125;</code>xvalue被隐式转换成了prvalue）</li>
<li>可以是不完整类型</li>
<li>不能被取地址（通过内置取地址运算符）</li>
<li>不能是内置赋值和<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/operator_assignment#Builtin_compound_assignment">内置复合赋值运算</a>符的左操作数</li>
<li>当作用在函数参数时，有两个函数重载都可用，一个是右值引用参数，另一个是const左值引用参数，一个xrvalue会绑定到参数为右值引用的重载函数上（因此，拷贝和移动构造函数都存在时，一个xrvalue会去调用移动构造而不是拷贝构造，同理作用于拷贝和移动赋值运算符）</li>
</ul>
</blockquote>
<ul>
<li>prvalue<blockquote>
<p>prvalue：一个将要消亡的值（生命周期马上结束），资源不可以被重用（想要被重用必须转化成xvalue）的对象。一部分有空间地址但马上就会被回收（空间地址可以被后面的新数据覆盖），一部分没有空间地址。可以被移动。</p>
<ul>
<li>所有 literals：bool literal (例如<code> true</code>)，integer literal (例如 <code>42</code>) 等等（无空间地址）。</li>
<li>实质上的函数调用：(<strong>return non-reference</strong>)（有空间地址）<br><code>f() </code>function call<br><img src="/img/00004/17.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></li>
</ul>
<p><code>a.f() </code>static or non-static member function<br><code>A()</code> 包括各种构造函数<br><code>str1 + str2</code> 重载 operator 也相当于函数调用<br><code>functor()</code> (对应 operator() 重载)<br><code>[]&#123;&#125;() </code>lambda (对应 operator() 重载)</p>
<ul>
<li>一些内置操作符产生的运算结果（无空间地址）：<br><code>a++</code> 自增自减<br><code>a+b</code> 加减乘除<br><code>a&amp;b</code> 位运算<br><code>a&amp;&amp;b</code> 逻辑运算<br><code>a&lt;b</code> 关系运算<br><code>&amp;a</code> 取地址<br><code>a, b</code> comma expression (如果b 是 rvalue)<br><code>(int)a</code> 或 static_cast&lt; int&gt;(a) 强制类型转换<br><code>a ? b : c </code>（第二个和第三个操作数为rvalue的情况下）</li>
<li>enumerator 枚举值（无空间地址）：<br><code>enum &#123; yes, no &#125;;</code> 中的 yes, no<br><code>a.m</code> 或 <code>p-&gt;m</code>，其中 m 是 member enumerator</li>
<li>普通成员函数本身（<a target="_blank" rel="noopener" href="https://en.cppreference.com/book/intro/functions">The signature of a function</a>）（无空间地址）<br><code>a.m</code> 或 <code>p-&gt;m</code> 或 <code>a.*pm</code> 或 <code>p-&gt;*pm</code>，其中 m 和 pm 都对应普通成员函数(non-static)</li>
<li>this 指针（有空间地址）<br>被当做参数传进去放在栈帧上。<h2 id="prvalue的特性："><a href="#prvalue的特性：" class="headerlink" title="prvalue的特性："></a>prvalue的特性：</h2></li>
<li>不会是多态的</li>
<li>非类非数组的prvalue不能被cv-qualified修饰，除非它为了被绑定到一个cv-qualified的引用类型上而转换化成xvalue (since C++17)，      例如 ：<code>const int&amp; i = 1；</code>(注意：一个函数调用或者强制类型转换表达式会导致生成一个非类cv-qualified类型，但是cv-qualifier通常会立即被剥离。)</li>
<li>prvalue不能有不完整的类型（使用decltype指示符时也不能有，除了void）</li>
<li>prvalue不能有抽象类类型或者an array thereof（不太懂官方要表达的意思，所以就以英文方式放在这里供大家参考）:(</li>
<li>不能被取地址（通过内置取地址运算符）</li>
<li>不能是内置赋值和<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/operator_assignment#Builtin_compound_assignment">内置复合赋值运算</a>符的左操作数</li>
<li>当作用在函数参数时，有两个函数重载都可用，一个是右值引用参数，另一个是const左值引用参数，一个prvalue会绑定到参数为右值引用的重载函数上（因此，拷贝和移动构造函数都存在时，一个prvalue会去调用移动构造而不是拷贝构造，同理作用于拷贝和移动赋值运算符）</li>
</ul>
</blockquote>
</li>
</ul>
<hr>
<h1 id="Temporary-materialization"><a href="#Temporary-materialization" class="headerlink" title="Temporary materialization"></a>Temporary materialization</h1><blockquote>
<p>经过对xvalue,prvalue和lvalue对认识后，咱们来聊聊临时对象，除了xvalue可以被称为临时对象，prvalue在某些情况下也可以被称为临时对象。从一个任何完整类型T的prvalue转换为相同类型T的xvalue的过程被称为临时物化（Temporary materialization）。该转换将prvalue作为其结果对象求值，从而将prvalue初始化为T类型的临时对象，并生成一个表示临时对象的xvalue(since C++17)。如果T是一个类或者类类型的数组，它必须具有可访问且未删除的析构函数。<br>Temporary materialization 会发生在下列情况中：**(since C++17)**</p>
<ul>
<li>绑定作用于prvalue时<br><code>int&amp;&amp; c = 1;const int&amp; c = 1;</code>c绑定的是一个xvalue</li>
<li>在一个prvalue类上使用成员访问运算符时<br><code>A().m; </code>pvalue A() 自动变成一个 xvlaue<br><code>A().*mp;</code> pvalue A() 自动变成一个 xvlaue</li>
<li>prvalue数组转变成一个指针或被绑定时，或者用下标访问一个prvalue数组<br>1.prvalue数组被绑定时<br><code>int (&amp;&amp; a)[2] = (int[])&#123;1, 2&#125;;</code><br>2.prvalue数组转变成一个指针时<br><code>[](int* iptr)&#123;std::cout&lt;&lt;*iptr;&#125;((int[])&#123;1,2&#125;);</code><br>对于一个对象或者一个表达式，如果可以对其使用调用运算符，则称它为可调用对象(《c++primer》p345)<br>3.用下标访问一个prvalue数组时<br><code>((int[])&#123;1, 2&#125;)[0];</code></li>
<li>当从带括号的列表初始化初始化std::initializer_list<T>类型的对象时;<br>《c++primer》p197</li>
<li>   typid作用于一个prvalue时<br>《c++primer》p732</li>
<li>sizeof作用于一个prvalue时</li>
<li>当一个prvalue出现在丢弃值表达式（<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/expressions#Discarded-value_expressions">Discarded-value expressions</a>）<br>上文研究开启RVO时讲过。</li>
<li>注意：当从相同类型的prvalue初始化一个对象时(通过直接初始化或复制初始化)不会发生临时物化:这样的对象是直接从初始化器初始化的。这确保了“拷贝副本的省略(RVO的工作机制)”。（上文研究开启RVO时讲过，prvalue可以用来初始化一个对象，这种prvalue被称为”有一个结果对象”（<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/value_category">such prvalue is said to have a result object</a>））<br><img src="/img/00004/18.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></li>
</ul>
<p>重要的事情说三遍！<br>从一个任何完整类型T的prvalue转换为相同类型T的xvalue的过程被称为临时物化<br>从一个任何完整类型T的prvalue转换为相同类型T的xvalue的过程被称为临时物化<br>从一个任何完整类型T的prvalue转换为相同类型T的xvalue的过程被称为临时物化</p>
</blockquote>
<hr>
<h1 id="引用折叠（万能引用，引用塌缩）"><a href="#引用折叠（万能引用，引用塌缩）" class="headerlink" title="引用折叠（万能引用，引用塌缩）"></a>引用折叠（万能引用，引用塌缩）</h1><blockquote>
<p>上面说过移动操作的出现提高了类内存转让的效率，而支承这一技术的基础就是prvalue,xvalue,lvalue。但右值引用才是移动操作能实现的根本原因。这里咱们好好讲一讲右值引用的相关知识引用折叠（关于右值引用的基础知识请参看《c++primer》p471这里不多赘述）。<br>引用折叠的两个规则被称为C++语言在正常绑定规则之外定义的两个例外规则，允许这种绑定。而这两个例外规则是move这种标准模板库设施正确工作的基础。<br>先介绍一下它的两个规则：</p>
<ul>
<li>.规则一：对于一个给定类型<code>T</code>，当我们将一个左值传给模板函数的右值引用参数时，编译器推断模板类型参数T为左值引用类型（T&amp;），例如对于<code>int</code>类型的左值时，推断<code>T</code>为<code>int&amp;</code>；当我们将一个右值传进去时，<code>T</code>被推断出来的类型为<code>T</code>，例如对于<code>int</code>类型的右值时，推断<code>T</code>为<code>int</code>。</li>
<li>例外规则二：如果我们间接创建了一个引用的引用，则这些引用形成了引用折叠。正常情况下，不能直接创建引用的引用，但是可以间接创建（如类型别名和模板参数）。大部分情况下，引用的引用会折叠为普通的左值引用（T&amp; &amp;、T&amp; &amp;&amp;、 T&amp;&amp; &amp;都会折叠成类型T&amp;），右值引用和右值引用，则折叠成右值引用（T&amp;&amp; &amp;&amp;折叠成T&amp;&amp;）。《c++primer》p608</li>
</ul>
</blockquote>
<hr>
<h2 id="对上面两个规则熟练后，我们来分析一下标准库move函数"><a href="#对上面两个规则熟练后，我们来分析一下标准库move函数" class="headerlink" title="对上面两个规则熟练后，我们来分析一下标准库move函数:"></a>对上面两个规则熟练后，我们来分析一下标准库move函数:</h2><blockquote>
<p>虽然不能直接将一个右值引用绑定到一个左值上，但可以用move获得一个绑定到左值上的xvalue。由于move本质上可以接受任何类型的实参，因此我们不会惊讶于他一个函数模板。</p>
<ul>
<li>std::move是如何定义的<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>&gt;<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp;<br>&gt;<span class="hljs-built_in">move</span>(T&amp;&amp; t) <span class="hljs-keyword">noexcept</span><br>&gt;&#123; <br>&gt;<span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t); <br>&gt;&#125;<br></code></pre></td></tr></table></figure>
在返回类型和类型转换中也要用到<code>typename</code>（《c++primer》p593）。<code>std::remove_reference&lt;T&gt;::type</code>的用处就是去除类型的引用（《c++primer》p605）。<code>static_cast</code>静态类型转换（《c++primer》p145）。</li>
<li>std::move是如何工作的</li>
</ul>
<p>这段代码很短，但其中有些微妙之处。首先，move的函数参数<code>T&amp;&amp;</code>是一个指向模板类型参数的右值引用。通过引用折叠，此参数可以与任何类型的实参匹配。特别是，我们既可以传递给move一个左值，也可以传递给它一个右值:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-function">string <span class="hljs-title">s1</span> <span class="hljs-params">( <span class="hljs-string">&quot;hi! &quot;</span>)</span>,s2</span>;<br>&gt;s2 = std::<span class="hljs-built_in">move</span> (<span class="hljs-built_in">string</span> ( <span class="hljs-string">&quot;bye!&quot;</span>) );<span class="hljs-comment">//正确:从一个右值移动数据</span><br>&gt;s2 = std::<span class="hljs-built_in">move</span>(s1);<span class="hljs-comment">//正确:但在赋值之后，s1的值是不确定的(内容被移动赋值运算符移动过)。</span><br></code></pre></td></tr></table></figure>
<p>在第一个赋值中，传递给move的实参是string的构造函数的右值结果。在<code>std::move(string(&quot;bye!&quot;))</code>中:</p>
<ol>
<li>推断出的T的类型为string。</li>
<li>因此remove_reference用string进行实例化。</li>
<li>remove_reference<string>的type成员是string。</li>
<li>move的返回类型是string&amp;&amp;。</li>
<li>move的函数参数t的类型为string&amp;&amp;。</li>
</ol>
<p>因此，这个调用实例化move<string>，即函数<br><code>string&amp;&amp; move(string &amp;&amp;t)</code></p>
<p>函数体返回<code>static_cast&lt;string&amp;&amp;&gt;(t)</code>。<code>t</code>的类型已经是<code>string&amp;&amp;</code>,于是类型转换什么都不做。因此，此调用的结果就是它所接受的右值引用（返回值为右值引用类型有临时对象产生）。<br>.<br>.现在考虑第二个赋值，它调用了<code>std::move ()</code>。在此调用中，传递给move的实参是一个左值。这样:</p>
<ol>
<li>推断出的T的类型为string&amp; (string 的引用，而非普通string)。</li>
<li>因此，remove reference用string&amp;进行实例化。</li>
<li>remove reference&lt;string&amp;&gt;的type成员是string。</li>
<li>move的返回类型仍是string&amp;&amp; 。</li>
<li>move的函数参数t实例化为string&amp; &amp;&amp;，会折叠为string&amp;。</li>
</ol>
<p>因此，这个调用实例化<code>move&lt;string&amp;&gt;</code>，即<br><code>string&amp;&amp;  move(string &amp;t)</code><br>这正是我们所寻求的—我们希望将一个右值引用绑定到一个左值。这个实例的函数体返回<code>static_cast&lt;string&amp;&amp;&gt;(t)</code>。在此情况下，<code>t</code>的类型为<code>string&amp;</code>，cast将其转换为<code>string&amp;&amp;</code>(强转伴随临时对象xvalue的产生其空间地址与<code>std::move()</code>函数产生的临时对象xvalue的空间地址相同)。<br><img src="/img/00004/19.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>将右值引用绑定到一个被强转成xvalue的左值，这一特性被称为截断。（《c++primer》p612）</p>
<h3 id="std-move-函数总结"><a href="#std-move-函数总结" class="headerlink" title="std::move()函数总结"></a>std::move()函数总结</h3><p>说白了<code>std::move()</code>函数就是将一个prvalue或者lvalue转变成xvalue的过程，这样不管是prvalue还是lvalue都可以被右值引用接受。</p>
</blockquote>
<hr>
<h2 id="接下来咱们来分析标准库forward函数"><a href="#接下来咱们来分析标准库forward函数" class="headerlink" title="接下来咱们来分析标准库forward函数:"></a>接下来咱们来分析标准库forward函数:</h2><blockquote>
<p>在分析forward源码之前，咱们先来看看forward完成了一个什么样的功能。<br>我们知道某些函数需要将其一个或多个实参连同类型不变地转发给其他函数。在此情况下，我们需要保持被转发实参的所有性质,包括实参类型是否是<code>const</code>的以及实参是左值还是右值。<br>作为一个例子，我们将编写一个函数，它接受一个可调用表达式和两个额外实参。我们的函数将调用给定的可调用对象，将两个额外参数逆序传递给它。下面是我们的翻转函数的模样:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//接受一个可调用对象和另外两个参数的模板</span><br><span class="hljs-comment">//对“翻转”的参数调用给定的可调用对象</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span> T1,<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flip2</span><span class="hljs-params">(F f,T1 &amp;&amp;t1,T2 &amp;&amp;t2)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">f</span> (t2,t1);<br>)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> v1,<span class="hljs-type">int</span> &amp;v2)</span></span><br><span class="hljs-function"></span>&#123;<br>	std::cout &lt;&lt; v1 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ++v2 &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>通过将一个函数参数定义为一个指向模板类型参数的右值引用，我们可以保持其对应实参的所有类型信息。而使用引用参数(无论是左值还是右值)使得我们可以保持<code>const</code>属性，因为在引用类型中的<code>const</code>是底层的。如果我们将函数参数定义为<code>T1&amp;&amp;</code>和<code>T2&amp;&amp;</code>, 通过引用折叠，就可以保持翻转后实参的左值&#x2F;右值属性（对应实参的<code>const</code>属性和左值&#x2F;右值属性将得到保持）:<br>例如，如果我们调用<code>flip2(f，j，42)</code>，将传递给参数<code>t1</code>一个左值<code>j</code>。但是，在<code>flip2</code>中，推断出的<code>T1</code>的类型为<code>int&amp;</code>，这意味着<code>t1</code>的类型会折叠为<code>int&amp;</code>。由于是引用类型，<code>t1</code>被绑定到<code>j</code>上。当<code>flip2</code>调用<code>f</code>时，<code>f</code>中的引用参数<code>v2</code>被绑定到<code>t1</code>，也就是被绑定到<code>j</code>。当<code>f</code>递增<code>v2</code>时，它也同时改变了<code>j</code>的值。<br>.<br>现在，咱们不用可调用对象<code>f</code>，用<code>g</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//接受一个可调用对象和另外两个参数的模板</span><br><span class="hljs-comment">//对“翻转”的参数调用给定的可调用对象</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span> T1,<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flip2</span><span class="hljs-params">(F f,T1 &amp;&amp;t1,T2 &amp;&amp;t2)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">g</span>(t2,t1);<br>)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;&amp;i, <span class="hljs-type">int</span>&amp; j)</span></span><br><span class="hljs-function"></span>&#123;<br>	std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>如果我们试图通过<code>flip2</code>调用<code>g</code>，则参数<code>t2</code>将被传递给<code>g</code>的右值引用参数。即使我们传递一个右值给<code>flip2</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">flip2</span>(g, i，<span class="hljs-number">42</span>);<span class="hljs-comment">//错误:不能从一个左值实例化int&amp;&amp;</span><br></code></pre></td></tr></table></figure>
<p>传递给<code>g </code>的将是<code>flip2</code>中名为<code>t2</code>的参数。函数参数与其他任何变量一样，都是左值表达式。因此，<code>flip2</code>中对 <code>g</code>的调用将传递给<code>g</code>的右值引用参数一个左值。<br>.<br>在调用中使用<code>std::forward</code>保持类型信息<br>.<br>我们可以使用一个名为forward 的新标准库设施来传递<code>flip2</code>的参数,它能保持原始实参的类型。类似move,forward定义在头文件utility中。与move不同,forward必须通过显式模板实参来调用。forward返回该显式实参类型的右值引用。即，<code>forward&lt;T&gt;</code>的返回类型是<code>T&amp;&amp;</code>。<br>通常情况下，我们使用forward传递那些定义为模板类型参数的右值引用的函数参数。通过其返回类型上的引用折叠，forward可以保持给定实参的左值&#x2F;右值属性(forward可以保持实参类型的所有细节)。<br>使用forward，我们可以再次重写翻转函数:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> F,<span class="hljs-keyword">typename</span> T1,<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flip</span><span class="hljs-params">(F f,T1 &amp;&amp;t1,T2 &amp;&amp;t2)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">g</span>(std::forward&lt;T2&gt;(t2),std::forward&lt;T1&gt;(t1)) ;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;&amp;i, <span class="hljs-type">int</span>&amp; j)</span></span><br><span class="hljs-function"></span>&#123;<br>	std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>如果我们调用<code>flip(g, i，42)</code>，<code>i</code>将以<code>int&amp;</code>类型传递给<code>g</code>，<code>42</code>将以<code>int&amp;&amp;</code>类型的<code>xvalue</code>传递给<code>g</code>。（primer没说清楚，单纯因为42是int&amp;&amp;类型是无法传给可调用对象g。lvalue可以是int&amp;&amp;类型，xvalue也可以是int&amp;&amp;类型，但是lvalue不能传给右值引用，而xvalue可以。）</p>
</blockquote>
<hr>
<blockquote>
<p>现在咱们知道forward是干什么的了。废话不多说直接分析它的源码，看看它如何保持实参类型的所有细节。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> _Tp&amp;&amp;</span><br><span class="hljs-function"><span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="hljs-type">_t</span>)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123; <br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="hljs-type">_t</span>); <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> _Tp&amp;&amp;</span><br><span class="hljs-function"><span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="hljs-type">_t</span>)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">static_assert</span>(!std::is_lvalue_reference&lt;_Tp&gt;::value, <span class="hljs-string">&quot;template argument&quot;</span><br>		    <span class="hljs-string">&quot; substituting _Tp is an lvalue reference type&quot;</span>);    <br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="hljs-type">_t</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>std::forward</code>有两个版本的重载，一个用于左值一个用于右值。不过咱们一般用的是第一个版本，因为用在形参上，形参不管怎么样都是个左值。那我们就只分析第一个版本的情况：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> F,<span class="hljs-keyword">typename</span> T1,<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flip</span><span class="hljs-params">(F f,T1 &amp;&amp;t1,T2 &amp;&amp;t2)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">g</span>(std::forward&lt;T2&gt;(t2),std::forward&lt;T1&gt;(t1)) ;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;&amp;i, <span class="hljs-type">int</span>&amp; j)</span></span><br><span class="hljs-function"></span>&#123;<br>	std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>就拿上面这个例子来说，如果我们调用<code>flip(g, i，42)</code>。<br><code>T2</code>将被推导成<code>int</code>，<code>t2</code>的类型为<code>int&amp;&amp;</code>。调用<code>std::forward&lt;T2&gt;(t2)</code>时，forward函数将被实例化成：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span>&amp;&amp;</span><br><span class="hljs-function"><span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; <span class="hljs-type">_t</span>)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123; <br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&amp;&amp;&gt;(<span class="hljs-type">_t</span>); <br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>_t</code>的类型为<code>int&amp;</code>，return时<code>_t</code>被强制转换成<code>int&amp;&amp;</code>，此时强转产生的<code>xvalue</code>和forward函数由返回类型<code>int&amp;&amp;</code>而产生的<code>xvalue</code>在同一空间地址。<code>xvalue</code>可以被函数<code>g</code>的形参 <code>i </code>所接受，完成<code>flip</code>实参<code>42</code>的类型保持。</p>
<p><code>T1</code>将被推导成<code>int&amp;</code>，<code>t1</code>的类型被折叠成<code>int&amp;</code>。调用<code>std::forward&lt;T1&gt;(t1)</code>时，forward函数将被实例化成：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span>&amp;</span><br><span class="hljs-function"><span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; <span class="hljs-type">_t</span>)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123; <br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&amp;&gt;(<span class="hljs-type">_t</span>); <br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>返回类型折叠成<code>int&amp;</code>。<code>t1</code>传入<code>flip</code>中是左值引用传入，被forward转换后也是左值引用。完成类型保持。</p>
</blockquote>
<hr>
<h3 id="std-forward总结"><a href="#std-forward总结" class="headerlink" title="std::forward总结"></a>std::forward总结</h3><blockquote>
<p>不难看出forward函数跟move函数的工作原理都一样，用的引用折叠技术。</p>
<ul>
<li>forward将g函数的右值引用类型实参从左值转换成右值，保持rvalue能被int&amp;&amp;接收的性质（可调用对象的形参类型为int&amp;&amp;，接受实参值的类型为rvalue）。</li>
<li>而g函数的左值引用类型实参，进入forward是左值引用进入，函数返回也是左值引用传出，没变化。</li>
<li>最后g函数的形参为int类型时，接受实参值的类型为lvalue或rvalue。forward不管怎么转换，它都可以接受。</li>
</ul>
<p>这就是所谓的类型保持（可能叙述的不是特别详细，毕竟过程有点复杂，只是起一个抛砖引玉的作用，大家可以下去自己捣鼓捣鼓）。<br>.</p>
</blockquote>
<hr>
<h2 id="最后咱们来看下move和forword的不同之处。"><a href="#最后咱们来看下move和forword的不同之处。" class="headerlink" title="最后咱们来看下move和forword的不同之处。"></a>最后咱们来看下move和forword的不同之处。</h2><blockquote>
<p>std::move函数的源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>&gt;<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp;<br>&gt;<span class="hljs-built_in">move</span>(T&amp;&amp; t) <span class="hljs-keyword">noexcept</span><br>&gt;&#123; <br><span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t); <br>&gt;&#125;<br></code></pre></td></tr></table></figure>
<p>std::forward函数的源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>&gt;<span class="hljs-keyword">constexpr</span> _Tp&amp;&amp;<br>&gt;forward(<span class="hljs-keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="hljs-type">_t</span>) <span class="hljs-keyword">noexcept</span><br>&gt;&#123; <br><span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="hljs-type">_t</span>); <br>&gt;&#125;<br></code></pre></td></tr></table></figure>
<p>不难发现，move函数的<code>std::remove_reference&lt;T&gt;::type</code>，放在返回类型和<code>static_cast&lt;&gt;</code>中，而且后面都是直接接上两个<code>&amp;&amp;</code>。他这样写的目的在于，不管<code>t</code>接受的是一个右值还是一个左值，返回出来值的类型永远都是右值。永远能被<code>int&amp;&amp;</code>接受。<br>而forward函数的<code>std::remove_reference&lt;T&gt;::type</code>，放在形参<code>_t</code>上，而且返回类型和<code>static_cast&lt;&gt;</code>都用了引用折叠技术，值得注意的一点是move函数不需要显示指定模板的类型，而forward函数需要显示指定实参类型。forward函数的形参一定是引用传入，而且返回类型和<code>static_cast&lt;&gt;</code>可以根据实参类型动态改变。forward函数的实参类型为<code>int&amp;&amp;</code>，则返回类型为<code>int&amp;&amp;</code>，返回出去的就是一个<code>xvalue</code>。forward函数的实参类型为<code>int&amp;</code>，则返回类型也为<code>int&amp;</code>，返回出去的和传入进来的都是实参的引用。</p>
</blockquote>
<hr>
<h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><blockquote>
<p>注意：下面的文件下载都是免费的，0积分下载，别被VIP字样吓到了蛤 :D<br><a target="_blank" rel="noopener" href="https://download.csdn.net/download/Howl_1/77241824">右值引用相关文档</a><br><a target="_blank" rel="noopener" href="https://download.csdn.net/download/Howl_1/77242257">测试代码的反汇编代码</a></p>
</blockquote>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><blockquote>
<p>摘取自《c++ template 2nd》附录中的内容，可以用来检查表达式的值类别（ value category of the expression：prvalue，xvalue或lvalue）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ISXVALUE(x) \</span><br><span class="hljs-meta">std::is_rvalue_reference<span class="hljs-string">&lt;decltype((x))&gt;</span>::value</span><br>&gt;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ISLVALUE(x)	\</span><br><span class="hljs-meta">std::is_lvalue_reference<span class="hljs-string">&lt;decltype((x))&gt;</span>::value</span><br>&gt;<span class="hljs-meta">#<span class="hljs-keyword">define</span> CHEECK_VALUE_CATOGORIES(x) \</span><br><span class="hljs-meta"><span class="hljs-keyword">if</span>(ISXVALUE(x)) printf(<span class="hljs-string">&quot;%s is a xvalue\n&quot;</span>,#x);\</span><br><span class="hljs-meta"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ISLVALUE(x)) printf(<span class="hljs-string">&quot;%s is a lvalue\n&quot;</span>,#x);\</span><br><span class="hljs-meta"><span class="hljs-keyword">else</span> printf(<span class="hljs-string">&quot;%s is a prvalue\n&quot;</span>,#x);</span><br></code></pre></td></tr></table></figure>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/C/" class="category-chain-item">C++</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>用反汇编分析c++RVO开启和关闭时的底层原理以及C++prvalue，xvalue和lvalue的相关知识</div>
      <div>https://howl144.github.io/2022/01/28/00004. 用反汇编分析c++RVO开启和关闭时的底层原理以及C++prvalue，xvalue和lvalue的相关知识/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Deng Ye</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>January 28, 2022</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/02/09/00005.%20C++11,14,17%E4%B8%ADauto%E5%92%8Cdecltype%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E5%8F%8A%E6%8B%93%E5%B1%95/" title="C++11,14,17中auto和decltype相关知识及拓展">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">C++11,14,17中auto和decltype相关知识及拓展</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/07/25/00003.%20%E4%BD%BF%E7%94%A8tcpdump%E8%A7%82%E5%AF%9FTCP%E5%A4%B4%E9%83%A8%E4%BF%A1%E6%81%AF%EF%BC%88%E8%A1%A5%E5%85%85TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%EF%BC%89/" title="使用tcpdump观察TCP头部信息和三次握手四次挥手">
                        <span class="hidden-mobile">使用tcpdump观察TCP头部信息和三次握手四次挥手</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        Views: 
        <span id="leancloud-site-pv"></span>
        
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        Visitors: 
        <span id="leancloud-site-uv"></span>
        
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
