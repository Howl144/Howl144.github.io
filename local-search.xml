<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Games202 Hw5 JBF and SVGF</title>
    <link href="/2023/07/21/00019.%20Games202%20Hw5/"/>
    <url>/2023/07/21/00019.%20Games202%20Hw5/</url>
    
    <content type="html"><![CDATA[<h1 id="最终效果图">最终效果图</h1><p>为了降低图片存储空间，只能控制一下FPS以及分辨率了，看起来像ppt别介意👀。<br />这是降噪前的截图<br /><img src="/img/00019/image-11.png" alt="0" /> Pinkroom-SVGF<br /><img src="/img/00019/pinkroom-svgf.gif" alt="1" /><br />Pinkroom-JBF-Atrous<br /><img src="/img/00019/pinkroom-JBF-atrous.gif" alt="2" /></p><h1 id="作业要求总览">作业要求总览</h1><ol type="1"><li>实现单帧降噪。<br /></li><li>实现两帧间的投影。<br /></li><li>实现两帧间的累积。<br /></li><li>Bouns 1：实现A-Trous Wavelet加速单帧降噪。</li></ol><p>个人扩展部分：Spatiotemporal-Variance-Guided-Filtering</p><h1 id="源码">源码</h1><p>暂未公开</p><h1 id="前言">前言</h1><p>关于作业的构建以及完整运行流程本文不做太多介绍，网上有很多关于该部分内容的教程，重点放在算法本身。</p><h1 id="概述">概述</h1><p>本次作业框架提供了<code>exr文件</code>的读写操作（exr的内容就是1Spp的pathtracing得到的结果），我们需要的数据也通过<code>FrameInfo</code>封装好了，需要完成的地方就是<code>denoiser类</code>的成员函数。</p><p>关于<code>读取exr</code>需要的注意的地方就是,<code>width</code>和<code>height</code>记得将其初始化一下，否则<code>exr文件</code>读取错误时，内存会直接撑爆，卡的要死。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Buffer2D&lt;Float3&gt; <span class="hljs-title">ReadFloat3Image</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;filename)</span> </span>&#123;<br>    <span class="hljs-type">int</span> width = <span class="hljs-number">0</span>, height = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">float</span> *_buffer = <span class="hljs-built_in">ReadImage</span>(filename, width, height, <span class="hljs-number">3</span>);<br>    ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">float</span> *<span class="hljs-title">ReadImage</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;filename, <span class="hljs-type">int</span> &amp;width, <span class="hljs-type">int</span> &amp;height,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;channel)</span> </span>&#123;<br>    ...<br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">LoadEXR</span>(&amp;out, &amp;width, &amp;height, filename.<span class="hljs-built_in">c_str</span>(), &amp;err);<br>    <span class="hljs-comment">//不初始化，读取失败后width * height得到的值巨大无比。</span><br>    <span class="hljs-type">float</span> *buffer = <span class="hljs-keyword">new</span> <span class="hljs-type">float</span>[width * height * channel];<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>然后就是<code>debug</code>部分在这里加上断点，可以让你在调试时候通过<strong>堆栈</strong>快速定位问题地方。否则报错只有简短的报错信息，压根不知道是哪错了。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">inline</span> T &amp;Buffer2D&lt;T&gt;::<span class="hljs-built_in">operator</span>()(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;y) &#123;<br>    <span class="hljs-keyword">if</span> (!(<span class="hljs-number">0</span> &lt;= x &amp;&amp; x &lt; m_width &amp;&amp; <span class="hljs-number">0</span> &lt;= y &amp;&amp; y &lt; m_height))<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="实现-jbf-a-trous-wavelet">实现 JBF A-Trous Wavelet</h1><h2 id="高斯滤波">高斯滤波</h2><p>先介绍一下高斯滤波在图形学的应用后面会用到<br />二维高斯函数的定义为：<br /><span class="math display">\[f(x,y) = \dfrac{1}{2\pi\sigma^{2}}e^{-\dfrac{x^{2}+y^{2}}{2\sigma^{2}}}\]</span></p><p><code>x,y</code> ：是偏移值，<span class="math inline">\(r^2 = x^2 +y^2\)</span>可以看做距离平方<br /><code>σ</code> ：是正态分布的标准偏差，可以决定函数的胖瘦。</p><p>在二维空间中，这个公式生成的曲面的等高线是从中心开始呈正态分布的同心圆。分布不为零的像素组成的卷积矩阵与原始图像做变换。每个像素的值都是周围相邻像素值的加权平均。原始像素的值有最大的高斯分布值，所以有最大的权重，相邻像素随着距离原始像素越来越远，其权重也越来越小。</p><p>一个<code>3 * 3</code>高斯核的偏移图：<br /><span class="math display">\[\begin{bmatrix}-1,1 &amp; 0,1 &amp; 1,1 \\\-1,0 &amp; 0,0 &amp; 1,0 \\\-1,-1 &amp; 0,-1 &amp; 1,-1\end{bmatrix}\]</span></p><p>假定<span class="math inline">\(\sigma =0.8\)</span>，根据偏移值和高斯函数可以得到一个<code>3 * 3</code>高斯核：<br /><span class="math display">\[\begin{bmatrix}0.05212 &amp; 0.1138 &amp; 0.05212 \\\0.1138 &amp; 0.2486 &amp; 0.1138 \\\0.05212 &amp; 0.1138 &amp; 0.05212\end{bmatrix}\]</span>由于高斯核的大小不能无限大，所以该上面生成的高斯核权重加起来大约只有<code>0.91</code>左右。在次之前需要除以左上角的值使最小值为<code>1</code>，然后取整，最后进行归一化处理，使<code>3 * 3</code>的高斯核总权重为<code>1</code>，得到一个类高斯的滤波核。下面是归一化的高斯核：<br /><span class="math display">\[\begin{bmatrix}\dfrac{1}{16} &amp; \dfrac{1}{8} &amp; \dfrac{1}{16} \\\\dfrac{1}{8} &amp; \dfrac{1}{4} &amp; \dfrac{1}{8} \\\\dfrac{1}{16} &amp; \dfrac{1}{8} &amp; \dfrac{1}{16}\end{bmatrix}\]</span></p><h2 id="联合双边滤波">联合双边滤波</h2><p>权重总和为<code>1</code>或不为<code>1</code>的滤波器的实现在课上有提到：<br /><img src="/img/00019/implementation-of-filtering.png" alt="3" /><code>w_ij</code> : 遍历到周围像素时，该像素的权重。<br /><code>sum_of_weights</code> :各像素权重总和，如果是上面提到的归一化高斯核，则该值等于<code>1</code>。<br /><code>sum_of_weighted_values</code> :各像素值经过权重处理后的总和。<br /><code>C^&#123;input&#125;[j]</code> :各像素的值，可以是灰度值或者<code>RGB</code>颜色值。<br />总的来说，就是每个像素都会考虑它一定范围内像素值对它的贡献，最后再除以<strong>权重总和</strong>就是该像素的颜色值。这样做优点在于，它不会引起整体能量的降低或升高，不会导致图像整体变暗或变亮。<br />所以我们不需要再关系滤波核的权重，而是关注滤波核的形状，而图像降噪部分最重要的就是滤波核的形状。</p><p>如果只是使用高斯滤波核，则图像的高频信息都会被抹去，保留住了低频信息，这样看起来图像就会变得很模糊：<br /><img src="/img/00019/gaussian-filter.png" alt="4" />而我们还是希望边界不要被糊掉，以及保留一些有用的高频信息，这就引入了新的方法<code>BF(Bilateral Filtering)</code>：<br /><img src="/img/00019/bilateral-filtering.png" alt="5" /><code>i</code>，<code>j</code> 表示一个点；<code>k</code>，<code>l</code> 表示另一个点。<br />该方法在类高斯滤波（一切随距离衰减的函数都可以用，所以前面那一坨就去掉了）上增加了一个颜色贡献项，也就说中心周围的像素和中心像素的颜色差异过大就不给予它贡献，这样边界这种高频信息就不会被糊掉。下面就是该方法的效果：<br /><img src="/img/00019/bilateral-filtering-result.png" alt="6" />效果是好了很多，边界也很清晰了，但还是有问题，山体以及水面很多有用的高频信息被当做噪声抹掉了，也就是说该方法分不清噪点和有用的高频信息。</p><p>所以在此基础上，再增加一些新的判断标准就可以保留更多有用的高频信息，这就是引入了<code>JBF/CBF(Joint/Cross Bilateral Filtering)</code>:<br /><span class="math display">\[J(i,j) = \exp(-\frac{\lVert i-j\lVert ^2}{2\sigma_{p}^2} - \frac{\lVert\widetilde{C}[i] - \widetilde{C}[j] \lVert ^2 }{2\sigma_{c}^2} -\frac{D_{normal}(i,j)^2}{2\sigma_{n}^2} -\frac{D_{plane}(i,j)^2}{2\sigma_{d}^2})\]</span></p><p>其中<code>i</code>，<code>j</code> 为不同的两个像素点。 <spanclass="math display">\[D_{normal}(i,j) = arccos(Normal[i] \cdot Normal[j])\]</span></p><p><span class="math display">\[D_{plane}(i,j) = Normal[i]\cdot \frac{Position[j] - Position[i]}{\lVertPosition[j] - Positon[i] \lVert}\]</span></p><p><spanclass="math inline">\(\widetilde{C}\)</span>为有噪声的输入图像，<spanclass="math inline">\(D_{normal}\)</span>为两法线夹角，<spanclass="math inline">\(D_{plane}\)</span>为深度差值指标。公式中的各个<code>σ</code>值在<code>Denoiser</code>类中有提供。</p><p>该方法新增两个判断标准来源<code>Gbuffer</code>，由于<code>Gbuffer</code>生成的纹理是没有任何噪声的，所以用它们来指导滤波效果非常不错，而且生成<code>Gbuffer</code>的性能消耗几乎可以忽略不计，在第一趟<code>Rasterization</code>生成<code>Primary Ray</code>的时候直接顺带就生成了所需要的<code>Gbuffer</code>。</p><p><code>JBF</code>的代码等到后面讲解<code>A-Trous Wavelet</code>单帧降噪加速时在贴上。</p><h2 id="两帧间的投影">两帧间的投影</h2><p>这一步主要是找出当前帧的每个像素在上一帧对应是哪个像素，如下图所示：<br /><img src="/img/00019/back-projection.png" alt="7" />我们称这一过程为<code>Back Projection</code>，它实现的具体表达式如下：<br /><span class="math display">\[Screen_{i-1} = E_{i-1}P_{i-1}V_{i-1}M_{i-1}M_{i}^{-1}World_{i}\]</span> <span class="math inline">\(E_{i-1}\)</span>是视口变换，闫老师说公式中漏掉了，这里我补上。<br />我们可以通过该式子找到当前帧当前片段对应的上一帧的片段，上述式子中所需要的各种数据在框架中都有提供，具体请后面的代码实现。找到的上一帧信息还有可能无法使用，这一现象我们称作为<code>Temporal Failure</code>，如下图所示，有三种情境会导致投影得到的信息无效。<br /><img src="/img/00019/temporal-failure.png" alt="8" />左边的箱子是上一帧，右边的箱子是当前帧。<br />disocclusion ：当前帧新出现的物体，由被遮挡的状态变成未被遮挡的状态。</p><p>前两种情况由屏幕空间的范围来约束它，超出范围的直接丢弃（因为上一帧并未记录屏幕外的信息）。对于第三种，我们则用一个叫<code>Object ID</code>的方法来检测<code>Temporal Failure</code>，如果上一帧和当前帧的<code>Object ID</code>不一致则丢弃，说明当前帧该物体属于<code>disocclusion</code>状态。</p><p>代码实现如下：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Denoiser_JBF::Reprojection</span><span class="hljs-params">(<span class="hljs-type">const</span> FrameInfo &amp;frameInfo)</span> </span>&#123;<br>    <span class="hljs-type">int</span> height = m_accColor.m_height;<br>    <span class="hljs-type">int</span> width = m_accColor.m_width;<br>    Matrix4x4 pre_World_To_Screen =<br>        m_preFrameInfo.m_matrix[m_preFrameInfo.m_matrix.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel for</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; height; y++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; width; x++) &#123;<br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Reproject</span><br>            <span class="hljs-built_in">m_valid</span>(x, y) = <span class="hljs-literal">false</span>;<br>            <span class="hljs-built_in">m_misc</span>(x, y) = <span class="hljs-built_in">Float3</span>(<span class="hljs-number">0.f</span>);<br><br>            <span class="hljs-type">int</span> id = frameInfo.<span class="hljs-built_in">m_id</span>(x, y);<br>            <span class="hljs-keyword">if</span> (id == <span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            Matrix4x4 world_to_local = <span class="hljs-built_in">Inverse</span>(frameInfo.m_matrix[id]);<br>            Matrix4x4 pre_local_to_world = m_preFrameInfo.m_matrix[id];<br>            <span class="hljs-keyword">auto</span> world_position = frameInfo.<span class="hljs-built_in">m_position</span>(x, y);<br>            <span class="hljs-keyword">auto</span> local_position =<br>                <span class="hljs-built_in">world_to_local</span>(world_position, Float3::EType::Point);<br>            <span class="hljs-keyword">auto</span> pre_world_position =<br>                <span class="hljs-built_in">pre_local_to_world</span>(local_position, Float3::EType::Point);<br>            <span class="hljs-keyword">auto</span> pre_screen_position =<br>                <span class="hljs-built_in">pre_World_To_Screen</span>(pre_world_position, Float3::EType::Point);<br><br>            <span class="hljs-keyword">if</span> (pre_screen_position.x &lt; <span class="hljs-number">0</span> || pre_screen_position.x &gt;= width ||<br>                pre_screen_position.y &lt; <span class="hljs-number">0</span> || pre_screen_position.y &gt;= height) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> pre_id =<br>                    m_preFrameInfo.<span class="hljs-built_in">m_id</span>(pre_screen_position.x, pre_screen_position.y);<br>                <span class="hljs-keyword">if</span> (pre_id == id) &#123;<br>                    <span class="hljs-built_in">m_valid</span>(x, y) = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-built_in">m_misc</span>(x, y) =<br>                        <span class="hljs-built_in">m_accColor</span>(pre_screen_position.x, pre_screen_position.y);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//m_misc是一个临时存储的buffer，如果一趟pass中，读写是同一个buffer，就需要另开一个buffer来避免它们相互干扰。在后面svgf中我们也会经常这么使用。</span><br>    std::<span class="hljs-built_in">swap</span>(m_misc, m_accColor);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>其中<code>world_to_local</code>对应 <spanclass="math inline">\(M_{i}^{-1}\)</span>，<code>pre_local_to_world</code>对应<spanclass="math inline">\(M_{i-1}\)</span>，<code>pre_World_To_Screen</code>对应<span class="math inline">\(E_{i-1}P_{i-1}V_{i-1}\)</span>。</p><h2 id="两帧间的累积">两帧间的累积</h2><p>上一节中我已经拿到了上一帧有用的历史信息，这一小节则是将当前帧与上一帧进行线性混合，在线性混合之前还需要一次<code>Clamp</code>操作，将上一帧的颜色利用当前帧的均值和方差严格控制在当前帧颜色附近，公式如下：<span class="math display">\[\overline{C}_{i}=\alpha\overline{C}_{i}+(1-\alpha)Clamp(\overline{C}_{i-1})\]</span> <spanclass="math inline">\(\alpha\)</span>的值通常取<code>0.2</code>。<br />对于<code>Clamp</code>部分，首先需要计算 <spanclass="math inline">\(\overline{C}_{i}\)</span>在<code>7 * 7</code>的邻域内的均值<code>μ</code>和方差<code>σ</code>，然后把上一帧的颜色<spanclass="math inline">\(\overline{C}_{i-1}\)</span><code>Clamp</code>在<span class="math inline">\((\mu - k\sigma, \mu + k\sigma)\)</span>范围内。</p><p>代码实现如下：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Denoiser_JBF::TemporalAccumulation</span><span class="hljs-params">(<span class="hljs-type">const</span> Buffer2D&lt;Float3&gt; &amp;curFilteredColor)</span> </span>&#123;<br>    <span class="hljs-type">int</span> height = m_accColor.m_height;<br>    <span class="hljs-type">int</span> width = m_accColor.m_width;<br>    <span class="hljs-type">int</span> kernelRadius = <span class="hljs-number">3</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel for</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; height; y++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; width; x++) &#123;<br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Temporal clamp</span><br>            Float3 color = <span class="hljs-built_in">m_accColor</span>(x, y);<br>            <span class="hljs-comment">//Set Alpha to 1 when no legal corresponding point was found in the previous frame</span><br>            <span class="hljs-type">float</span> alpha = <span class="hljs-number">1.0f</span>;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">m_valid</span>(x, y)) &#123;<br>                alpha = m_alpha;<br><br>                <span class="hljs-type">int</span> x_start = std::<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, x - kernelRadius);<br>                <span class="hljs-type">int</span> x_end = std::<span class="hljs-built_in">min</span>(width - <span class="hljs-number">1</span>, x + kernelRadius);<br>                <span class="hljs-type">int</span> y_start = std::<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, y - kernelRadius);<br>                <span class="hljs-type">int</span> y_end = std::<span class="hljs-built_in">min</span>(height - <span class="hljs-number">1</span>, y + kernelRadius);<br><br>                <span class="hljs-function">Float3 <span class="hljs-title">mu</span><span class="hljs-params">(<span class="hljs-number">0.f</span>)</span></span>;<br>                <span class="hljs-function">Float3 <span class="hljs-title">sigma</span><span class="hljs-params">(<span class="hljs-number">0.f</span>)</span></span>;<br><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> m = x_start; m &lt;= x_end; m++) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = y_start; n &lt;= y_end; n++) &#123;<br>                        mu += <span class="hljs-built_in">curFilteredColor</span>(m, n);<br>                        <span class="hljs-comment">//sqr：平方</span><br>                        sigma += <span class="hljs-built_in">Sqr</span>(<span class="hljs-built_in">curFilteredColor</span>(x, y) - <span class="hljs-built_in">curFilteredColor</span>(m, n));<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-type">int</span> count = kernelRadius * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 7 * 7</span><br>                count *= count;<br><br>                mu /= <span class="hljs-built_in">float</span>(count);<br>                sigma = <span class="hljs-built_in">SafeSqrt</span>(sigma / <span class="hljs-built_in">float</span>(count));<br>                color = <span class="hljs-built_in">Clamp</span>(color, mu - sigma * m_colorBoxK, mu + sigma * m_colorBoxK);<br>            &#125;<br><br>            <span class="hljs-built_in">m_misc</span>(x, y) = <span class="hljs-built_in">Lerp</span>(color, <span class="hljs-built_in">curFilteredColor</span>(x, y), alpha);<br>        &#125;<br>    &#125;<br>    std::<span class="hljs-built_in">swap</span>(m_misc, m_accColor);<br>&#125;<br></code></pre></td></tr></table></figure><code>Clamp</code>是为了减轻<code>Lagging(拖影)</code>现象，如果什么都不做强行使用上一帧的信息，就会导致拖影现象:<br /><img src="/img/00019/lagging.png" alt="9" /></p><p>使用了<code>Clamp</code>方法后，拖影现象没了，但是会重新引入噪声，不过相比于拖影效果还是好了很多：<br /><img src="/img/00019/noise.png" alt="10" /></p><p>通常<code>Object ID</code>和<code>Clamp</code>方法是一起使用。</p><p>即使我们已经做得足够好了，但还是有很多的<code>Temporal Failure</code>，并不是因为几何的原因，而是<code>shading</code>过程中也会出问题，也就是说阴影或者反射这种现象，在用上一帧的信息时，它的<code>motion vector</code>是零，当前帧当前片段就会用上一帧的信息，这就会导致阴影拖尾或者反射延迟的现象：<br />Detached/Lagging shadows<br /><img src="/img/00019/lagging-shadows.png" alt="11" /> Reflectionhysteresis<br /><img src="/img/00019/reflection-hysteresis.gif" alt="12" /></p><h2 id="加速单帧降噪">加速单帧降噪</h2><h3 id="separate-passes">Separate Passes</h3><p>在此之前还介绍一种<code>Separate Passes</code>的方法，该方法可以将复杂度从<code>N^2</code>降到<code>2N</code>：<br /><img src="/img/00019/image.png" alt="13" />该方法很适合高斯滤波，因为高斯滤波在定义上就可以拆分成两个方向上函数的乘积形式,滤波过程中相当于先水平方向做一次卷积，然后将结果给到竖直方向再做一次卷积，非常完美：<br /><img src="/img/00019/image-1.png" alt="14" />但问题是<code>BF</code>和<code>JBF</code>的卷积核，不是一个高斯函数，想要将它拆分成水平竖直的函数是几乎不可能，但这里是实时渲染，“约等于”无处不在😆，<code>filter</code>的范围只要不是太大比如<code>32 * 32</code>还是可以勉强用一用的。</p><h3 id="a-trous-wavelet">A-Trous Wavelet</h3><p>上面提到的<code>Separate Passes</code>方法，我还没看到在哪里用上了😅。而<code>A-Trous Wavelet</code>方法在降噪这方面几乎是通吃，应用非常广泛：<br /><img src="/img/00019/image-2.png" alt="15" />这里<code>ppt</code>上的图片不太好理解，我这里引用一下知乎<ahref="https://zhuanlan.zhihu.com/p/607012514">花桑</a>的图片<br /><img src="/img/00019/image-3.png" alt="16" /><code>A-Trous Wavelet</code>方法相当于吧一个非常大范围的<code>filter过程</code>分解成<code>几趟pass</code>来完成，我们需要<code>filter</code>的点位<code>p</code>就是<code>const Float3 p = ipos + Float3(xx, yy,0) * stepSize;</code>其中<code>ipos</code>中心点，<code>xx,yy</code>是偏移值，<code>stepSize</code>则是<span class="math inline">\(2^{pass-1}\)</span><br />这样<code>3</code>趟<code>5 * 5</code>的滤波就相当于<code>16 * 16</code>的滤波。在实际应用中，我们通常使用一个大小为<code>5 * 5</code>的滤波核，走<code>5</code>趟，来模拟<code>64 * 64</code>的滤波过程。(5* 5的滤波核，走5趟，filter半径即 <span class="math inline">\(2 \times2^{5-1}=32\)</span>)</p><p>当然这只是该方法的应用，它的原理其实很复杂，简单概述一下：<br /><img src="/img/00019/image-4.png" alt="17" /> 对于第一个问题：<br />为什么要用一个逐渐增加的<code>filter</code>范围，不能一上来就是最大范围？<br />图上给出的答案是，逐渐增加的<code>filter</code>范围 ==去掉更低的频率。<br />对于第一趟<code>pass</code>，我们<code>filter</code>的过程是将高频信息限制在一个可接受的范围内，往后的每一趟<code>pass</code>都是在前一趟的基础上继续将高频信息限制在一个更低的可接受范围内，所以这里“去掉更低的频率”意思是相比于上一趟<code>pass</code>，去掉比上一趟高频信息更低一点的高频信息。自然这个过程就是<code>filter</code>的范围是逐渐增加，而不能一上来就是<code>filter</code>最大的范围。<br />对于第二个问题：<br />为什么可以安全的跳过一些采样点？<br />图上给出的答案是，采样 == 重复搬移频谱。<br />首先对于采样来说，时域上的采样等于原始函数乘上冲击函数。而对应频域上，就是原始频谱卷积冲击频谱，相当于对在频域上对原始频谱进行搬移的操作，而且时域冲击函数的冲击间隔越大，对应频域搬移的间隔就越小：<br /><img src="/img/00019/image-5.png" alt="18" /><br />(a)为原始函数，(b)为该函数经过傅里叶变化后的频谱。<br />(c)为冲击函数，(d)为该函数经过傅里叶变化后的频谱。<br />(e)为原始函数乘上冲击函数的结果。<br />(f)为(b)(d)频谱卷积后的结果。<br />我们知道如果时域采样间隔增加大，频域上频谱混叠就越严重，只有当频谱中高频信息被抹掉后，混叠才不会引起走样。这也是要用一个逐渐增加的<code>filter</code>范围的一个原因。<br /><img src="/img/00019/image-6.png" alt="19" />回到问题上，<code>A-Trous Wavelet</code>的采样间隔为<spanclass="math inline">\(2^{pass-1}-1\)</span>，这种采样间距的好处是搬移的边界正好是上一趟留下的最高频率。所以这种采样可以安全的跳过一些采样点，而不引入走样。<br />结合第一个问题和第二个问题，当前<code>pass</code>会除去一些更低的高频信息，有助于搬移混叠时减少走样现象，以<spanclass="math inline">\(2^{pass-1}-1\)</span>的间隔去采样，由于搬移时左右边界都是上一次留下的最高频信息，所以这种逐渐增大的采样间隔并不会新增走样。更多内容请关注该论文：<br /><a href="https://jo.dreggn.org/home/2010_atrous.pdf">Edge-AvoidingÀ-Trous Wavelet Transform for fast Global Illumination Filtering</a></p><p><code>JBF A-Trous Wavelet</code>的代码实现如下：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Buffer2D&lt;Float3&gt; <span class="hljs-title">Denoiser_JBF::ATrousWaveletFilter</span><span class="hljs-params">(<span class="hljs-type">const</span> FrameInfo &amp;frameInfo)</span> </span>&#123;<br>    <span class="hljs-type">int</span> height = frameInfo.m_beauty.m_height;<br>    <span class="hljs-type">int</span> width = frameInfo.m_beauty.m_width;<br>    Buffer2D&lt;Float3&gt; filteredImage = <span class="hljs-built_in">CreateBuffer2D</span>&lt;Float3&gt;(width, height);<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel for</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; height; y++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; width; x++) &#123;<br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Joint bilateral filter</span><br>            <span class="hljs-comment">// filteredImage(x, y) = frameInfo.m_beauty(x, y);</span><br><br>            <span class="hljs-keyword">auto</span> center_postion = frameInfo.<span class="hljs-built_in">m_position</span>(x, y);<br>            <span class="hljs-keyword">auto</span> center_normal = frameInfo.<span class="hljs-built_in">m_normal</span>(x, y);<br>            <span class="hljs-keyword">auto</span> center_color = frameInfo.<span class="hljs-built_in">m_beauty</span>(x, y);<br><br>            Float3 final_color;<br>            <span class="hljs-keyword">auto</span> total_weight = <span class="hljs-number">.0</span>f;<br><br>            <span class="hljs-type">int</span> passes = <span class="hljs-number">5</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> pass = <span class="hljs-number">0</span>; pass &lt; passes; pass++) &#123;<br><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> filterX = <span class="hljs-number">-2</span>; filterX &lt;= <span class="hljs-number">2</span>; filterX++) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> filterY = <span class="hljs-number">-2</span>; filterY &lt;= <span class="hljs-number">2</span>; filterY++) &#123;<br><br>                        <span class="hljs-type">int</span> m = x + std::<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, pass) * filterX;<br>                        <span class="hljs-type">int</span> n = y + std::<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, pass) * filterY;<br><br>                        <span class="hljs-keyword">auto</span> postion = frameInfo.<span class="hljs-built_in">m_position</span>(m, n);<br>                        <span class="hljs-keyword">auto</span> normal = frameInfo.<span class="hljs-built_in">m_normal</span>(m, n);<br>                        <span class="hljs-keyword">auto</span> color = frameInfo.<span class="hljs-built_in">m_beauty</span>(m, n);<br><br>                        <span class="hljs-keyword">auto</span> d_position = <span class="hljs-built_in">SqrDistance</span>(center_postion, postion) /<br>                                          (<span class="hljs-number">2.0f</span> * m_sigmaCoord * m_sigmaCoord);<br>                        <span class="hljs-keyword">auto</span> d_color = <span class="hljs-built_in">SqrDistance</span>(center_color, color) /<br>                                       (<span class="hljs-number">2.0f</span> * m_sigmaColor * m_sigmaColor);<br>                        <span class="hljs-keyword">auto</span> d_normal = <span class="hljs-built_in">SafeAcos</span>(<span class="hljs-built_in">Dot</span>(center_normal, normal));<br>                        d_normal *= d_normal;<br>                        d_normal /= (<span class="hljs-number">2.0f</span> * m_sigmaNormal * m_sigmaNormal);<br><br>                        <span class="hljs-type">float</span> d_plane = <span class="hljs-number">.0</span>f;<br>                        <span class="hljs-keyword">if</span> (d_position &gt; <span class="hljs-number">0.f</span>) &#123;<br>                            d_plane = <span class="hljs-built_in">Dot</span>(center_normal, <span class="hljs-built_in">Normalize</span>(postion - center_postion));<br>                        &#125;<br>                        d_plane *= d_plane;<br>                        d_plane /= (<span class="hljs-number">2.0f</span> * m_sigmaPlane * m_sigmaPlane);<br><br>                        <span class="hljs-type">float</span> weight =<br>                            std::<span class="hljs-built_in">exp</span>(-d_plane - d_position - d_color - d_normal);<br>                        total_weight += weight;<br>                        final_color += color * weight;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (total_weight == <span class="hljs-number">0</span>)<br>                <span class="hljs-built_in">filteredImage</span>(x, y) = center_color;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-built_in">filteredImage</span>(x, y) = final_color / total_weight;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> filteredImage;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>用该方法<code>filter</code>的效果图：<br />此时的<code>sigmaColor</code>为<code>0.6f</code><br /><img src="/img/00019/box-JBF-atrous.gif" alt="20" /><br />而<code>Pink Room</code>的<code>sigmaColor</code>需要调为<code>10.0f</code>，否则完全不能看。<br /><img src="/img/00019/pinkroom-JBF-atrous.gif" alt="21" /></p><h1 id="实现-svgf">实现 SVGF</h1><h2id="论文地址以及论文提供的源码地址">论文地址以及论文提供的源码地址</h2><p><code>Paper</code> : <ahref="https://research.nvidia.com/sites/default/files/pubs/2017-07_Spatiotemporal-Variance-Guided-Filtering%3A//svgf_preprint.pdf">Spatiotemporal-Variance-Guided-Filtering</a><br /><code>Source Code</code> : <ahref="https://github.com/NVIDIAGameWorks/Falcor/tree/master/Source/RenderPasses/SVGFPass">Falcor</a><br />本文部分代码以及图片均来源于此。</p><h2 id="算法概述">算法概述</h2><p><code>SVGF</code>资料不多，我引用一下论文中的图片来讲解：<br /><img src="/img/00019/image-8.png" alt="22" /><br />首先从路径追踪得到直接光和间接光每个像素的颜色，然后通过除以像素上的纹理信息（DemodulateAlbedo）得到像素的<code>Irradiance</code>（辐照度）：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">float3 <span class="hljs-title">demodulate</span><span class="hljs-params">(float3 c, float3 albedo)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> c / <span class="hljs-built_in">max</span>(albedo, <span class="hljs-built_in">float3</span>(<span class="hljs-number">0.001</span>, <span class="hljs-number">0.001</span>, <span class="hljs-number">0.001</span>));<br>&#125;<br><br>float3 illumination = <span class="hljs-built_in">demodulate</span>(gColor[ipos].rgb - gEmission[ipos].rgb, gAlbedo[ipos].rgb);<br></code></pre></td></tr></table></figure>接着对分别对直接光照和间接光照的<code>Irradiance</code>信息进行时间和空间上的混合<code>Filter</code>来重建因为样本极度稀疏所丢失的信息（ReconstructionFilter）。对<code>Irradiance</code>进行<code>Filter</code>之后，再把纹理信息叠加回来（ModulateAlbedo）：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">float4 <span class="hljs-title">main</span><span class="hljs-params">(FullScreenPassVsOut vsOut)</span> : SV_TARGET0</span><br><span class="hljs-function">&#123;</span><br>    <span class="hljs-type">const</span> int2 ipos = <span class="hljs-built_in">int2</span>(vsOut.posH.xy);<br><br>    <span class="hljs-keyword">return</span> gAlbedo[ipos] * gIllumination[ipos] + gEmission[ipos];<br>&#125;<br></code></pre></td></tr></table></figure>这样做的好处是，纹理的细节并不会因为<code>Filter</code>的强度过于大而丢失掉。在<code>Pipeline</code>的最后，采用现在引擎里非常流行的<code>Temporal AA</code>，更进一步的消除画面上残留的抖动，保证结果序列帧间的稳定。</p><p>由于作业5，提供的<code>EXR文件</code>中只包含了直接光和间接光结合在一起的完整结果，我在进行<code>Reconstruction Filter</code>过程中也是直接对该结果进行的<code>Filter</code>，所以画面有些地方会糊掉会很正常。</p><p>至于<code>Tone Mapping</code>和<code>TAA</code>我均未实现，我们的重点是<code>Reconstruction Filter</code>。</p><h2 id="reconstruction-filter">Reconstruction Filter</h2><p><img src="/img/00019/image-9.png" alt="23" /><br />重建执行三个主要步骤：在时间上累积我们的<code>1 spp</code>路径跟踪输入以提高有效采样率，使用这些时间上增强的颜色样本来估计局部亮度方差，以及使用这些方差估计来驱动分层的<code>“a-trous小波滤波器”</code>。</p><h3 id="temporal-filtering">Temporal Filtering</h3><p><code>Temporal Filter</code>和上文提到的“两帧间的累积”很相似，公式如下：<br /><span class="math display">\[C_{i} = \alpha C_{i} + (1-\alpha)C_{i-1}\]</span>为了尽可能多的囊括历史帧里的样本信息，<code>Temporal Filter</code>并不像<code>JBF</code>那样通过<code>Color Clamping</code>来防止<code>Ghosting</code>这种问题。所以在做<code>Sample Reprojection</code>的时候需要检查范围，深度，法线，模型索引等，去尽可能的丢弃无效的历史样本:<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (loc.x &lt; <span class="hljs-number">0</span> || loc.x &gt;= width || loc.y &lt; <span class="hljs-number">0</span> || loc.y &gt;= height)<br>    <span class="hljs-comment">//丢弃</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Denoiser_SVGF::isReprjValid</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">float</span> depth,<span class="hljs-type">const</span> <span class="hljs-type">float</span> preDepth,<span class="hljs-type">const</span> <span class="hljs-type">float</span> fwidthZ,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> Float3 normal, <span class="hljs-type">const</span> Float3 preNormal,<span class="hljs-type">const</span> <span class="hljs-type">float</span> fwidthNormal,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">int</span> meshId,<span class="hljs-type">const</span> <span class="hljs-type">int</span> preMeshId</span></span><br><span class="hljs-params"><span class="hljs-function">)</span> </span>&#123;<br>    <span class="hljs-comment">// check if deviation of depths is acceptable</span><br>    <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">fabs</span>(depth - preDepth) / (fwidthZ + <span class="hljs-number">1e-2</span>) &gt; <span class="hljs-number">10.0f</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// check normals for compatibility</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Distance</span>(normal, preNormal) / (fwidthNormal + <span class="hljs-number">1e-2</span>) &gt; <span class="hljs-number">16.0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// Since the grayscale is the result of direct path-tracing, there is a mutual contribution that can occur without meshid.</span><br>    <span class="hljs-comment">//To mitigate this, add meshid, which can cause other problems such as artifacts.</span><br>    <span class="hljs-keyword">if</span> (meshId != preMeshId)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 代码中的<code>fwidthZ，fwidthNormal</code>为深度或法线<ahref="https://developer.download.nvidia.com/cg/fwidth.html">在x，y方向上的偏导和</a>。其计算方法如下：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> Float3 normal = frameInfo.<span class="hljs-built_in">m_normal</span>(x, y);<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> ddxN = <span class="hljs-built_in">Distance</span>(frameInfo.<span class="hljs-built_in">m_normal</span>(x + <span class="hljs-number">1</span>, y), normal);<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> ddyN = <span class="hljs-built_in">Distance</span>(frameInfo.<span class="hljs-built_in">m_normal</span>(x, y + <span class="hljs-number">1</span>), normal);<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> fwidthNormal = ddxN + ddyN;<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> depth = frameInfo.<span class="hljs-built_in">m_depth</span>(x, y);<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> ddxZ = std::<span class="hljs-built_in">fabs</span>(frameInfo.<span class="hljs-built_in">m_depth</span>(x + <span class="hljs-number">1</span>, y) - depth);<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> ddyZ = std::<span class="hljs-built_in">fabs</span>(frameInfo.<span class="hljs-built_in">m_depth</span>(x, y + <span class="hljs-number">1</span>) - depth);<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> fwidthZ = ddxZ + ddyZ;<br></code></pre></td></tr></table></figure> <code>Temporal Filter</code>公式中的<spanclass="math inline">\(\alpha\)</span>是根据寻找历史样本的成功次数来定的，最大为<code>1</code>，最小自定：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// this adjusts the alpha for the case where insufficient history is available.</span><br><span class="hljs-comment">// It boosts the temporal accumulation to give the samples equal weights in the beginning.</span><br><span class="hljs-type">const</span> <span class="hljs-type">float</span> alpha = success ? std::<span class="hljs-built_in">fmax</span>(m_Alpha, <span class="hljs-number">1.0</span> / historyLength) : <span class="hljs-number">1.0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> alphaMoments = success ? std::<span class="hljs-built_in">fmax</span>(m_MomentsAlpha, <span class="hljs-number">1.0</span> / historyLength) : <span class="hljs-number">1.0</span>;<br><br><span class="hljs-comment">// compute first two moments of luminance</span><br>Float3 moments;<br>moments.x = <span class="hljs-built_in">Luminance</span>(illumination);<br>moments.y = moments.x * moments.x;<br><br><span class="hljs-comment">// temporal integration of the moments</span><br>moments = <span class="hljs-built_in">Lerp</span>(prevMoments, moments, alphaMoments);<br><br><span class="hljs-type">float</span> variance = std::<span class="hljs-built_in">fmax</span>(<span class="hljs-number">0.f</span>, moments.y - moments.x * moments.x);<br><span class="hljs-comment">// temporal integration of illumination</span><br><span class="hljs-built_in">m_accColor</span>(x, y) = <span class="hljs-built_in">Lerp</span>(prevIllumination, illumination, alpha);<br><span class="hljs-built_in">m_curFrameVariance</span>(x,y) = variance;<br><span class="hljs-built_in">m_moments</span>(x, y) = moments;<br><span class="hljs-built_in">m_tmpHisLength</span>(x,y) = historyLength;<br></code></pre></td></tr></table></figure>是的，不仅仅是颜色需要<code>Temporal Filter</code>，<code>Moments</code>也需要，方差的计算依赖它，通过在时间上积累<code>Luminance</code>的<code>First</code>和<code>Second Moment</code>，<spanclass="math inline">\(\mu^{\prime}_{1i}\)</span>和<spanclass="math inline">\(\mu^{\prime}_{2i}\)</span>，方差的计算公式如下:<br /><span class="math display">\[\sigma^{\prime 2}_{i}=\mu^{\prime}_{2i}-\mu^{\prime 2}_{1i}\]</span><code>Moments Temporal Filter</code>对应上图中紫色块的处理过程。</p><h3 id="variance-estimation">Variance Estimation</h3><p>由于摄像机运动、影视效果和视口变换出界都会导致<code>disocclusion事件</code>，从而影响方差估计的质量。所以我们要对出现<code>disocclusion事件</code>的前<code>4</code>帧进行空间上的<code>7 * 7</code>双边滤波，该滤波核权重由深度，法线，灰度值决定。在此期间也对<code>illumination</code>做一次<code>Filter</code>，两者是同时进行，几乎没有额外开销。代码实现如下：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Denoiser_SVGF::VarianceEstimation</span><span class="hljs-params">(<span class="hljs-type">const</span> FrameInfo &amp;frameInfo)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> height = frameInfo.m_beauty.m_height;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> width = frameInfo.m_beauty.m_width;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> radius = <span class="hljs-number">3</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel for</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; height; y++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; width; x++) &#123;<br><br>            <span class="hljs-type">const</span> Float3 ipos = <span class="hljs-built_in">Float3</span>(x, y, <span class="hljs-number">0</span>);<br>            <span class="hljs-type">float</span> h = <span class="hljs-built_in">m_historyLength</span>(ipos.x, ipos.y);<br>            <span class="hljs-keyword">if</span> (h &lt; <span class="hljs-number">4.0</span>)&#123;<span class="hljs-comment">// not enough temporal history available</span><br>                <span class="hljs-type">float</span> sumWIllumination = <span class="hljs-number">0.0</span>;<br>                Float3 sumIllumination = <span class="hljs-built_in">Float3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>                Float3 sumMoments = <span class="hljs-built_in">Float3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>                <span class="hljs-type">const</span> Float3 illuminationCenter = <span class="hljs-built_in">m_accColor</span>(ipos.x, ipos.y);<br>                <span class="hljs-type">const</span> <span class="hljs-type">float</span> lIlluminationCenter = <span class="hljs-built_in">Luminance</span>(illuminationCenter);<br><br>                <span class="hljs-type">const</span> Float3 nCenter = frameInfo.<span class="hljs-built_in">m_normal</span>(ipos.x, ipos.y);<br>                <span class="hljs-type">const</span> <span class="hljs-type">float</span> zCenter = frameInfo.<span class="hljs-built_in">m_depth</span>(ipos.x, ipos.y);<br>                <span class="hljs-comment">// depth-gradient estimation from screen-space derivatives</span><br>                <span class="hljs-type">float</span> dgrad_x = std::<span class="hljs-built_in">fmax</span>(<span class="hljs-number">1e-8</span>, std::<span class="hljs-built_in">fabs</span>(frameInfo.<span class="hljs-built_in">m_depth</span>(ipos.x + <span class="hljs-number">1</span>, ipos.y) - zCenter)) * <span class="hljs-number">3.0</span>;<br>                <span class="hljs-type">float</span> dgrad_y = std::<span class="hljs-built_in">fmax</span>(<span class="hljs-number">1e-8</span>, std::<span class="hljs-built_in">fabs</span>(frameInfo.<span class="hljs-built_in">m_depth</span>(ipos.x, ipos.y + <span class="hljs-number">1</span>) - zCenter)) * <span class="hljs-number">3.0</span>;<br>                <span class="hljs-type">float</span> maxDgrad = std::<span class="hljs-built_in">fmax</span>(dgrad_x, dgrad_y);<br><br>                <span class="hljs-comment">// compute first and second moment spatially. This code also applies cross-bilateral</span><br>                <span class="hljs-comment">// filtering on the input illumination.</span><br><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> yy = -radius; yy &lt;= radius; yy++) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> xx = -radius; xx &lt;= radius; xx++) &#123;<br>                        <span class="hljs-type">const</span> Float3 p = ipos + <span class="hljs-built_in">Float3</span>(xx, yy,<span class="hljs-number">0</span>);<br>                        <span class="hljs-type">bool</span> inside = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">if</span> (p.x &gt;= <span class="hljs-number">0</span> &amp;&amp; p.y &gt;= <span class="hljs-number">0</span> &amp;&amp; p.x &lt; width &amp;&amp; p.y &lt; height)<br>                            inside = <span class="hljs-literal">true</span>;<br><br>                        <span class="hljs-keyword">if</span> (inside) &#123;<br>                            <span class="hljs-type">const</span> Float3 illuminationP = <span class="hljs-built_in">m_accColor</span>(p.x, p.y);<br>                            <span class="hljs-type">const</span> Float3 momentsP = <span class="hljs-built_in">m_moments</span>(p.x, p.y);<br>                            <span class="hljs-type">const</span> <span class="hljs-type">float</span> lIlluminationP = <span class="hljs-built_in">Luminance</span>(illuminationP);<br>                            <span class="hljs-type">const</span> <span class="hljs-type">float</span> zP = frameInfo.<span class="hljs-built_in">m_depth</span>(p.x, p.y);<br>                            <span class="hljs-type">const</span> Float3 nP = frameInfo.<span class="hljs-built_in">m_normal</span>(p.x,p.y);<br><br>                            <span class="hljs-comment">// calculate the normal, depth and luminance weights</span><br>                            <span class="hljs-type">float</span> nw = <span class="hljs-built_in">normalWeight</span>(nCenter, nP);<br>                            <span class="hljs-type">float</span> dw = <span class="hljs-built_in">depthWeight</span>(zCenter, zP, maxDgrad,xx, yy);<br>                            <span class="hljs-type">float</span> lw = <span class="hljs-built_in">luminanceWeight</span>(lIlluminationCenter,<br>                                                       lIlluminationP, <span class="hljs-number">1.0</span>);<br>                            <span class="hljs-type">float</span> w = nw * dw * lw;<br>                            sumWIllumination += w;<br>                            sumIllumination += illuminationP * w;<br>                            sumMoments += momentsP * w;<br>                        &#125;<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-comment">// Clamp sum to &gt;0 to avoid NaNs.</span><br>                sumWIllumination = std::<span class="hljs-built_in">fmax</span>(sumWIllumination, <span class="hljs-number">1e-6</span>f);<br>                sumIllumination /= sumWIllumination;<br>                sumMoments /= sumWIllumination;<br><br>                <span class="hljs-comment">// compute variance using the first and second moments</span><br>                <span class="hljs-type">float</span> variance = sumMoments.y - sumMoments.x * sumMoments.x;<br><br>                <span class="hljs-comment">// give the variance a boost for the first frames</span><br>                <span class="hljs-keyword">if</span> (h != <span class="hljs-number">0</span>)<br>                    variance *= <span class="hljs-number">4.0</span> / h;<br><br>                <span class="hljs-built_in">m_tmpColor</span>(ipos.x, ipos.y) = sumIllumination;<br>                <span class="hljs-built_in">m_curFrameVariance</span>(ipos.x, ipos.y) = variance;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// do nothing</span><br>                <span class="hljs-built_in">m_tmpColor</span>(ipos.x, ipos.y) = <span class="hljs-built_in">m_accColor</span>(ipos.x, ipos.y);<br>            &#125;<br>        &#125;<br>    &#125;<br>    std::<span class="hljs-built_in">swap</span>(m_tmpColor, m_accColor);<br>&#125;<br></code></pre></td></tr></table></figure>本质上来说我们只对出现了<code>disocclusion事件</code>的前几帧进行空间上的方差估计，直到时间累积收集了足够的数据来进行稳定的估计。权重计算函数在下一节讲。</p><h3 id="edge-stopping-functions">Edge-Stopping Functions</h3><h4 id="depth">Depth</h4><p>真实的场景在几何尺度上有很大的变化，尤其是在开阔的景观中。使得全局边缘停止函数不受控制。因此，我们对表面深度设定了一个局部线性模型，并且测量其表面深度的偏差。我们使用剪切空间深度（只要是线性深度即可，本文使用的深度信息应该属于viewspace）的屏幕空间偏导数来估计局部深度模型。该权重函数为：<br /><span class="math display">\[w_{z}=exp(-\dfrac{\left| z(p)-z(q) \right|}{\sigma_{z} \left| \nablaz(p) \cdot (p-q) \right|+\epsilon})\]</span></p><p>根据经验<spanclass="math inline">\(\sigma_{z}\)</span>为<code>1.0</code>可以得到比较好的效果，用来控制深度的影响是大还是小。<span class="math inline">\(\nablaz\)</span>是屏幕坐标下深度的梯度，<spanclass="math inline">\(\epsilon\)</span>是防止除以零。代码实现如下：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">Denoiser_SVGF::depthWeight</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">float</span> center_depth, <span class="hljs-type">const</span> <span class="hljs-type">float</span> depth,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">const</span> <span class="hljs-type">float</span> dgrad, </span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">const</span> <span class="hljs-type">float</span> offset_x, <span class="hljs-type">const</span> <span class="hljs-type">float</span> offset_y)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span> eps = <span class="hljs-number">1e-8</span>;<br>    Float3 offset&#123;offset_x, offset_y,<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">exp</span>( (-std::<span class="hljs-built_in">fabs</span>(center_depth - depth)) / (std::<span class="hljs-built_in">fabs</span>( m_phiDepth * dgrad * <span class="hljs-built_in">Length</span>(offset)+ eps)) );<br>&#125;<br></code></pre></td></tr></table></figure> 本应该是<span class="math inline">\(\nabla z(p) \cdot(p-q)\)</span>即梯度点乘偏移，梯度和偏移都是二维向量。但是这里的写法是，取梯度中较大的一个偏导数作为一维梯度值然后乘上偏移向量的长度。其结果相差不大，至于论文源码为什么要这么算目前不得而知，两种算法得到的结果我都看了一下几乎没区别，读者有兴趣可以去试下。</p><h4 id="normal">Normal</h4><p>法线权重比较简单，法线夹角小权重大，反之权重小。公式如下：<br /><span class="math display">\[w_{n}=max(0,n(p)\cdot n(q))^{\sigma_{n}}\]</span> <spanclass="math inline">\(\sigma_{n}\)</span>按经验来说为<code>128</code>效果比较好，用来控制法线的权重。<br />代码实现如下：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">Denoiser_SVGF::normalWeight</span><span class="hljs-params">(<span class="hljs-type">const</span> Float3 &amp;center_normal, <span class="hljs-type">const</span> Float3 &amp;normal)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">pow</span>(std::<span class="hljs-built_in">fmax</span>(<span class="hljs-number">0.0</span>, <span class="hljs-built_in">Dot</span>(center_normal, normal)), m_phiNormal);<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="luminance">Luminance</h4><p>亮度边缘停止函数的一个关键方面是它能够通过其局部标准差重新归一化亮度，来自动适应所有亮度。但是，在低样本数下操作会在我们对方差和标准差的估计中引入不稳定性；这可能会引入走样现象。为了避免这些问题，我们使用<code>3 * 3</code>高斯核对方差图像进行预滤波，这显著提高了重建质量。亮度边缘停止函数变为：<br /><span class="math display">\[w_{l}=exp(-\dfrac{|l_{i}(p)-l_{i}(q)|}{\sigma_{l}\sqrt{g_{3\times3}(Var(l_{i}(p)))}+\epsilon})\]</span> 根据经验<spanclass="math inline">\(\sigma_{l}\)</span>为<code>4</code>效果比较好，用于控制亮度的影响。<br />由于亮度方差往往会随着后续迭代而减少，因此<spanclass="math inline">\(w_{l}\)</span>的影响会随着每次迭代而增加，从而防止过度模糊。<br />需要注意的是，这个高斯预滤波器仅用于驱动亮度边缘停止函数，而不用于传播到小波变换下的一次迭代的方差中。<br />代码实现如下：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">Denoiser_SVGF::computeVarianceCenter</span><span class="hljs-params">(<span class="hljs-type">const</span> Float3&amp; ipos,<span class="hljs-type">const</span> <span class="hljs-type">int</span> width,<span class="hljs-type">const</span> <span class="hljs-type">int</span> height)</span> </span>&#123;<br>    <span class="hljs-type">float</span> sum = <span class="hljs-number">0.f</span>;<br>    <br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span> kernel[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">1.0</span> / <span class="hljs-number">4.0</span>, <span class="hljs-number">1.0</span> / <span class="hljs-number">8.0</span>&#125;, &#123;<span class="hljs-number">1.0</span> / <span class="hljs-number">8.0</span>, <span class="hljs-number">1.0</span> / <span class="hljs-number">16.0</span>&#125;&#125;;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> radius = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> yy = -radius; yy &lt;= radius; yy++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> xx = -radius; xx &lt;= radius; xx++) &#123;<br>            Float3 p = ipos + <span class="hljs-built_in">Float3</span>(xx, yy,<span class="hljs-number">0</span>);<br>            p.x = std::<span class="hljs-built_in">fmin</span>(std::<span class="hljs-built_in">fmax</span>(p.x, <span class="hljs-number">0.0</span>), width - <span class="hljs-number">1.0</span>);<br>            p.y = std::<span class="hljs-built_in">fmin</span>(std::<span class="hljs-built_in">fmax</span>(p.y, <span class="hljs-number">0.0</span>), height - <span class="hljs-number">1.0</span>);<br>            <span class="hljs-type">const</span> <span class="hljs-type">float</span> k = kernel[std::<span class="hljs-built_in">abs</span>(xx)][std::<span class="hljs-built_in">abs</span>(yy)];<br>            sum += <span class="hljs-built_in">m_curFrameVariance</span>(p.x,p.y) * k;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">float</span> variance = <span class="hljs-built_in">computeVarianceCenter</span>(ipos,width,height);<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">Denoiser_SVGF::luminanceWeight</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">float</span> center_lum, <span class="hljs-type">const</span> <span class="hljs-type">float</span> lum,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">const</span> <span class="hljs-type">float</span> variance</span></span><br><span class="hljs-params"><span class="hljs-function">)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span> eps = <span class="hljs-number">1e-10</span>;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">exp</span>( (-std::<span class="hljs-built_in">fabs</span>(center_lum - lum)) /<br>               (m_phiColor * std::<span class="hljs-built_in">sqrt</span>(std::<span class="hljs-built_in">fmax</span>(<span class="hljs-number">0.0</span>, variance) + eps)));<br>&#125;<br></code></pre></td></tr></table></figure> <code>kernel</code>是 <spanclass="math inline">\(\sigma\)</span>为0.8的高斯滤波核，上文有提到。</p><h3 id="edge-avoiding-a-trous-wavelet-transform">Edge-avoiding A-trouswavelet transform</h3><p><code>Reconstruction Filter</code>的最后最重要的一步，<code>Reproject</code>（TemporalFiltering）以及<code>Variance Estimation</code>都是为了这一步做铺垫。上文说到光栅化的<code>G-buffer</code>不包含随机噪声，使我们能够使用<code>G-buffer</code>来定义边缘停止函数，这些函数可以用来鉴别像素是否在同一表面，从而进行相互贡献。该论文的实现也使用了<code>A-trous wavelet</code>方法（上文有提及），权重函数<spanclass="math inline">\(w(p,q)\)</span>使用的是一个<code>5 * 5</code>的联合双边滤波核。公式如下：<br /><span class="math display">\[\hat{c}_{i+1}(p)=\dfrac{\sum_{q\in\Omega}h(q)\cdotw(p,q)\cdot\hat{c}_{i}(q)}{\sum_{q\in\Omega}h(q)\cdot w(p,q)}\]</span></p><p><spanclass="math inline">\(h(q)\)</span>是一个类高斯滤波核，论文和本此实现使用的<spanclass="math inline">\(h(q)\)</span>权重系数不太一样不过没关系，都是随距离衰减的函数就行。<spanclass="math inline">\(\Omega\)</span>是滤波器中被收集的像素集合（就是每一趟中踩到的像素点的集合）<br /><span class="math inline">\(\hat{c}_{i+1}(p)\)</span>和 <spanclass="math inline">\(\hat{c}_{i}(q)\)</span>则是滤波后的输出颜色以及p点附近q点的像素颜色。</p><p>该论文新颖的权重函数 <spanclass="math inline">\(w(p,q)\)</span>使用的是深度、世界空间法线以及<code>Filter</code>后输入的<code>Luminance</code>，公式如下：<br /><span class="math display">\[w_{i}(p,q)=w_{z}\cdot w_{n}\cdot w_{l}\]</span> 这几个函数在上一节我已经详细解释了。</p><p>在应用<code>A-trous wavelet</code>过程中，我们会基于亮度方差的局部估计来调整亮度边缘停止函数。然后根据<code>A-trous wavelet</code>来<code>Filter</code>时间上累计的颜色，并假设我们采样到的方差样本是不相关的（相互独立），则我们向下一次<code>A-trous wavelet</code>传递方差的公式为：<br /><span class="math display">\[Var(\hat{c}_{i+1}(p))=\dfrac{\sum_{q\in\Omega}h(q)^{2}\cdotw(p,q)^{2}\cdot Var(\hat{c}_{i}(q))}{(\sum_{q\in\Omega}h(q)\cdotw(p,q))^{2}}\]</span>我们会使用这个结果来控制下一次<code>A-trous wavelet</code>的边缘停止函数。代码实现如下：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Denoiser_SVGF::ATrousWaveletFilter</span><span class="hljs-params">(<span class="hljs-type">const</span> FrameInfo &amp;frameInfo,<span class="hljs-type">const</span> <span class="hljs-type">int</span> stepSize)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> height = frameInfo.m_beauty.m_height;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> width = frameInfo.m_beauty.m_width;<br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span> kernelWeights[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span> / <span class="hljs-number">3.0</span>, <span class="hljs-number">1.0</span> / <span class="hljs-number">6.0</span>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel for</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; height; y++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; width; x++) &#123;<br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> SVGF</span><br>            <span class="hljs-type">const</span> Float3 ipos = <span class="hljs-built_in">Float3</span>(x, y, <span class="hljs-number">0</span>);<br>            <span class="hljs-type">const</span> Float3 illuminationCenter = <span class="hljs-built_in">m_accColor</span>(ipos.x, ipos.y);<br>            <span class="hljs-type">const</span> <span class="hljs-type">float</span> lIlluminationCenter = <span class="hljs-built_in">Luminance</span>(illuminationCenter);<br><br>            <span class="hljs-comment">//variance,filtered using 3 * 3 gaussin blur</span><br>            <span class="hljs-type">const</span> <span class="hljs-type">float</span> var = <span class="hljs-built_in">computeVarianceCenter</span>(ipos,width,height);<br><br>            <span class="hljs-type">const</span> <span class="hljs-type">float</span> zCenter = frameInfo.<span class="hljs-built_in">m_depth</span>(ipos.x, ipos.y);<br>            <span class="hljs-type">const</span> Float3 nCenter = frameInfo.<span class="hljs-built_in">m_normal</span>(ipos.x, ipos.y);<br><br>            <span class="hljs-type">float</span> dgrad_x = std::<span class="hljs-built_in">fmax</span>(<span class="hljs-number">1e-8</span>, std::<span class="hljs-built_in">fabs</span>(frameInfo.<span class="hljs-built_in">m_depth</span>(ipos.x + <span class="hljs-number">1</span>, ipos.y) - zCenter)) * stepSize;<br>            <span class="hljs-type">float</span> dgrad_y = std::<span class="hljs-built_in">fmax</span>(<span class="hljs-number">1e-8</span>, std::<span class="hljs-built_in">fabs</span>(frameInfo.<span class="hljs-built_in">m_depth</span>(ipos.x, ipos.y + <span class="hljs-number">1</span>) - zCenter)) * stepSize;<br>            <br>            <span class="hljs-type">float</span> maxDgrad = std::<span class="hljs-built_in">fmax</span>(dgrad_x, dgrad_y);<br><br>            <span class="hljs-comment">//explicitly store/accumulate center pixel with weight 1 to prevent issues</span><br>            <span class="hljs-comment">//with the edge-stopping functions</span><br>            <span class="hljs-type">float</span> sumWIllumination = <span class="hljs-number">1.0</span>;<br>            <span class="hljs-type">float</span> sumVariance = <span class="hljs-built_in">m_curFrameVariance</span>(ipos.x, ipos.y);<br>            Float3 sumIllumination = illuminationCenter;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> yy = <span class="hljs-number">-2</span>; yy &lt;= <span class="hljs-number">2</span>; yy++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> xx = <span class="hljs-number">-2</span>; xx &lt;= <span class="hljs-number">2</span>; xx++) &#123;<br>                    <span class="hljs-type">const</span> Float3 p = ipos + <span class="hljs-built_in">Float3</span>(xx, yy,<span class="hljs-number">0</span>) * stepSize;<br>                    <span class="hljs-type">bool</span> inside = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">if</span> (p.x &gt;= <span class="hljs-number">0</span> &amp;&amp; p.y &gt;= <span class="hljs-number">0</span> &amp;&amp; p.x &lt; width &amp;&amp; p.y &lt; height)<br>                        inside = <span class="hljs-literal">true</span>;<br><br>                    <span class="hljs-type">const</span> <span class="hljs-type">float</span> kernel = kernelWeights[std::<span class="hljs-built_in">abs</span>(xx)] * kernelWeights[std::<span class="hljs-built_in">abs</span>(yy)];<br><br>                    <span class="hljs-keyword">if</span> (inside &amp;&amp;<br>                        (xx != <span class="hljs-number">0</span> ||<br>                         yy != <span class="hljs-number">0</span>)) <span class="hljs-comment">// skip center pixel, it is already accumulated</span><br>                    &#123;<br>                        <span class="hljs-type">const</span> Float3 illuminationP = <span class="hljs-built_in">m_accColor</span>(p.x,p.y);<br>                        <span class="hljs-type">const</span> <span class="hljs-type">float</span> lIlluminationP = <span class="hljs-built_in">Luminance</span>(illuminationP);<br>                        <span class="hljs-type">const</span> <span class="hljs-type">float</span> zP = frameInfo.<span class="hljs-built_in">m_depth</span>(p.x,p.y);<br>                        <span class="hljs-type">const</span> Float3 nP = frameInfo.<span class="hljs-built_in">m_normal</span>(p.x,p.y);<br>                        <span class="hljs-type">const</span> <span class="hljs-type">float</span> varP = <span class="hljs-built_in">m_curFrameVariance</span>(p.x,p.y);<br><br>                        <span class="hljs-comment">// calculate the normal, depth and luminance weights</span><br>                        <span class="hljs-type">float</span> nw = <span class="hljs-built_in">normalWeight</span>(nCenter, nP);<br>                        <span class="hljs-type">float</span> dw = <span class="hljs-built_in">depthWeight</span>(zCenter, zP, maxDgrad, xx, yy);<br>                        <span class="hljs-type">float</span> lw = <span class="hljs-built_in">luminanceWeight</span>(lIlluminationCenter, lIlluminationP, var);<br><br>                        <span class="hljs-type">const</span> <span class="hljs-type">float</span> wIllumination = nw * dw * lw * kernel;<br><br>                        <span class="hljs-comment">// alpha channel contains the variance, therefore the weights need</span><br>                        <span class="hljs-comment">// to be squared, see paper for the formula(4.3 (1) (2))</span><br>                        sumWIllumination += wIllumination;<br>                        sumIllumination += <span class="hljs-built_in">Float3</span>(wIllumination) * illuminationP;<br>                        sumVariance += wIllumination * wIllumination * varP;<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// renormalization is different for variance, check paper for the formula</span><br>            <span class="hljs-built_in">m_tmpColor</span>(ipos.x, ipos.y) = sumIllumination / sumWIllumination;<br>            <span class="hljs-built_in">m_tmpCurFrameVar</span>(ipos.x, ipos.y) = sumVariance / (sumWIllumination * sumWIllumination);<br>        &#125;<br>    &#125;<br>    std::<span class="hljs-built_in">swap</span>(m_tmpColor,m_accColor);<br>    std::<span class="hljs-built_in">swap</span>(m_tmpCurFrameVar,m_curFrameVariance);<br>&#125;<br></code></pre></td></tr></table></figure> <code>Step Size</code>为<spanclass="math inline">\(2^{i},i\in([0,4] \cap \mathbb{Z})\)</span></p><p>Cornell Box效果如下：<br /><img src="/img/00019/box-svgf.gif" alt="24" /><br />Pink Room效果如下:<br /><img src="/img/00019/pinkroom-svgf.gif" alt="25" /><br />这是降噪前的图片：<br /><img src="/img/00019/image-10.png" alt="26" /><br /><img src="/img/00019/image-11.png" alt="27" /></p>]]></content>
    
    
    <categories>
      
      <category>Games202</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Games202 Hw4 IBL and Kulla Conty</title>
    <link href="/2023/07/01/00018.%20Games202%20Hw4/"/>
    <url>/2023/07/01/00018.%20Games202%20Hw4/</url>
    
    <content type="html"><![CDATA[<h1 id="最终效果图">最终效果图</h1><p>每组下面一排球是没用<code>Kulla Conty</code>的对照组，所有球的金属度都为<code>1</code>,粗糙度最小<code>0.05</code>，最大<code>0.95</code>,可以明显看到对照组随着粗糙度增大，会越来越暗，而使用了<code>Kulla Conty</code>的实验组，亮度不会随着粗糙度的增加而衰减，为了使现象更明显这里吧<code>HDR tonemapping</code>功能禁用了！<img src="/img/00018/result.png" alt="0" /><br />下面是金材质的<code>Kulla-Conty Approximation</code>效果：<br /><img src="/img/00018/image-15.png" alt="1" /></p><h1 id="作业总览">作业总览</h1><ol type="1"><li>实现预计算<span class="math inline">\(E(\mu)\)</span></li><li>实现预计算<span class="math inline">\(E_{avg}\)</span></li><li>正确实现PBR材质</li><li>正确实现Kulla-Conty材质</li><li>提高1：实现重要性采样的预计算方法<br /></li><li>提高2：在预计算<spanclass="math inline">\(E(\mu)\)</span>时，使用<code>Split Sum</code>完成预计算工作</li></ol><p>个人扩展部分：<code>Image Based Lighting</code></p><h1 id="源码">源码</h1><p>暂未公开</p><h1 id="webgl代码框架的理解">Webgl代码框架的理解</h1><p>这部分代码主要解释我们需要的地方，太过于细节的地方本节内容不做解释，只去理解那些能帮助我实现想要效果的代码。</p><h2 id="模型加载">模型加载</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> pbrSphere1Transform = <span class="hljs-title function_">setTransform</span>(<span class="hljs-number">360</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">180</span>, <span class="hljs-number">180</span>, <span class="hljs-number">180</span>, <span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>, <span class="hljs-number">0</span>);<br><span class="hljs-title function_">loadGLTF</span>(renderer, <span class="hljs-string">&#x27;assets/ball/&#x27;</span>, <span class="hljs-string">&#x27;ball&#x27;</span>, <span class="hljs-string">&#x27;PBRMaterial&#x27;</span>, pbrSphere1Transform,irradianceMap,prefilterMap,pbrBrdfLutObj,metallic,<span class="hljs-number">0.95</span>);<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadGLTF</span>(<span class="hljs-params">renderer, path, name, objMaterial, transform,irradianceMap,prefilterMap,pbrBrdfLut, metallic=<span class="hljs-number">1.0</span>, roughness=<span class="hljs-number">0.2</span></span>)&#123;<br>    ...<br><span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">GLTFLoader</span>(manager)<br>.<span class="hljs-title function_">setPath</span>(path)<br>.<span class="hljs-title function_">load</span>(name + <span class="hljs-string">&#x27;.gltf&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">gltf</span>) &#123;<br>gltf.<span class="hljs-property">scene</span>.<span class="hljs-title function_">traverse</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">child</span>) &#123;<br><span class="hljs-keyword">if</span> (child.<span class="hljs-property">isMesh</span>) &#123;<br>                    ...<br><span class="hljs-keyword">let</span> colorMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Texture</span>(renderer.<span class="hljs-property">gl</span>);<br>...<br>                    <span class="hljs-comment">//gold : 0.94423,0.77611,0.37217</span><br>                    <span class="hljs-keyword">let</span> kd = [<span class="hljs-number">1.00</span>,<span class="hljs-number">1.00</span>, <span class="hljs-number">1.00</span>]; <span class="hljs-comment">//albedo</span><br>                    colorMap.<span class="hljs-title class_">CreateConstantTexture</span>(renderer.<span class="hljs-property">gl</span>, kd, <span class="hljs-literal">true</span>);<br><span class="hljs-keyword">let</span> material;<br><span class="hljs-keyword">switch</span> (objMaterial) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;KullaContyMaterial&#x27;</span>:<br>material = <span class="hljs-title function_">buildKullaContyMaterial</span>(colorMap,metallic,roughness,irradianceMap,prefilterMap,pbrBrdfLut,kullaContyBrdflut,kullaContyEavglut,<span class="hljs-string">&quot;./src/shaders/kullaContyShader/KullaContyVertex.glsl&quot;</span>, <span class="hljs-string">&quot;./src/shaders/kullaContyShader/KullaContyFragment.glsl&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;PBRMaterial&#x27;</span>:<br>material = <span class="hljs-title function_">buildPBRMaterial</span>(colorMap,metallic,roughness,irradianceMap,prefilterMap,pbrBrdfLut,<span class="hljs-string">&quot;./src/shaders/pbrShader/PBRVertex.glsl&quot;</span>, <span class="hljs-string">&quot;./src/shaders/pbrShader/PBRFragment.glsl&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>material.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br><span class="hljs-keyword">let</span> meshRender = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MeshRender</span>(renderer.<span class="hljs-property">gl</span>, mesh, data,objMaterial);<br>renderer.<span class="hljs-title function_">addMeshRender</span>(meshRender);<br>&#125;);<br>&#125;<br>&#125;);<br>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>模型加载主要就看这部分，打了省略的部分不需要去理解。<br /><code>colorMap</code>获取创建的纹理<code>ID</code>,<code>kD</code>是<code>albedo</code>，只为了观察能量损失和补充直接填<code>1.0</code>就行，<code>CreateConstantTexture</code>用<code>albedo</code>创建一张宽高为<code>1</code>的纹理。<br /><code>buildKullaContyMaterial</code>是一个异步函数，函数执行完成后就会进入回调部分<code>material.then((data))</code>,<code>data</code>才是函数的返回值。<br /><code>child.isMesh</code>会判断模型的子节点是否为<code>mesh</code>节点，经过<code>debug</code>发现，该<code>ball</code>模型有<code>4</code>个子节点，也就说会进入回调部分<code>material.then((data))</code>4次。</p><h2 id="shader编译">shader编译</h2><p>在理解框架<code>shader</code>编译之前需要把材质类型熟悉一下，以<code>PBRMaterial.js</code>为例:<br /><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Material</span> &#123;<br>    #flatten_uniforms;<br>    #flatten_attribs;<br>    #vsSrc;<br>    #fsSrc;<br>    <span class="hljs-comment">// Uniforms is a map, attribs is a Array</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">uniforms, attribs, vsSrc, fsSrc, frameBuffer</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">uniforms</span> = uniforms;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">attribs</span> = attribs;<br>        <span class="hljs-variable language_">this</span>.#vsSrc = vsSrc;<br>        <span class="hljs-variable language_">this</span>.#fsSrc = fsSrc;<br><br>        <span class="hljs-variable language_">this</span>.#flatten_uniforms = [<span class="hljs-string">&#x27;uViewMatrix&#x27;</span>,<span class="hljs-string">&#x27;uModelMatrix&#x27;</span>, <span class="hljs-string">&#x27;uProjectionMatrix&#x27;</span>, <span class="hljs-string">&#x27;uCameraPos&#x27;</span>, <span class="hljs-string">&#x27;uLightPos&#x27;</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> uniforms) &#123;<br>            <span class="hljs-variable language_">this</span>.#flatten_uniforms.<span class="hljs-title function_">push</span>(k);<br>        &#125;<br>        <span class="hljs-variable language_">this</span>.#flatten_attribs = attribs;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">frameBuffer</span> = frameBuffer;<br>    &#125;<br>    <span class="hljs-title function_">setMeshAttribs</span>(<span class="hljs-params">extraAttribs</span>) &#123;<br>    <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; extraAttribs.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-variable language_">this</span>.#flatten_attribs.<span class="hljs-title function_">push</span>(extraAttribs[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-title function_">compile</span>(<span class="hljs-params">gl</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Shader</span>(gl, <span class="hljs-variable language_">this</span>.#vsSrc, <span class="hljs-variable language_">this</span>.#fsSrc,<br>            &#123;<br>                <span class="hljs-attr">uniforms</span>: <span class="hljs-variable language_">this</span>.#flatten_uniforms,<br>                <span class="hljs-attr">attribs</span>: <span class="hljs-variable language_">this</span>.#flatten_attribs<br>            &#125;);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PBRMaterial</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Material</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">albedo, metallic,roughness,irradianceMap,prefilterMap,pbrBrdfLut, vertexShader, fragmentShader</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(&#123;<br>            <span class="hljs-string">&#x27;uAlbedoMap&#x27;</span>:          &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;texture&#x27;</span>, <span class="hljs-attr">value</span>: albedo &#125;,<br>            <span class="hljs-string">&#x27;uMetallic&#x27;</span>:        &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;1f&#x27;</span>, <span class="hljs-attr">value</span>: metallic &#125;,<br>            ...<br>            <span class="hljs-comment">// &#x27;uLightPos[4]&#x27;: &#123; type: &#x27;3fv&#x27;, value: null &#125;,</span><br>            <span class="hljs-comment">// &#x27;uLightColors[4]&#x27;: &#123; type: &#x27;3fv&#x27;, value: null &#125;,</span><br>        &#125;, [], vertexShader, fragmentShader);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">buildPBRMaterial</span>(<span class="hljs-params">albedo, metallic,roughness,irradianceMap,prefilterMap,pbrBrdfLut, vertexPath, fragmentPath</span>) &#123;<br>    <span class="hljs-keyword">let</span> vertexShader = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getShaderString</span>(vertexPath);<br>    <span class="hljs-keyword">let</span> fragmentShader = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getShaderString</span>(fragmentPath);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PBRMaterial</span>(albedo, metallic,roughness,irradianceMap,prefilterMap,pbrBrdfLut, vertexShader, fragmentShader);<br>&#125;<br></code></pre></td></tr></table></figure>各种材质类都是继承自父类<code>Material</code>,子类部分只负责填写对应<code>shader</code>需要<code>uniform</code>的变量，子类用<code>super</code>关键字来对父类进行初始化，随后填写<code>uniform</code>数据全部被保存入父类私有变量<code>#flatten_uniforms</code>中，父类还包含了一些常用<code>uniform</code>变量<code>'uViewMatrix','uModelMatrix'...</code>,这些名字在不同的<code>vertex</code>和<code>fragment</code>中名字都是统一的,可自行修改，数组<code>uniform</code>变量需要自己手动设置，框架没有对这类变量进行解析。<br /><code>this.#vsSrc</code>和<code>this.#fsSrc</code>保存的<code>shader</code>文件路径，<code>#this.attribs</code>保存的<code>vertexShader</code>的<code>location</code>变量名字，比如:<br /><code>layout (location = 0) in vec3 aVertexPosition;</code>中的<code>aVertexPosition</code>，所以在<code>vertexShader</code>中不要更改它的名字，名字都是来源于<code>mesh</code>节点，在<code>MeshRender.js</code>文件中会判断<code>mesh</code>节点是否包含该属性名字，有的话就调用该材质的<code>setMeshAttribs</code>函数将名字存入<code>#this.attribs</code>。<br />在调用<code>compile()</code>函数的时候，<code>shader</code>路径，<code>uniform</code>变量名，<code>attribs</code>变量名字会一同传入<code>new</code>出来的<code>shader</code>对象。<br /><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shader</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">gl, vsSrc, fsSrc, shaderLocations</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">gl</span> = gl;<br>        <span class="hljs-keyword">const</span> vs = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compileShader</span>(vsSrc, gl.<span class="hljs-property">VERTEX_SHADER</span>);<br>        <span class="hljs-keyword">const</span> fs = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compileShader</span>(fsSrc, gl.<span class="hljs-property">FRAGMENT_SHADER</span>);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">program</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addShaderLocations</span>(&#123;<br>            <span class="hljs-attr">glShaderProgram</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">linkShader</span>(vs, fs),<br>        &#125;, shaderLocations);<br>    &#125;<br>    <span class="hljs-title function_">compileShader</span>(<span class="hljs-params">shaderSource, shaderType</span>) &#123;<br>        <span class="hljs-keyword">const</span> gl = <span class="hljs-variable language_">this</span>.<span class="hljs-property">gl</span>;<br>        <span class="hljs-keyword">var</span> shader = gl.<span class="hljs-title function_">createShader</span>(shaderType);<br>        ...<br>        <span class="hljs-keyword">return</span> shader;<br>    &#125;;<br>    <span class="hljs-title function_">linkShader</span>(<span class="hljs-params">vs, fs</span>) &#123;<br>        <span class="hljs-keyword">const</span> gl = <span class="hljs-variable language_">this</span>.<span class="hljs-property">gl</span>;<br>        <span class="hljs-keyword">var</span> prog = gl.<span class="hljs-title function_">createProgram</span>();<br>        ...<br>        <span class="hljs-keyword">return</span> prog;<br>    &#125;;<br>    <span class="hljs-title function_">addShaderLocations</span>(<span class="hljs-params">result, shaderLocations</span>) &#123;<br>        <span class="hljs-keyword">const</span> gl = <span class="hljs-variable language_">this</span>.<span class="hljs-property">gl</span>;<br>        result.<span class="hljs-property">uniforms</span> = &#123;&#125;;<br>        result.<span class="hljs-property">attribs</span> = &#123;&#125;;<br>        <span class="hljs-keyword">if</span> (shaderLocations &amp;&amp; shaderLocations.<span class="hljs-property">uniforms</span> &amp;&amp; shaderLocations.<span class="hljs-property">uniforms</span>.<span class="hljs-property">length</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; shaderLocations.<span class="hljs-property">uniforms</span>.<span class="hljs-property">length</span>; ++i) &#123;<br>                result.<span class="hljs-property">uniforms</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(result.<span class="hljs-property">uniforms</span>, &#123;<br>                    [shaderLocations.<span class="hljs-property">uniforms</span>[i]]: gl.<span class="hljs-title function_">getUniformLocation</span>(result.<span class="hljs-property">glShaderProgram</span>, shaderLocations.<span class="hljs-property">uniforms</span>[i]),<br>                &#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (shaderLocations &amp;&amp; shaderLocations.<span class="hljs-property">attribs</span> &amp;&amp; shaderLocations.<span class="hljs-property">attribs</span>.<span class="hljs-property">length</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; shaderLocations.<span class="hljs-property">attribs</span>.<span class="hljs-property">length</span>; ++i) &#123;<br>                result.<span class="hljs-property">attribs</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(result.<span class="hljs-property">attribs</span>, &#123;<br>                    [shaderLocations.<span class="hljs-property">attribs</span>[i]]: gl.<span class="hljs-title function_">getAttribLocation</span>(result.<span class="hljs-property">glShaderProgram</span>, shaderLocations.<span class="hljs-property">attribs</span>[i]),<br>                &#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>shader对象在构造函数中就完成了所有事情，<code>gl.createProgram()</code>这个函数返回shader的ID，该ID存储在<code>addShaderLocations()</code>这个函数中result对象里面，<code>&#123; glShaderProgram: this.linkShader(vs, fs) &#125;</code>这里是对result对象的初始化，后面又加了两个成员变量<code>result.uniforms</code>和<code>result.attribs</code>。<br />重点是这个函数<code>addShaderLocations()</code>,<code>result.uniforms</code>和<code>result.attribs</code>存储的是一系列键值对，<code>key</code>是之前传入的uniform变量名，<code>value</code>是location后得到ID,<code>result.attribs</code>同理。<br />所以在<code>MeshRender</code>对象中，进行<code>gl.useProgram()</code>,<code>gl.uniform()</code>,<code>gl.enableVertexAttribArray()</code>操作时，只需要所以用变量名来索引<code>shader.program</code>的shaderID，uniformID,attribsID以及即可,该<code>program</code>就对应上面说的<code>result</code>的内容。<br />知道这些以后我们就可以自行对shader进行<code>uniform</code>,和<code>useProgram</code>操作,对于需要手动设置<code>uniform变量</code>如下：<br /><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>; l &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">lights</span>.<span class="hljs-property">length</span>; l++) &#123;<br>    ...<br>    <span class="hljs-comment">// Camera pass</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">meshes</span>.<span class="hljs-property">length</span>; i++) &#123;<br>        <br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">meshes</span>[i].<span class="hljs-property">materialName</span> == <span class="hljs-string">&quot;KullaContyMaterial&quot;</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">meshes</span>[i].<span class="hljs-property">materialName</span> == <span class="hljs-string">&quot;PBRMaterial&quot;</span>)&#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable constant_">ID</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">meshes</span>[i].<span class="hljs-property">shader</span>.<span class="hljs-property">program</span>.<span class="hljs-property">glShaderProgram</span>;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">gl</span>.<span class="hljs-title function_">useProgram</span>(<span class="hljs-variable constant_">ID</span>);<br>            gl.<span class="hljs-title function_">uniform3fv</span>(gl.<span class="hljs-title function_">getUniformLocation</span>(<br>                <span class="hljs-variable constant_">ID</span>, <span class="hljs-string">&quot;uLightPos&quot;</span> + <span class="hljs-string">&quot;[&quot;</span> + l + <span class="hljs-string">&quot;]&quot;</span>), <br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">lights</span>[l].<span class="hljs-property">entity</span>.<span class="hljs-property">lightPos</span>);<br>            gl.<span class="hljs-title function_">uniform3fv</span>(gl.<span class="hljs-title function_">getUniformLocation</span>(<br>                <span class="hljs-variable constant_">ID</span>, <span class="hljs-string">&quot;uLightColors&quot;</span> + <span class="hljs-string">&quot;[&quot;</span> + l + <span class="hljs-string">&quot;]&quot;</span>), <br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">lights</span>[l].<span class="hljs-property">entity</span>.<span class="hljs-property">lightRadiance</span>);<br>        &#125;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">meshes</span>[i].<span class="hljs-title function_">draw</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">camera</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>好的，框架核心的东西大概都讲完了，其他的地方根据上面说的内容，多看几遍就没任何问题了，下面讲下IBL。</p><h1 id="ibl">IBL</h1><p>IBL的实现流程如下：<br /><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//ibl</span><br><span class="hljs-keyword">let</span> envCubemap,irradianceMap,prefilterMap;<br><span class="hljs-keyword">let</span> pbrBrdfLutObj;<br><span class="hljs-keyword">let</span> hdrObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Texture</span>(gl);<br><span class="hljs-comment">//加载HDR文件</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">loadTexture</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br><span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">RGBELoader</span>().<span class="hljs-title function_">load</span>(<span class="hljs-string">&quot;assets/winter_sky_1k.hdr&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">texture</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;HDR Loaded&quot;</span>);<br><span class="hljs-title function_">resolve</span>(texture);<br>&#125;);<br>&#125;);<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">integral</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">let</span> hdrData = <span class="hljs-keyword">await</span> <span class="hljs-title function_">loadTexture</span>();<br><span class="hljs-keyword">let</span> data = hdrData.<span class="hljs-property">image</span>.<span class="hljs-property">data</span>;<br><span class="hljs-keyword">let</span> width = hdrData.<span class="hljs-property">image</span>.<span class="hljs-property">width</span>;<br><span class="hljs-keyword">let</span> height = hdrData.<span class="hljs-property">image</span>.<span class="hljs-property">height</span>;<br>gl.<span class="hljs-title function_">bindTexture</span>(gl.<span class="hljs-property">TEXTURE_2D</span>, hdrObj.<span class="hljs-property">texture</span>);<br>gl.<span class="hljs-title function_">texImage2D</span>(gl.<span class="hljs-property">TEXTURE_2D</span>, <span class="hljs-number">0</span>, gl.<span class="hljs-property">RGBA</span>, width, height, <span class="hljs-number">0</span>, gl.<span class="hljs-property">RGBA</span>, gl.<span class="hljs-property">UNSIGNED_BYTE</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(data));<br><span class="hljs-comment">////debug texture</span><br><span class="hljs-comment">// gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,</span><br><span class="hljs-comment">// new Uint8Array([0, 0, 255, 255]));</span><br>gl.<span class="hljs-title function_">texParameteri</span>(gl.<span class="hljs-property">TEXTURE_2D</span>, gl.<span class="hljs-property">TEXTURE_WRAP_S</span>, gl.<span class="hljs-property">CLAMP_TO_EDGE</span>);<br>gl.<span class="hljs-title function_">texParameteri</span>(gl.<span class="hljs-property">TEXTURE_2D</span>, gl.<span class="hljs-property">TEXTURE_WRAP_T</span>, gl.<span class="hljs-property">CLAMP_TO_EDGE</span>);<br>gl.<span class="hljs-title function_">texParameteri</span>(gl.<span class="hljs-property">TEXTURE_2D</span>, gl.<span class="hljs-property">TEXTURE_MIN_FILTER</span>, gl.<span class="hljs-property">LINEAR</span>);<br>gl.<span class="hljs-title function_">texParameteri</span>(gl.<span class="hljs-property">TEXTURE_2D</span>, gl.<span class="hljs-property">TEXTURE_MAG_FILTER</span>, gl.<span class="hljs-property">LINEAR</span>);<br>gl.<span class="hljs-title function_">bindTexture</span>(gl.<span class="hljs-property">TEXTURE_2D</span>, <span class="hljs-literal">null</span>);<br><span class="hljs-title function_">getErrorMessage</span>(gl,<span class="hljs-string">&quot;engine.js&quot;</span>);<br><span class="hljs-keyword">let</span> ibl = <span class="hljs-keyword">new</span> <span class="hljs-title function_">IBL</span>(gl,hdrObj.<span class="hljs-property">texture</span>);<br><span class="hljs-keyword">await</span> ibl.<span class="hljs-title function_">init</span>();<br>envCubemap = ibl.<span class="hljs-title function_">caculateEnvCubemap</span>();<br>irradianceMap = ibl.<span class="hljs-title function_">caculateIrradianceMap</span>();<br>prefilterMap = ibl.<span class="hljs-title function_">caculatePrefilterMap</span>();<br>pbrBrdfLutObj = ibl.<span class="hljs-title function_">caculateLut</span>();<br>&#125;<br><span class="hljs-keyword">await</span> <span class="hljs-title function_">integral</span>();<br></code></pre></td></tr></table></figure>主要就是加载<code>HDR</code>文件，将<code>HDR</code>的内容载入一张<code>2D纹理</code>中(hdrObj)，然后根据纹理生成<code>environmentCubemap</code>(envCubemap),然后根据<code>Cubemap</code>预计算漫反射项(irradianceMap)的光照部分，镜面反射项的光照部分(prefilterMap)以及对BRDF本身的预计算(pbrBrdfLutObj)，然后在shader中直接查表完成环境光<code>Cook-Torrance</code>反射模型的积分。<br />注意<code>gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE,new Uint8Array(data));</code>这个函数读取数据的类型不能像<code>Opengl</code>那样填<code>gl.FLOAT</code>,不然会报错,可以用这个函数来检测<code>getErrorMessage()</code>。如果非得使用<code>gl.Float</code>可以像作业三那样添加<code>gl.getExtension('EXT_color_buffer_float')</code>扩展。</p><h2 id="从等距柱状投影到立方体贴图">从等距柱状投影到立方体贴图</h2><p><code>HDR</code>文件载入<code>2D纹理</code>后就是<code>等距柱状投影图(Equirectangular Map)</code>,我们要做的就是将这张<code>2D纹理</code>转换成<code>Cubemap</code>。<br />这里用<a href="https://en.wikipedia.org/wiki/UV_mapping">UVmapping</a>中的技术,从球面上找到UV坐标。从<code>笛卡尔坐标系</code>转<code>球坐标系</code>然后映射到<code>[0,1]</code>区间去采样等距柱状图，在右手坐标系进行，<code>phi</code>逆时针旋转。公式如下：<br /><span class="math display">\[\begin{align}u=0.5+\frac{\arctan(p_{z},p_{x})}{2\pi}  \\v=0.5+\frac{\arcsin(p_{y})}{\pi}  \tag{1}\end{align}\]</span> 解释如下：<br /><img src="/img/00018/uv-mapping.png" alt="2" /> 代码如下:<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> vec2 invAtan = <span class="hljs-built_in">vec2</span>(<span class="hljs-number">0.1591</span>, <span class="hljs-number">0.3183</span>);<br><span class="hljs-comment">// hdr文件存储每个浮点值的方式</span><br><span class="hljs-comment">// 每个通道存储 8 位，再以 alpha 通道存放指数</span><br><span class="hljs-comment">// 因此利用这种方式解码</span><br><span class="hljs-function">vec3 <span class="hljs-title">hdrDecode</span><span class="hljs-params">(vec4 encoded)</span></span>&#123;<br>    <span class="hljs-type">float</span> exponent = encoded.a * <span class="hljs-number">256.0</span> - <span class="hljs-number">128.0</span>;<br>    vec3 mantissa = encoded.rgb;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">exp2</span>(exponent) * mantissa;<br>&#125;<br><span class="hljs-function">vec2 <span class="hljs-title">SampleSphericalMap</span><span class="hljs-params">(vec3 v)</span></span><br><span class="hljs-function"></span>&#123;<br>    vec2 uv = <span class="hljs-built_in">vec2</span>(<span class="hljs-built_in">atan</span>(v.z, v.x), <span class="hljs-built_in">asin</span>(v.y));<br>    uv *= invAtan;<br>    uv += <span class="hljs-number">0.5</span>;<br>    <span class="hljs-keyword">return</span> uv;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vec2 uv = <span class="hljs-built_in">SampleSphericalMap</span>(<span class="hljs-built_in">normalize</span>(WorldPos));<br>    vec4 enCodeColor = <span class="hljs-built_in">texture</span>(uEquirectangularMap,uv).rgba;<br>    vec3 deCodeColor = <span class="hljs-built_in">hdrDecode</span>(enCodeColor);<br>    fragColor = <span class="hljs-built_in">vec4</span>(<span class="hljs-built_in">vec3</span>(deCodeColor), <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p><h2id="环境光cook-torrance反射方程的预计算">环境光Cook-Torrance反射方程的预计算</h2><p>快速浏览一下反射方程：<br /><span class="math display">\[L_{o}(p,w_{o})=\int_{\Omega}^{}(kd\frac{c}{\pi}+ks\frac{DFG}{4(w_{o}\cdotn)(w_{i}\cdot n)})L_{i}(p,w_{i})n\cdot w_{i}dw_{i} \tag{2}\]</span> 该公式的解释可以参考<ahref="https://learnopengl-cn.github.io/07%20PBR/01%20Theory/">OpenglPbr</a>。值得一提的是公式中<code>ks</code>和<code>Fresnel</code>项指代的同一件事情，所以<code>ks</code>可以省略，其中<code>o</code>代表出射方向也就是我们看到的方向，<code>i</code>是入射方向即光照方向。</p><h3 id="漫反射光照的预计算">漫反射光照的预计算</h3><p>仔细观察会发现<code>BRDF</code>的漫反射<code>kd</code>和镜面<code>ks</code>项是相互独立的，我们可以将积分分成两部分：<span class="math display">\[L_{o}(p,w_{o})=\int_{\Omega}(kd\frac{c}{\pi})L_{i}(p,w_{i})n\cdotw_{i}dw_{i}+\int_{\Omega}(\frac{DFG}{4(w_{o}\cdot n)(w_{i}\cdotn)})L_{i}(p,w_{i})n\cdot w_{i}dw_{i} \tag{3}\]</span>前这部分才是本节的重点，让我们在化简一下(颜色<code>c</code>,漫反射率<code>kd</code>,和<code>π</code>在整个积分是常数)：<br /><span class="math display">\[L_{o}(p,w_{o})=(kd\frac{c}{\pi})\int_{\Omega}L_{i}(p,w_{i})n\cdotw_{i}dw_{i} \tag{4}\]</span>经过简化有可以发现，积分目前只跟<code>wi</code>有关(假设物体上的点p位于立方体中间，<code>N</code>为<code>p</code>与立方体上某点的连线)，由于是漫反射在半球上的积分，其入射方向是均匀的来自半球的四面八方。<br />积分参考<code>Opengl</code>的方法：对于立方体贴图的每个纹素，在<code>纹素所代表的方向</code>的半球Ω内生成固定数量的采样向量，并对采样结果取平均值。数量固定的采样向量将均匀地分布在半球内部。注意，积分是连续函数，在采样向量数量固定的情况下离散地采样只是一种近似计算方法，我们采样的向量越多，就越接近正确的结果。<br />纹素所代表的方向的半球<code>Ω</code>内生成固定数量的采样向量，图解如下：<br /><img src="/img/00018/irradiance.png" alt="3" /><br />反射方程的积分<code>∫</code>是围绕立体角<code>dw</code>旋转，而这个立体角相当难以处理。为了避免对难处理的立体角求积分，我们使用球坐标<code>θ</code>和<code>ϕ</code>来代替立体角。公式如下：<br /><span class="math display">\[\begin{align}L_{o}(p,\phi_{o},\theta_{o})=kd\frac{c}{\pi}\int_{\phi=0}^{2\pi}\int_{\theta=0}^{\frac{1}{2}\pi}L_{i}(p,\phi_{i},\theta_{i})\cos(\theta_{i})\sin(\theta_{i})d\thetad\phi\\=kd\frac{c}{\pi}\frac{2\pi}{n1}\frac{\pi}{2\cdotn2}\sum_{m=0}^{n1}\sum_{n=0}^{n2}L_{i}(p,\phi_{m},\theta_{n})\cos(\theta_{n})\sin(\theta_{n})\\=kd\frac{c\pi}{n1\cdotn2}\sum_{m=0}^{n1}\sum_{n=0}^{n2}L_{i}(p,\phi_{m},\theta_{n})\cos(\theta_{n})\sin(\theta_{n})\tag{5}\end{align}\]</span>该结果由蒙特卡洛积分所得，<code>φ</code>的概率密度为<code>1/2PI</code>，<code>θ</code>的概率密度为<code>2/PI</code>，其中添加的<code>sin(θ)</code>是为了权衡较高半球区域的较小采样区域的贡献度如图：<br /><img src="/img/00018/image.png" alt="4" /><br />给定每个片段的积分球坐标，对半球进行离散采样，过程代码如下：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">float</span> PI = <span class="hljs-number">3.14159265359</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vec3 N = <span class="hljs-built_in">normalize</span>(WorldPos);<br>    vec3 irradiance = <span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0</span>);   <br>    <span class="hljs-comment">// tangent space calculation from origin point</span><br>    vec3 up    = <span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>);<br>    vec3 right = <span class="hljs-built_in">normalize</span>(<span class="hljs-built_in">cross</span>(up, N));<br>    up         = <span class="hljs-built_in">normalize</span>(<span class="hljs-built_in">cross</span>(N, right));<br>    <span class="hljs-type">float</span> sampleDelta = <span class="hljs-number">0.025</span>;<br>    <span class="hljs-type">float</span> nrSamples = <span class="hljs-number">0.0f</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">float</span> phi = <span class="hljs-number">0.0</span>; phi &lt; <span class="hljs-number">2.0</span> * PI; phi += sampleDelta)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">float</span> theta = <span class="hljs-number">0.0</span>; theta &lt; <span class="hljs-number">0.5</span> * PI; theta += sampleDelta)<br>        &#123;<br>            <span class="hljs-comment">// spherical to cartesian (in tangent space)</span><br>            vec3 tangentSample = <span class="hljs-built_in">vec3</span>(<span class="hljs-built_in">sin</span>(theta) * <span class="hljs-built_in">cos</span>(phi),  <span class="hljs-built_in">sin</span>(theta) * <span class="hljs-built_in">sin</span>(phi), <span class="hljs-built_in">cos</span>(theta));<br>            <span class="hljs-comment">// tangent space to world</span><br>            vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * N; <br>            irradiance += <span class="hljs-built_in">texture</span>(uEnvironmentMap, sampleVec).rgb * <span class="hljs-built_in">cos</span>(theta) * <span class="hljs-built_in">sin</span>(theta);<br>            nrSamples++;<br>        &#125;<br>    &#125;<br>    irradiance = PI * irradiance * (<span class="hljs-number">1.0</span> / <span class="hljs-built_in">float</span>(nrSamples));<br>    FragColor = <span class="hljs-built_in">vec4</span>(irradiance, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>球坐标系转笛卡尔坐标系，得到的是切线空间的向量，需要用<code>TBN</code>矩阵将该向量转至世界空间。最后得到漫反射辐照度贴图如下：<br /><img src="/img/00018/image-1.png" alt="5" /><br />糊的很，根本没有细节可言。</p><h3 id="splitsum和ggx重要性采样">SplitSum和GGX重要性采样</h3><p>为了理解，我们回顾一下反射方程，但这次只关注镜面反射部分（在上一节中已经剥离了漫反射部分）：<br /><span class="math display">\[L_{o}(p,w_{o})=\int_{\Omega}(\frac{DFG}{4(w_{o}\cdot n)(w_{i}\cdotn)})L_{i}(p,w_{i})n\cdot w_{i}dw_{i} \tag{6}\]</span>对这部分积分进行预计算有个棘手的地方，它不仅依赖<code>wi</code>还依赖<code>wo</code>，我们不可能吧<code>wi</code>和<code>wo</code>的每种组合都进行预计算(wi(θ，φ),wo(θ，φ),F0,roughness,一共六个维度也无法预计算)，所以<code>Epic Games</code>提出了一个新的解决方法<ahref="http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf">splitsum</a>：<br /><span class="math display">\[\begin{align}\int_{\Omega}(\frac{DFG}{4(w_{o}\cdot n)(w_{i}\cdotn)})L_{i}(p,w_{i})n\cdot w_{i}dw_{i}\\\approx\frac{1}{N}\sum_{k=1}^{N}\frac{L_{i}(p,w_{ik})f_{r}(p,w_{ik},w_{ok})\cos(\theta_{ik})}{p(w_{ik},w_{ok})}\\\approx(\frac{1}{N}\sum_{k=1}^{N}L_{i}(p,w_{ik}))(\frac{1}{N}\sum_{k=1}^{N}\frac{f_{r}(p,w_{ik},w_{ok})\cos(\theta_{ik})}{p(w_{ik},w_{ok})})\tag{7}\end{align}\]</span>该式子左边是一个求和，右边是蒙特卡洛积分，左右分别为两维度，可以直接查表。左边wi是两维度好理解，右边两维度我在后面章节解释。我们分别对这两部分进行预计算就可以解决上面棘手的部分。<br />但是它们都是建立在<code>GGX重要性采样</code>的基础上，先介绍一下重要性采样：<br />我们使用球面坐标生成均匀分布在半球<code>Ω</code>上的采样向量，以对环境贴图进行卷积。虽然这个方法非常适用于辐照度，但对于镜面反射效果较差。镜面反射依赖于表面的粗糙度，反射光线可能比较松散，也可能比较紧密，但是一定会围绕着反射向量<code>r</code>，除非表面极度粗糙:<br /><img src="/img/00018/image-2.png" alt="6" /><br />所有可能出射的反射光构成的形状称为镜面波瓣。随着粗糙度的增加，镜面波瓣的大小增加；随着入射光方向不同，形状会发生变化。因此，镜面波瓣的形状高度依赖于材质。在微表面模型里给定入射光方向，则镜面波瓣指向微平面的半向量的反射方向。考虑到大多数光线最终会反射到一个基于半向量的镜面波瓣内，采样时以类似的方式选取采样向量是有意义的，因为大部分其余的向量都被浪费掉了。根据表面粗糙度生成法线<code>N</code>，然后以镜面反射的形式计算出采样方向的过程称为<code>重要性采样</code>。<br />要理解重要性采样需要先理解<ahref="https://en.wikipedia.org/wiki/Inverse_transform_sampling">逆变换采样</a>，逆变换采样是用range为[0,1]之间的均匀随机数来生成服从pdf的样本，其过程如下：<br />1.从均匀分布<code>U[0,1]</code>中产生一个随机数<code>ui</code><br />2.计算<spanclass="math inline">\(x_{i}=F_{X}^{-1}(u_{i})\)</span>作为采样结果<br />其中<spanclass="math inline">\(F_{X}(x)\)</span>为<code>CDF</code>(累积分布函数)所有的<code>CDF</code>中，在<code>x</code>趋近最小值时，<code>CDF</code>趋近于<code>0</code>，当<code>x</code>趋近最大值时，<code>CDF</code>趋近与<code>1</code>。<br /><spanclass="math inline">\(f_{X}(x)\)</span>为随机变量<code>X</code>的<code>pdf</code>(概率密度函数)。这是它们的关系<spanclass="math inline">\(F_{X}(x)=\int_{-\infty}^{x}f_{X}(u)du\)</span><br /><spanclass="math inline">\(F_{X}^{-1}(x)\)</span>为<code>cdf</code>的反函数，只有单调非减的函数才有反函数。<code>GGX重要性采样</code>用的概率密度函数为<ahref="https://www.reedbeta.com/blog/hows-the-ndf-really-defined/">D(h)dot(n,h)</a>，其在球坐标系下的概率密度函数为：<span class="math display">\[p_{h}(\theta,\phi)=\frac{\alpha^{2}\cos(\theta)\sin(\theta)}{\pi((\alpha^{2}-1)\cos^{2}(\theta)+1)^{2}}\tag{8}\]</span> 分别求θ和φ的边缘概率密度函数(pdf)： <spanclass="math display">\[\begin{align}p_{h}(\theta)=\int_{0}^{2\pi}p_{h}(\theta,\phi)d\phi=\frac{2\alpha^{2}\cos(\theta)\sin(\theta)}{((\alpha^{2}-1)\cos^{2}(\theta)+1)^{2}}\tag{9}\end{align}\]</span> <span class="math display">\[\begin{align}p_{h}(\phi)=\int_{0}^{\frac{\pi}{2}}\frac{\alpha^{2}\cos(\theta)\sin(\theta)}{\pi((\alpha^2-1)\cos^{2}(\theta)+1)^{2}}d\theta\\=-\frac{\alpha^{2}}{2\pi}\int_{0}^{\frac{\pi}{2}}\frac{-2\cos(\theta)\sin(\theta)}{((\alpha^2-1)\cos^{2}(\theta)+1)^{2}}d\theta\\=\frac{\alpha^{2}}{2\pi}\int_{\frac{\pi}{2}}^{0}\frac{1}{((\alpha^2-1)\cos^{2}(\theta)+1)^{2}}d(\cos^{2}\theta)\\=\frac{\alpha^{2}}{2\pi}\int_{0}^{1}\frac{1}{((\alpha^{2}-1)t+1)^{2}}dt\\\end{align}\]</span> 令<code>x=(α^2-1)t+1</code> <span class="math display">\[\begin{align}=\frac{\alpha^{2}}{2\pi(\alpha^2-1)}\int_{1}^{\alpha^2}\frac{1}{x^{2}}dx\\=\frac{\alpha^{2}}{2\pi(1-\alpha^2)}\frac{1}{x}\vert_{1}^{\alpha^2} \\=\frac{1}{2\pi} \tag{10}\end{align}\]</span> 再分别求<code>θ</code>和<code>φ</code>的累计分布函数(cdf):<span class="math display">\[P_{h}(\phi)=\int_{0}^{\phi}\frac{1}{2\pi}dt=\frac{\phi}{2\pi} \tag{11}\]</span> <span class="math display">\[\begin{align}P_{h}(\theta)=\int_{0}^{\theta}\frac{2\alpha^{2}\cos(t)\sin(t)}{((\alpha^{2}-1)\cos^{2}(t)+1)^{2}}dt\\=\alpha^{2}\int_{\theta}^{0}\frac{1}{((\alpha^2-1)\cos^{2}(t)+1)^{2}}d(\cos^{2}(t))\\=\frac{\alpha^2}{\alpha^2-1}\int_{\alpha^2}^{(\alpha^2-1)\cos^{2}(\theta)+1}-\frac{1}{x^{2}}dx\\=\frac{\alpha^2}{\alpha^2-1}\frac{1}{x}\vert_{\alpha^{2}}^{(\alpha^2-1)\cos^{2}(\theta)+1}\\=\frac{\alpha^{2}}{\alpha^{2}-1}\cdot(\frac{1}{(\alpha^2-1)\cos^{2}(\theta)+1}-\frac{1}{\alpha^{2}}) \tag{12}\end{align}\]</span>反函数就是函数值域<code>Y</code>和定义域<code>X</code>的映射关系翻转一下。均匀的从<code>U[0,1]</code>中取出两个随机数<spanclass="math inline">\(X_{1}\)</span>和<spanclass="math inline">\(X_{2}\)</span>,则我们要的采样<code>θ</code>和<code>φ</code>为：<br /><span class="math display">\[\phi=2\pi X_{1} \tag{13}\]</span> <span class="math display">\[\theta=\arccos\sqrt{\frac{1-X_{2}}{X_{2}(\alpha^{2}-1)+1}} \tag{14}\]</span> 对应代码实现如下：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vec3 <span class="hljs-title">ImportanceSampleGGX</span><span class="hljs-params">(vec2 Xi, vec3 N, <span class="hljs-type">float</span> roughness)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">float</span> a = roughness*roughness;<br><span class="hljs-type">float</span> phi = <span class="hljs-number">2.0</span> * PI * Xi.x;<br><span class="hljs-type">float</span> cosTheta = <span class="hljs-built_in">sqrt</span>((<span class="hljs-number">1.0</span> - Xi.y) / (<span class="hljs-number">1.0</span> + (a*a - <span class="hljs-number">1.0</span>) * Xi.y));<br><span class="hljs-type">float</span> sinTheta = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span> - cosTheta*cosTheta);<br><span class="hljs-comment">// from spherical coordinates to cartesian coordinates - halfway vector</span><br>vec3 H;<br>H.x = <span class="hljs-built_in">cos</span>(phi) * sinTheta;<br>H.y = <span class="hljs-built_in">sin</span>(phi) * sinTheta;<br>H.z = cosTheta;<br><span class="hljs-comment">// from tangent-space H vector to world-space sample vector</span><br>vec3 up          = <span class="hljs-built_in">abs</span>(N.z) &lt; <span class="hljs-number">0.999</span> ? <span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>) : <span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);<br>vec3 tangent   = <span class="hljs-built_in">normalize</span>(<span class="hljs-built_in">cross</span>(up, N));<br>vec3 bitangent = <span class="hljs-built_in">cross</span>(N, tangent);<br>vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">normalize</span>(sampleVec);<br>&#125;<br></code></pre></td></tr></table></figure> ### 镜面反射光照的预计算</p><p>上节内容提到用<code>Split Sum</code>来分割镜面反射的光照和BRDF部分以避免去求wi和wo所有组合下的积分。本节重要点放在镜面反射光照的预计算，我们再看下这部分的公式：<br /><span class="math display">\[\frac{1}{N}\sum_{k=1}^{N}L_{i}(p,w_{ik}) \tag{15}\]</span>这里可以看做是一次求和取平均。还有一个问题就是，这里的wi不仅需要<code>GGX重要性采样</code>得到的符合<code>D(h)dot(n,h)概率密度函数</code>的微表面法线方向，还需要视角方向<code>V</code>,但是我们并不能提前知道<code>V</code>是什么方向，这里<code>Epic Games</code>再一次假设，即<code>v=r=n</code>。这种各向同性假设是第二个近似来源，不幸的是，这意味在掠入射角时不会得到长反射效果：<br /><img src="/img/00018/image-3.png" alt="7" /><br />与分裂和近似相比，这实际上是我们<code>IBL</code>解的较大误差源。代码中通过<code>cosθlk</code>加权可以获得更好的结果：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vec3 N = <span class="hljs-built_in">normalize</span>(WorldPos);<br>    <span class="hljs-comment">// make the simplifying assumption that V equals R equals the normal </span><br>    vec3 R = N;<br>    vec3 V = R;<br>    <span class="hljs-type">const</span> uint SAMPLE_COUNT = <span class="hljs-number">1024u</span>;<br>    vec3 prefilteredColor = <span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0</span>);<br>    <span class="hljs-type">float</span> totalWeight = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">for</span>(uint i = <span class="hljs-number">0u</span>; i &lt; SAMPLE_COUNT; ++i)<br>    &#123;<br>        <span class="hljs-comment">// generates a sample vector that&#x27;s biased towards the preferred alignment direction (importance sampling).</span><br>        vec2 Xi = <span class="hljs-built_in">Hammersley</span>(i, SAMPLE_COUNT);<br>        vec3 H = <span class="hljs-built_in">ImportanceSampleGGX</span>(Xi, N, uRoughness);<br>        vec3 L  = <span class="hljs-built_in">normalize</span>(<span class="hljs-number">2.0</span> * <span class="hljs-built_in">dot</span>(V, H) * H - V);<br>        <span class="hljs-comment">//COS weight can increase image quality</span><br>        <span class="hljs-type">float</span> NdotL = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(N, L), <span class="hljs-number">0.0</span>);<br>        <span class="hljs-keyword">if</span>(NdotL &gt; <span class="hljs-number">0.0</span>)<br>        &#123;<br>            <span class="hljs-comment">// sample from the environment&#x27;s mip level based on roughness/pdf</span><br>            <span class="hljs-type">float</span> D   = <span class="hljs-built_in">DistributionGGX</span>(N, H, uRoughness);<br>            <span class="hljs-type">float</span> NdotH = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(N, H), <span class="hljs-number">0.0</span>);<br>            <span class="hljs-type">float</span> HdotV = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(H, V), <span class="hljs-number">0.0</span>);<br>            <span class="hljs-type">float</span> pdf = D * NdotH / (<span class="hljs-number">4.0</span> * HdotV) + <span class="hljs-number">0.0001</span>; <br>            <span class="hljs-type">float</span> resolution = <span class="hljs-number">512.0</span>; <span class="hljs-comment">// resolution of source cubemap (per face)</span><br>            <span class="hljs-type">float</span> saTexel  = <span class="hljs-number">4.0</span> * PI / (<span class="hljs-number">6.0</span> * resolution * resolution);<br>            <span class="hljs-type">float</span> saSample = <span class="hljs-number">1.0</span> / (<span class="hljs-built_in">float</span>(SAMPLE_COUNT) * pdf + <span class="hljs-number">0.0001</span>);<br>            <span class="hljs-comment">//sample solid angle ratio to pixel solid angle</span><br>            <span class="hljs-type">float</span> mipLevel = uRoughness == <span class="hljs-number">0.0</span> ? <span class="hljs-number">0.0</span> : <span class="hljs-number">0.5</span> * <span class="hljs-built_in">log2</span>(saSample / saTexel);        <br>            prefilteredColor += <span class="hljs-built_in">textureLod</span>(uEnvironmentMap, L, mipLevel).rgb * NdotL;<br>            totalWeight      += NdotL;<br>        &#125;<br>    &#125;<br>    prefilteredColor = prefilteredColor / totalWeight;<br>    FragColor = <span class="hljs-built_in">vec4</span>(prefilteredColor, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure> 代码中的<code>pdf</code>推导过程如下，图片来源于<ahref="https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf">2007年论文</a>：<br /><span class="math display">\[p_{o}(\theta,\phi)=p_{h}(\theta,\phi)\cdot\lVert\frac{\partialw_{h}}{\partial w_{o}}\rVert \tag{16}\]</span> <img src="/img/00018/pdf-derivation.png" alt="8" /><br /><span class="math display">\[\begin{align}\lVert\frac{\partial w_{h}}{\partial w_{o}}\rVert=\frac{\vert o\cdoth\vert}{\lVert\vec{h}\rVert^{2}} \\=\frac{\vert o\cdot h\vert}{\lVert 2(o\cdot h)h\rVert^{2}}=\frac{\vert o\cdot h\vert}{4(o\cdot h)^{2}\lVerth\rVert^{2}}=\frac{1}{4\vert o\cdot h\vert} \tag{17}\end{align}\]</span>其中<code>i</code>，<code>o</code>和<code>没箭头的h</code>，都是归一化后的向量。这只是反射模型的<code>pdf</code>，以同样的计算方法论文作者还给出了折射的<code>pdf</code>，感兴趣可以去看下。需要注意的是这里推导涉及的i，o和代码中的v，L没关系，只是单纯用来推导的,一般来说我们视<code>i</code>为光照方向，<code>o</code>为视角方向。</p><p>代码中<ahref="https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-20-gpu-based-importance-sampling">采样</a>是对<code>uEnvironmentMap</code>的<code>mipmap</code>来采样，而不是直接去获取清晰度最高的<code>uEnvironmentMap</code>,这样做的原因是<code>pdf</code>越低，样本所对应的环境贴图中平均像素数就越多，使用的<code>mipmap</code>层级应该越大，这可以做到少采样数量达到多采样数量的效果，并减少伪影。我们用与样本相关的实体角来定义这种关系，计算方法是<code>pdf</code>与样本总数<code>N</code>之间乘积的倒数：<br /><span class="math display">\[\Omega_{s}=\frac{1}{N\cdot p_{L}(\theta,\phi)} \tag{18}\]</span>该式子表示采样方向所对应的环境贴图中像素数的多少(采样立体角的大小)。我们还需要知道立方体贴图中一个像素对应的立体角是多大,我们这里是求单位球表面积比上立方体分辨率：<br /><span class="math display">\[\Omega_{p}=\frac{d(u)}{w\cdot h} \tag{19}\]</span>原文这个<code>d(u)</code>是计算从半球的单位面积到纹理上的单位面积的变化速率（换句话说，计算映射的畸变率），原文<code>d(u)</code>是应用在另一种采样方式，不是在立方体贴图上面进行的采样，和我们这里不一样，我们这里直接算立方体贴图上一个像素对应的立体角大小就行。那<code>d(u)</code>直接就是单位球的表面积<code>4π</code>。<br />最后用下面这个公式计算<code>mipmap</code>层数：<br /><span class="math display">\[level=max[\frac{1}{2}\log_{2}\frac{\Omega_{s}}{\Omega_{p}},0] \tag{20}\]</span>最后计算完的<code>prefilteredColor</code>根据粗糙度<code>[0,1]</code>，分别存入<code>prefilterMap</code>的<code>5</code>层<code>mipmap</code>中，在最后<code>shading</code>过程中，根据粗糙度来获取<code>prefilteredColor</code>层数。代码如下：<br /><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js">gl.<span class="hljs-title function_">bindFramebuffer</span>(gl.<span class="hljs-property">FRAMEBUFFER</span>, captureFBO);<br><span class="hljs-keyword">const</span> maxMipLevels = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> mip = <span class="hljs-number">0</span>; mip &lt; maxMipLevels; ++mip)<br>&#123;<br>    <span class="hljs-comment">// reisze framebuffer according to mip-level size.</span><br>    <span class="hljs-keyword">let</span> mipWidth  = <span class="hljs-number">128</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">0.5</span>, mip);<br>    <span class="hljs-keyword">let</span> mipHeight = <span class="hljs-number">128</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">0.5</span>, mip);<br>    gl.<span class="hljs-title function_">bindRenderbuffer</span>(gl.<span class="hljs-property">RENDERBUFFER</span>, captureRBO);<br>    gl.<span class="hljs-title function_">renderbufferStorage</span>(gl.<span class="hljs-property">RENDERBUFFER</span>, gl.<span class="hljs-property">DEPTH_COMPONENT24</span>, mipWidth, mipHeight);<br>    gl.<span class="hljs-title function_">viewport</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mipWidth, mipHeight);<br>    <span class="hljs-keyword">let</span> roughness = mip / (maxMipLevels - <span class="hljs-number">1</span>);<br>    gl.<span class="hljs-title function_">uniform1f</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">prefilterShader</span>.<span class="hljs-property">program</span>.<span class="hljs-property">uniforms</span>[<span class="hljs-string">&quot;uRoughness&quot;</span>],roughness);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; ++i)<br>    &#123;<br>        gl.<span class="hljs-title function_">uniformMatrix4fv</span>(<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">prefilterShader</span>.<span class="hljs-property">program</span>.<span class="hljs-property">uniforms</span>[<span class="hljs-string">&quot;uViewMatrix&quot;</span>],<br>            <span class="hljs-literal">false</span>,<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">captureViews</span>[i]);<br>        gl.<span class="hljs-title function_">framebufferTexture2D</span>(gl.<span class="hljs-property">FRAMEBUFFER</span>, gl.<span class="hljs-property">COLOR_ATTACHMENT0</span>, gl.<span class="hljs-property">TEXTURE_CUBE_MAP_POSITIVE_X</span> + i, <span class="hljs-variable language_">this</span>.<span class="hljs-property">prefilterMap</span>, mip);<br>        gl.<span class="hljs-title function_">clear</span>(gl.<span class="hljs-property">COLOR_BUFFER_BIT</span> | gl.<span class="hljs-property">DEPTH_BUFFER_BIT</span>);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">renderCube</span>();<br>    &#125;<br>&#125;<br>gl.<span class="hljs-title function_">bindFramebuffer</span>(gl.<span class="hljs-property">FRAMEBUFFER</span>, <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure> 一切顺利的话，会得到下面的图片：<br /><img src="/img/00018/image-6.png" alt="9" /></p><h3 id="预计算brdf">预计算BRDF</h3><p>有了上面的基础，这部分内容就比较简单了，快速看一遍公式：<br /><span class="math display">\[\frac{1}{N}\sum_{k=1}^{N}\frac{f_{r}(p,w_{ik},w_{ok})\cos(\theta_{ik})}{p(w_{ik},w_{ok})}\tag{21}\]</span>上文说到镜面反射方程有六个维度<code>wi(θ，φ)</code>,<code>wo(θ，φ)</code>,<code>F0</code>,<code>roughness</code>,由于光照部分我们已经处理过了，而此时<code>BRDF</code>的<code>wi</code>和<code>wo</code>都是和<code>n</code>绑定在一起的，那这里<code>BRDF</code>就只剩下<code>4</code>个维度<code>wi·n</code>,<code>wo·n</code>,<code>F0</code>,<code>roughness</code>,由于重要性采样可以由<code>wo</code>生成服从<code>D(h)dot(n,h)</code>概率密度函数的<code>wi</code>，则维度可以再降到3个<code>wo·n</code>,<code>F0</code>,<code>roughness</code>，再将<code>Fresnel</code>项拆分成两部分，<code>F0</code>也可以移出积分范围，维度再降到2个<code>wo·n</code>,<code>roughness</code>，这样就可以愉快的打表了😆！下面是拆分过程，我这里把<code>k</code>角标去掉了方便观看：<br /><span class="math display">\[\begin{align}\frac{1}{N}\sum_{k=1}^{N}\frac{f_{r}(p,w_{i},w_{o})\cos(\theta_{i})}{p(w_{i},w_{o})}\\=\frac{1}{N}\sum_{k=1}^{N}\frac{f_{r}(p,w_{i},w_{o})F(w_{o},h)\cos(\theta_{i})}{F(w_{o},h)p(w_{i},w_{o})}\\=\frac{1}{N}\sum_{k=1}^{N}\frac{f_{r}(p,w_{i},w_{o})}{F(w_{o},h)p(w_{i},w_{o})}(F0+(1-F0)(1-w_{o}\cdoth)^{5})\cos(\theta_{i})\end{align}\]</span> 这里用<code>α</code>代替<code>(1-wo·h)^5</code>:<br /><span class="math display">\[\begin{align}=\frac{1}{N}\sum_{k=1}^{N}\frac{f_{r}(p,w_{i},w_{o})}{F(w_{o},h)p(w_{i},w_{o})}(F0+(1-F0)\alpha)\cos(\theta_{i})\\=\frac{1}{N}\sum_{k=1}^{N}\frac{f_{r}(p,w_{i},w_{o})}{F(w_{o},h)p(w_{i},w_{o})}(F0*(1-\alpha)+\alpha)\cos(\theta_{i})\\=\frac{1}{N}\sum_{k=1}^{N}\frac{f_{r}(p,w_{i},w_{o})}{F(w_{o},h)p(w_{i},w_{o})}F0*(1-\alpha)\cos(\theta_{i})+\frac{1}{N}\sum_{k=1}^{N}\frac{f_{r}(p,w_{i},w_{o})}{F(w_{o},h)p(w_{i},w_{o})}\alpha\cos(\theta_{i})\tag{22}\end{align}\]</span> 可以看到这两部分都包含一个共同项：<br /><span class="math display">\[\frac{f_{r}(p,w_{i},w_{o})}{F(w_{o},h)p(w_{i},w_{o})}\cos(\theta_{i})\]</span>我们将其化简一下,其中<code>pdf=D * NdotH / (4.0 * VdotH)</code>：<br /><span class="math display">\[\begin{align}=\frac{DG\cos(\theta_{i})}{4\cos(\theta_{o})\cos(\theta_{i})}\frac{4(o\cdoth)}{D(n\cdot h)} \\=\frac{G(o\cdot h)}{(o\cdot n)(n\cdot h)} \tag{23}\end{align}\]</span> 带入(22)式中得：<br /><span class="math display">\[F0*\frac{1}{N}\sum_{k=1}^{N}\frac{G(o\cdot h)}{(o\cdot n)(n\cdoth)}(1-(1-(w_{o}\cdot h)^{5}))+\frac{1}{N}\sum_{k=1}^{N}\frac{G(o\cdoth)}{(o\cdot n)(n\cdot h)}(1-(w_{o}\cdot h)^{5}) \tag{24}\]</span> 代码实现如下：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vec2 <span class="hljs-title">IntegrateBRDF</span><span class="hljs-params">(<span class="hljs-type">float</span> NdotV, <span class="hljs-type">float</span> roughness)</span></span><br><span class="hljs-function"></span>&#123;<br>    vec3 V;<br>    V.x = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span> - NdotV*NdotV);<br>    V.y = <span class="hljs-number">0.0</span>;<br>    V.z = NdotV;<br>    <span class="hljs-type">float</span> A = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-type">float</span> B = <span class="hljs-number">0.0</span>; <br>    vec3 N = <span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    <span class="hljs-type">const</span> uint SAMPLE_COUNT = <span class="hljs-number">1024u</span>;<br>    <span class="hljs-keyword">for</span>(uint i = <span class="hljs-number">0u</span>; i &lt; SAMPLE_COUNT; ++i)<br>    &#123;<br>        <span class="hljs-comment">// generates a sample vector that&#x27;s biased towards the</span><br>        <span class="hljs-comment">// preferred alignment direction (importance sampling).</span><br>        vec2 Xi = <span class="hljs-built_in">Hammersley</span>(i, SAMPLE_COUNT);<br>        vec3 H = <span class="hljs-built_in">ImportanceSampleGGX</span>(Xi, N, roughness);<br>        vec3 L = <span class="hljs-built_in">normalize</span>(<span class="hljs-number">2.0</span> * <span class="hljs-built_in">dot</span>(V, H) * H - V);<br>        <span class="hljs-type">float</span> NdotL = <span class="hljs-built_in">max</span>(L.z, <span class="hljs-number">0.0</span>);<br>        <span class="hljs-type">float</span> NdotH = <span class="hljs-built_in">max</span>(H.z, <span class="hljs-number">0.0</span>);<br>        <span class="hljs-type">float</span> VdotH = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(V, H), <span class="hljs-number">0.0</span>);<br>        <span class="hljs-keyword">if</span>(NdotL &gt; <span class="hljs-number">0.0</span>)<br>        &#123;<br>            <span class="hljs-type">float</span> G = <span class="hljs-built_in">GeometrySmith</span>(N, V, L, roughness);<br>            <span class="hljs-type">float</span> G_Vis = (G * VdotH) / (NdotH * NdotV);<br>            <span class="hljs-type">float</span> Fc = <span class="hljs-built_in">pow</span>(<span class="hljs-number">1.0</span> - VdotH, <span class="hljs-number">5.0</span>);<br>            <span class="hljs-comment">//pdf = D * NdotH / (4.0 * HdotV); </span><br>            A += (<span class="hljs-number">1.0</span> - Fc) * G_Vis;<br>            B += Fc * G_Vis;<br>        &#125;<br>    &#125;<br>    A /= <span class="hljs-built_in">float</span>(SAMPLE_COUNT);<br>    B /= <span class="hljs-built_in">float</span>(SAMPLE_COUNT);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">vec2</span>(A, B);<br>&#125;<br></code></pre></td></tr></table></figure> 如果一切顺利，会得到这样一张纹理：<br /><img src="/img/00018/image-4.png" alt="10" /><br />代码中debug出的样子如下：<br /><img src="/img/00018/image-5.png" alt="11" /></p><h2 id="完成ibl反射">完成IBL反射</h2><p>对上面完成的三部分预计算纹理进行查表，即环境光Cook-Torrance反射方程的积分值。代码如下：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vec3 <span class="hljs-title">fresnelSchlickRoughness</span><span class="hljs-params">(vec3 F0, vec3 V, vec3 N,<span class="hljs-type">float</span> roughness)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> F0 + (<span class="hljs-built_in">max</span>(<span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0</span> - roughness), F0) - F0) * <span class="hljs-built_in">pow</span>(<span class="hljs-number">1.0</span> - <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(N,V),<span class="hljs-number">0.0</span>), <span class="hljs-number">5.0</span>);<br>&#125; <br>...<br><span class="hljs-comment">//以环境光作为IBL</span><br>vec3 F = <span class="hljs-built_in">fresnelSchlickRoughness</span>(F0,V,N,uRoughness);<br>vec3 kD = (<span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0</span>) - F) * (<span class="hljs-number">1.0</span> - uMetallic);<br><span class="hljs-comment">//漫反射光照项</span><br>vec3 irradiance = <span class="hljs-built_in">texture</span>(uIrradianceMap,N).rgb;<br>vec3 diffuse = irradiance * albedo;<br><span class="hljs-comment">//以确保不会对一个没有数据的mip级别采样</span><br><span class="hljs-type">const</span> <span class="hljs-type">float</span> MAX_REFLECTION_LOD = <span class="hljs-number">4.0</span>;<br><span class="hljs-comment">//镜面反射光照项</span><br>vec3 prefilteredColor = <span class="hljs-built_in">textureLod</span>(uPrefilterMap,R,uRoughness * MAX_REFLECTION_LOD).rgb;<br><span class="hljs-comment">//BRDF项</span><br>vec2 brdf = <span class="hljs-built_in">texture</span>(uPbrBrdfLUT,<span class="hljs-built_in">vec2</span>(<span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(N,V),<span class="hljs-number">0.0</span>),uRoughness)).rg;<br><span class="hljs-comment">//split sum</span><br>vec3 specular = prefilteredColor * (F0 * brdf.r + brdf.g);<br><span class="hljs-comment">//环境光Cook-Torrance反射方程的积分值</span><br>vec3 ambient = (kD * diffuse + specular) * uAo;<br></code></pre></td></tr></table></figure>使用<code>fresnelSchlickRoughness</code>函数，是由于环境光来自在半球内所有围绕着法线<code>N</code>的方向，没有单一的半向量去决定菲涅尔因子。为了仍然能模拟菲涅尔，这里采用了法线和视线的夹角。之前的算法采用了受表面粗糙度影响的微平面半向量，作为菲涅尔方程的输入。这里我们加入粗糙度来权衡这一损失。<br />然后将<code>ambient</code>加到正常的<code>PBR</code>模型上就大功告成了：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vec3 albedo = <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">texture</span>(uAlbedoMap, vTexCoords).rgb,<span class="hljs-built_in">vec3</span>(<span class="hljs-number">2.2</span>));<br><br>vec3 N = <span class="hljs-built_in">normalize</span>(vNormal);<br>vec3 V = <span class="hljs-built_in">normalize</span>(uCameraPos - vWorldPos);<br>vec3 R = <span class="hljs-built_in">reflect</span>(-V, N);<br><br>vec3 F0 = <span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.04</span>); <br>F0 = <span class="hljs-built_in">mix</span>(F0, albedo, uMetallic);<br>vec3 Lo = <span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0</span>);<br><span class="hljs-keyword">for</span> (uint i = <span class="hljs-number">0u</span>;i &lt; <span class="hljs-number">4u</span>;++i)&#123;<br>    vec3 L = <span class="hljs-built_in">normalize</span>(uLightPos[i] - vWorldPos);<br>    vec3 H = <span class="hljs-built_in">normalize</span>(V + L);<br>    <span class="hljs-comment">// float distance = length(uLightPos[i] - vWorldPos);</span><br>    <span class="hljs-comment">// float attenuation = 1.0 / (distance * distance); </span><br>    vec3 radiance = uLightColors[i] * <span class="hljs-number">1.0</span>;<br>    <span class="hljs-comment">//Cook-Torrance BRDF</span><br>    <span class="hljs-type">float</span> NDF = <span class="hljs-built_in">DistributionGGX</span>(N, H, uRoughness);   <br>    <span class="hljs-type">float</span> G   = <span class="hljs-built_in">GeometrySmith</span>(N, V, L, uRoughness); <br>    vec3 F    = <span class="hljs-built_in">fresnelSchlick</span>(F0, V, H);<br>    <span class="hljs-type">float</span> NdotL = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(N,L),<span class="hljs-number">0.0</span>);<br>    <span class="hljs-type">float</span> NdotV = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(N,V),<span class="hljs-number">0.0</span>);<br>    vec3 numerator    = NDF * G * F; <br>    <span class="hljs-type">float</span> denominator = <span class="hljs-built_in">max</span>((<span class="hljs-number">4.0</span> * NdotL * NdotV), <span class="hljs-number">0.0000001</span>);<br>    vec3 specular = numerator / denominator;<br>    <span class="hljs-comment">//Reference opengl pbr</span><br>    vec3 diffuse = (<span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0</span>)-F) * (<span class="hljs-number">1.0</span> - uMetallic) * albedo / PI;<br>    <span class="hljs-comment">// Lo += ( diffuse + specular) * radiance * NdotL;</span><br>    Lo += (specular) * radiance * NdotL;<br>&#125;<br>...<br>vec3 color = ambient + Lo;<br><span class="hljs-comment">// HDR tonemapping</span><br>color = color / (color + <span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0</span>));<br><span class="hljs-comment">// gamma correct</span><br>color = <span class="hljs-built_in">pow</span>(color, <span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0</span>/<span class="hljs-number">2.2</span>)); <br>FragColor = <span class="hljs-built_in">vec4</span>(color, <span class="hljs-number">1.0</span>);<br></code></pre></td></tr></table></figure>为了对比<code>kulla Conty</code>方法这里吧<code>diffuse</code>项去掉。一切顺利的话，会得到下面的效果：<br /><img src="/img/00018/image-7.png" alt="12" /></p><h1 id="kulla-conty-approximation">Kulla Conty Approximation</h1><h2 id="预计算eμ和e_avg">预计算E(μ)和E_avg</h2><p>在引入<code>Kulla Conty</code>方法之前，我们看下<code>Cook-Torrance</code>反射方程的<code>G</code>项：<br /><img src="/img/00018/image-8.png" alt="13" /><br /><code>G</code>项考虑了微表面模型的自遮挡现象，在垂直角度看微表面时，几乎没有自遮挡现象，而在掠射角方向看向微表面时，自遮挡现象就会很严重，这是符合物理现象的。但是<code>G</code>项只考虑了光线在微表面上一次反射后的结果，这就导致必定会有一部分参与后续弹射的光线未被考虑进去，当粗糙度越高，沟壑越大后续弹射的光线占比越大能量损失就越多。而<code>kulla conty</code>方法就是为了弥补这部分损失的能量。</p><p>考虑<code>Kulla Conty</code>方法时，首先我们需要知道有多少能量丢失了，如果只考虑一次反射，那丢失的能量就是<code>1 - 一次反射</code>。而微表面反射模型本来也就是只考虑了一次的反射，我们假设所有入射方向<code>Li</code>的<code>radiance</code>都为<code>1</code>，则一次反射后我们能看到的能量为：<span class="math display">\[E(p,w_o)=\int_{\Omega+}\frac{DG}{4(w_o\cdot n)(w_i\cdot n)}n\cdotw_idw_i \tag{25}\]</span>由于这里考虑的全反射，<code>F</code>自然就<code>1</code>，然后我们设<code>μi=cos(wi)</code>:<br /><span class="math display">\[E(\mu_o)=\int_{0}^{2\pi}\int_{0}^{1}f(\mu_o,\mu_i,\phi)\mu_id\mu_id\phi\tag{26}\]</span>这里<code>θ</code>由<code>π/2</code>到<code>0</code>。闫老师课上讲的是用<code>sinθ</code>去替换，但是后面计算<code>sinθ</code>说不通，而不论<code>sinθ</code>替换还是<code>conθ</code>，其推导出的公式都是一样，不同的是<code>sinθ</code>，<code>θ</code>由<code>0</code>到<code>π/2</code>。</p><p>得到了<code>E(μo)</code>后，那我们就可以设计另一个<code>BRDF</code>使得其积分的结果为<code>1-E(μo)</code>，然后将结果加到原有的<code>BRDF</code>上面，这样就不会有能量损失了。<br />这个新设计的<code>BRDF</code>就是：<br /><span class="math display">\[f_{ms}(\mu_o,\mu_i)=\frac{(1-E(\mu_o))(1-E(\mu_i))}{\pi(1-E_{avg})}\tag{27}\]</span>其中<code>E_avg</code>是函数<code>E(μ)</code>在区间<code>[0,1]</code>的平均值：<br /><span class="math display">\[\begin{align}E_{avg}=\frac{\int_{0}^{1}E(\mu)\mu d\mu}{\int_{0}^{1}\mu d\mu} \\=2\int_{0}^{1}E(\mu)\mu d\mu \tag{28}\end{align}\]</span> 其正确性参考课堂上给的过程： <img src="/img/00018/image-9.png"alt="14" /><br />该新设计的<code>BRDF</code>中有两个积分值，我们同样采用打表的形式，把积分值存到一张纹理中。<code>E(μ)</code>的积分值我们同样使用重要性采样来保证结果的正确性，其代码实现如下：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Vec3f <span class="hljs-title">IntegrateBRDF</span><span class="hljs-params">(Vec3f V, <span class="hljs-type">float</span> roughness)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> sample_count = <span class="hljs-number">1024</span>;<br>    <span class="hljs-type">float</span> A = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-type">float</span> B = <span class="hljs-number">0.0</span>;<br>    Vec3f N = <span class="hljs-built_in">Vec3f</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sample_count; i++) &#123;<br>        Vec2f Xi = <span class="hljs-built_in">Hammersley</span>(i, sample_count);<br>        Vec3f H = <span class="hljs-built_in">ImportanceSampleGGX</span>(Xi, N, roughness);<br>        Vec3f L = <span class="hljs-built_in">normalize</span>(H * <span class="hljs-number">2.0f</span> * <span class="hljs-built_in">dot</span>(V, H) - V);<br>        <span class="hljs-type">float</span> NoL = std::<span class="hljs-built_in">max</span>(L.z, <span class="hljs-number">0.0f</span>);<br>        <span class="hljs-type">float</span> NoH = std::<span class="hljs-built_in">max</span>(H.z, <span class="hljs-number">0.0f</span>);<br>        <span class="hljs-type">float</span> VoH = std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(V, H), <span class="hljs-number">0.0f</span>);<br>        <span class="hljs-type">float</span> NoV = std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(N, V), <span class="hljs-number">0.0f</span>);<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> To calculate (fr * ni) / p_o here - Bonus 1</span><br>        <span class="hljs-type">float</span> Fc = <span class="hljs-built_in">pow</span>(<span class="hljs-number">1.0f</span> - VoH, <span class="hljs-number">5.0f</span>);<br>        <span class="hljs-type">float</span> G = <span class="hljs-built_in">GeometrySmith</span>(roughness, NoV, NoL);<br>        <span class="hljs-type">float</span> G_Vis  = VoH * G / (NoV * NoH);<br><br>        <span class="hljs-comment">// //no split sum </span><br>        <span class="hljs-comment">// A += G_Vis;</span><br><br>        <span class="hljs-comment">// Split Sum - Bonus 2</span><br>        A += (<span class="hljs-number">1.0</span> - Fc) * G_Vis;<br>        B += Fc * G_Vis;<br>    &#125;<br>    <span class="hljs-comment">// return &#123; A / sample_count, A / sample_count, A / sample_count &#125;; // No split sum version</span><br>    <span class="hljs-keyword">return</span> &#123; A / sample_count, B / sample_count, <span class="hljs-number">0.0</span> &#125;;  <span class="hljs-comment">// Split sum</span><br>&#125;<br></code></pre></td></tr></table></figure>其实这里严谨来说不叫<code>Split Sum</code>，该方法是对光照的剥离，我在上面章节有提到。但是作业要求有<code>Split Sum</code>的提高部分，我猜测应该是想让我们这样实现吧。但是仔细考虑的话其实也没必要这么实现，因为计算一次反射的能量，其<code>Fresenl</code>项为<code>1</code>即全反射，这里也不需要将<code>F0</code>剥离来使参数降维。就这样吧，这样得到的纹理如下：<br />Split Sum<br /><img src="/img/00018/image-10.png" alt="15" /><br />Not Split Sum<br /><img src="/img/00018/image-11.png" alt="16" /></p><p><code>E_avg</code>的预计算就比较简单了，代码如下：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Vec3f <span class="hljs-title">IntegrateEmu</span><span class="hljs-params">(Vec3f V, <span class="hljs-type">float</span> roughness, <span class="hljs-type">float</span> NdotV, Vec3f Ei)</span> </span>&#123;<br>    Vec3f Eavg = <span class="hljs-built_in">Vec3f</span>(<span class="hljs-number">0.0f</span>);<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> sample_count = <span class="hljs-number">1024</span>;<br>    Vec3f N = <span class="hljs-built_in">Vec3f</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sample_count; i++) &#123;<br>        Vec2f Xi = <span class="hljs-built_in">Hammersley</span>(i, sample_count);<br>        Vec3f H = <span class="hljs-built_in">ImportanceSampleGGX</span>(Xi, N, roughness);<br>        Vec3f L = <span class="hljs-built_in">normalize</span>(H * <span class="hljs-number">2.0f</span> * <span class="hljs-built_in">dot</span>(V, H) - V);<br>        <span class="hljs-type">float</span> NoL = std::<span class="hljs-built_in">max</span>(L.z, <span class="hljs-number">0.0f</span>);<br>        <span class="hljs-comment">// float pdf = 1;//跟roughness没关系</span><br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> To calculate Eavg here</span><br>        Eavg +=  Ei * <span class="hljs-number">2.0f</span> * NoL ;<span class="hljs-comment">//Ei * 2.0f * NoL, NoL : cos thetai</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> Eavg / sample_count;<br>&#125;<br></code></pre></td></tr></table></figure> 得到纹理如下：<br />Split Sum<br /><img src="/img/00018/image-12.png" alt="17" /><br />Not Split Sum<br /><img src="/img/00018/image-13.png" alt="18" /></p><h2 id="完成kulla-conty-approximation">完成Kulla ContyApproximation</h2><p>我们拿到已经预计算好的<code>E(μ)</code>和<code>E_avg</code>，现在就可以将新设计的<code>BRDF</code>积分值算出来了，代码实现如下：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//split sum</span><br><span class="hljs-function">vec3 <span class="hljs-title">MultiScatterBRDF</span><span class="hljs-params">(<span class="hljs-type">float</span> NdotL, <span class="hljs-type">float</span> NdotV, vec3 F)</span></span><br><span class="hljs-function"></span>&#123;<br>  vec3 albedo = <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">texture</span>(uAlbedoMap, vTexCoords).rgb,<span class="hljs-built_in">vec3</span>(<span class="hljs-number">2.2</span>));<br><br>  <span class="hljs-comment">// A split-sum result in which R-channel repesent F interger term</span><br>  vec3 E_o = <span class="hljs-built_in">texture</span>(uKullaContyBrdflut, <span class="hljs-built_in">vec2</span>(NdotL, uRoughness)).xyz;<br>  vec3 E_i = <span class="hljs-built_in">texture</span>(uKullaContyBrdflut, <span class="hljs-built_in">vec2</span>(NdotV, uRoughness)).xyz;<br>  <span class="hljs-comment">// Split sum result add here.</span><br>  vec3 Emu_o = F * E_o.x + <span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0</span>) * E_o.y;<br>  vec3 Emu_i = F * E_i.x + <span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0</span>) * E_i.y;<br>  vec3 E_avg = <span class="hljs-built_in">texture</span>(uKullaContyEavglut, <span class="hljs-built_in">vec2</span>(<span class="hljs-number">0</span>, uRoughness)).xyz;<br>  vec3 E_avgss = F * E_avg.x + <span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0</span>) * E_avg.y;<br>  ... <br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> To calculate fms and missing energy here</span><br>  vec3 F_ms = (<span class="hljs-number">1.0</span> - Emu_o) * (<span class="hljs-number">1.0</span> - Emu_i) / (PI * (<span class="hljs-number">1.0</span> - E_avgss));<br>  ...<br>  <span class="hljs-keyword">return</span> F_ms;<br>&#125;<br></code></pre></td></tr></table></figure>目前来说，还只能补偿<code>albedo</code>为<code>1</code>情况下的能量。如果物体本身自带颜色，那还要考虑因为物体本身吸收能量而引起的能量损失。首先要定一个平均<code>Fresenl</code>项，来表示不同入射方向下打到微表面，平均被反射出去的能量占比多少。公式如下：<br /><span class="math display">\[\begin{align}F_{avg}=\frac{\int_{0}^{1}F(\mu)\mu d\mu}{\int_{0}^{1}\mu d\mu} \\=2\int_{0}^{1}F(\mu)\mu d\mu \tag{29}\end{align}\]</span> 这篇<ahref="https://blog.selfshadow.com/publications/s2017-shading-course/imageworks/s2017_pbs_imageworks_slides_v2.pdf">论文</a>中，给出了该公式硬编码下的代码：<br /><img src="/img/00018/image-14.png" alt="19" /><br />其中<code>r</code>是<code>albedo</code>，入射角为0度时给的值。<code>g</code>是<code>EdgeTint</code>边缘色调，入射角为80度给的值。这篇<ahref="https://groups.google.com/g/alshaders/c/IZTbaqJMQBo">文章</a>教了我们怎么生成这两个值，我生成了金材质的<code>R</code>和<code>G</code>。<code>R(0.94423,0.77611,0.37217)</code>，<code>G(0.94806,0.86104,0.60760)</code>。</p><p>有了<code>平均Fresenl</code>项，我们现在从新认识一下<code>E_avg</code>：含义为不考虑菲涅尔项时，不同入射角度打到微表面时，离开表面后平均能被你看到的能量。</p><p>那考虑上物体本身会吸收的颜色，我们能看到一次反射后的平均能量为<spanclass="math inline">\(F_{avg}E_{avg}\)</span>，则发生一次反射后没有出去的平均能量为<spanclass="math inline">\(F_{avg}(1-E_{avg})\)</span>，然后这部分能量再次发生反射后我们能看到的平均能量为<spanclass="math inline">\(F_{avg}(1-E_{avg})F_{avg}E_{avg}\)</span>，总结出<code>K</code>次反射后我们能看到的平均能量为<spanclass="math inline">\(F_{avg}^{k}(1-E_{avg})^{k}F_{avg}E_{avg}\)</span>，最后将这部分能量全部加起来，就是一个级数，其数学公式为：<br /><span class="math display">\[((F_{avg}(1-E_{avg}))^{0}+(F_{avg}^{}(1-E_{avg}))^{1}+(F_{avg}(1-E_{avg}))^{k})*F_{avg}E_{avg}\tag{30}\]</span>前面部分是一个等比数列，由于<code>F_avg</code>和<code>1-E_avg</code>都是小于<code>1</code>的数，所以结果为：<br /><span class="math display">\[=\frac{F_{avg}E_{avg}}{1-F_{avg}(1-E_{avg})} \tag{31}\]</span>课堂上的讲解图片如下，需要注意的是这里的<code>one bounce</code>指的是两次反射：<br /><img src="/img/00018/image-16.png" alt="20" /><br />这个公式就是颜色项，我们直接乘上之前没有考虑颜色时的能量补偿项，代码实现如下：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vec3 <span class="hljs-title">MultiScatterBRDF</span><span class="hljs-params">(<span class="hljs-type">float</span> NdotL, <span class="hljs-type">float</span> NdotV)</span></span><br><span class="hljs-function"></span>&#123;<br>  vec3 albedo = <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">texture</span>(uAlbedoMap, vTexCoords).rgb,<span class="hljs-built_in">vec3</span>(<span class="hljs-number">2.2</span>));<br>  vec3 E_o = <span class="hljs-built_in">texture</span>(uKullaContyBrdflut, <span class="hljs-built_in">vec2</span>(NdotL, uRoughness)).xyz;<br>  vec3 E_i = <span class="hljs-built_in">texture</span>(uKullaContyBrdflut, <span class="hljs-built_in">vec2</span>(NdotV, uRoughness)).xyz;<br>  vec3 E_avg = <span class="hljs-built_in">texture</span>(uKullaContyEavglut, <span class="hljs-built_in">vec2</span>(<span class="hljs-number">0</span>, uRoughness)).xyz;<br>  <span class="hljs-comment">//gold</span><br>  vec3 edgetint = <span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.94806</span>,<span class="hljs-number">0.86104</span>,<span class="hljs-number">0.60760</span>);<br>  vec3 F_avg = <span class="hljs-built_in">AverageFresnel</span>(albedo, edgetint);<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> To calculate fms and missing energy here</span><br>  vec3 F_ms = (<span class="hljs-number">1.0</span> - E_o) * (<span class="hljs-number">1.0</span> - E_i) / (PI * (<span class="hljs-number">1.0</span> - E_avg));<br>  vec3 F_add = F_avg * E_avg / (<span class="hljs-number">1.0</span> - F_avg * (<span class="hljs-number">1.0</span> - E_avg));<br>  <span class="hljs-keyword">return</span> F_add * F_ms;<br>&#125;<br></code></pre></td></tr></table></figure> 效果如下：<br /><img src="/img/00018/image-15.png" alt="21" /></p>]]></content>
    
    
    <categories>
      
      <category>Games202</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Games202 Hw3 Screen Space Ray Tracing</title>
    <link href="/2023/06/10/00017.%20Games202%20Hw3/"/>
    <url>/2023/06/10/00017.%20Games202%20Hw3/</url>
    
    <content type="html"><![CDATA[<h1 id="效果图">效果图</h1><p>由于测试时我电脑的GPU是办公本的核显（GPU AMD Radeon(TM)530），帧率很低，我就在比较简单的环境（cube1）下比较它们的纯镜面反射差异。</p><p>World Space SSR<br /><img src="/img/00017/world-fps.png" alt="1" /><br />Efficient GPU SSR<br /><img src="/img/00017/texture-fps.png" alt="2" /><br />Hierarchical-Z SSR<br /><img src="/img/00017/hiz-fps.png" alt="3" /><br />可以看到<code>Hierarchical-Z SSR</code>的帧率最高，是<code>World Space SSR</code>帧率的4倍，其次是<code>Efficient GPU SSR</code>是<code>World Space SSR</code>帧率的2倍。</p><h1 id="作业总览">作业总览</h1><ol type="1"><li>实现直接光照。<br /></li><li>实现Screen Space Ray Tracing。<br /></li><li>实现间接光照。<br /></li><li>Bonus 1：实现Mipmap优化的 Screen Space Ray Tracing。</li></ol><p>个人扩展：<code>Efficient GPU Screen-Space Ray Tracing</code></p><h1 id="源码">源码</h1><p>暂未公开。</p><h1 id="前言">前言</h1><p>本文重点放在算法本身，源码中相关地方注释很明确，对于框架的理解不再做过多解释。<br />本次SSR算法总共有三种，分别World Space Ray Marching SSR,<ahref="https://jcgt.org/published/0003/04/04/paper.pdf">Efficient GPUSSR</a>和<ahref="https://sugulee.wordpress.com/2021/01/19/screen-space-reflections-implementation-and-optimization-part-2-hi-z-tracing-method/">Hierarchical-ZSSR</a>。</p><h1 id="实现">实现</h1><h2 id="world-space-ray-marching-ssr">World Space Ray Marching SSR</h2><p>本次作业的基础部分比较简单，算法本身并不复杂，所以这里就附带将<code>SSR Pass</code>的准备工作一并讲一下，这也为后面的算法做好准备。</p><h3 id="直接光照">直接光照</h3><p>我们先看下渲染方程，这里以<code>SSAO</code>为例讲解一下<code>Visibility</code>怎么处理：<br /><img src="/img/00017/image.png" alt="4" /><br />通过上图所说的<code>The RTR Approximation</code>，我们可以得到<code>Visibility</code>拆出后的方程：<br /><span class="math display">\[\begin{align}&amp;L_o(p,w_o)=\int_{\Omega+}L_i(p,w_i)f_r(p,w_i,w_o)V(p,w_i)\cos\theta_idw_i \\&amp; \approx \frac{\rho}{\pi}\cdotL_i(p)\cdot\pi\cdot\frac{\int_{\Omega+}V(p,w_i)\cos\theta_i dw_i}{\pi}\tag{1}\end{align}\]</span>但<code>SSAO</code>考虑的是<code>diffuse</code>物体局部范围内不带颜色的全局光照，其积分域在各个方向上都可能有贡献，所以这里要算积分值。<br />而我们要实现的直接光照是来自平行光，平行光和点光源的一个重要特性：<br />光源的方向是确定的，也就是说平行光和点光源到着色点只会有一条光线有贡献，其他方向上的贡献为<code>0</code>。那我们也就不用积分了，上述渲染方程直接为：<br /><span class="math display">\[\begin{align}L_o(p,w_o)=L_i(p,w_i)f_r(p,w_i,w_o)V(p,w_i)\cos\theta_i\end{align} \tag{2}\]</span> 所以代码实现就简单了，如下：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//直接光照</span><br><span class="hljs-comment">//L = V * Le * brdf * cos</span><br>vec3 L_Normal = <span class="hljs-built_in">GetGBufferNormalWorld</span>(screenUV);<br>L = <span class="hljs-built_in">EvalDiffuse</span>(screenUV) * <span class="hljs-built_in">EvalDirectionalLight</span>(screenUV) * <span class="hljs-built_in">max</span>(<span class="hljs-number">0.</span>, <span class="hljs-built_in">dot</span>(L_Normal, wi));<br></code></pre></td></tr></table></figure><code>V</code>项包含在<code>EvalDirectionalLight</code>函数中。</p><p>可以看到<code>Normal</code>等信息是从<code>Gbuffer</code>中获得的，<code>Gbuffer</code>纹理可以理解成是帧缓冲的<code>Color Attachment</code>，我们现在创建一个帧缓冲，并为它提供<code>4</code>个<code>Color Attachment</code>:<br /><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FBO</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">gl, GBufferNum, width, height</span>)&#123;<br>        ...<br>        <span class="hljs-keyword">function</span> <span class="hljs-title function_">CreateAndBindColorTargetTexture</span>(<span class="hljs-params">fbo, attachment, width, height</span>) &#123;<br>            <span class="hljs-comment">//创建纹理对象并设置其尺寸和参数</span><br>            <span class="hljs-keyword">var</span> texture = gl.<span class="hljs-title function_">createTexture</span>();<br>            ...<br>            gl.<span class="hljs-title function_">bindTexture</span>(gl.<span class="hljs-property">TEXTURE_2D</span>, texture);<br>            gl.<span class="hljs-title function_">texImage2D</span>(gl.<span class="hljs-property">TEXTURE_2D</span>, <span class="hljs-number">0</span>, gl.<span class="hljs-property">RGBA32F</span>, width, height, <span class="hljs-number">0</span>, gl.<span class="hljs-property">RGBA</span>, gl.<span class="hljs-property">FLOAT</span>, <span class="hljs-literal">null</span>);<br>            ...<br>            gl.<span class="hljs-title function_">framebufferTexture2D</span>(gl.<span class="hljs-property">FRAMEBUFFER</span>, attachment, gl.<span class="hljs-property">TEXTURE_2D</span>, texture, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> texture;<br>        &#125;;<br>        ...<br>        <span class="hljs-comment">//创建帧缓冲区对象并绑定</span><br>        <span class="hljs-keyword">var</span> framebuffer = gl.<span class="hljs-title function_">createFramebuffer</span>();<br>        gl.<span class="hljs-title function_">bindFramebuffer</span>(gl.<span class="hljs-property">FRAMEBUFFER</span>, framebuffer);<br>        <span class="hljs-comment">//在JavaScript中，对象是动态的，可以随时添加属性和方法</span><br>    framebuffer.<span class="hljs-property">attachments</span> = [];<br>    framebuffer.<span class="hljs-property">textures</span> = []<br>        ...<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-title class_">GBufferNum</span>; i++) &#123;<br>            <span class="hljs-keyword">var</span> attachment = gl.<span class="hljs-property">COLOR_ATTACHMENT0</span> + i;<br>    <span class="hljs-comment">// var texture = CreateAndBindColorTargetTexture(framebuffer, attachment);</span><br>            <span class="hljs-keyword">var</span> texture = <span class="hljs-title class_">CreateAndBindColorTargetTexture</span>(framebuffer, attachment, width, height, <span class="hljs-number">0</span>);<br>    framebuffer.<span class="hljs-property">attachments</span>.<span class="hljs-title function_">push</span>(attachment);<br>    framebuffer.<span class="hljs-property">textures</span>.<span class="hljs-title function_">push</span>(texture);<br><br>            <span class="hljs-keyword">if</span>(gl.<span class="hljs-title function_">checkFramebufferStatus</span>(gl.<span class="hljs-property">FRAMEBUFFER</span>) != gl.<span class="hljs-property">FRAMEBUFFER_COMPLETE</span>)<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gl.<span class="hljs-title function_">checkFramebufferStatus</span>(gl.<span class="hljs-property">FRAMEBUFFER</span>));<br>    &#125;<br>    <span class="hljs-comment">// * Tell the WEBGL_draw_buffers extension which FBO attachments are</span><br>    <span class="hljs-comment">//   being used. (This extension allows for Multiple Render Targets.)</span><br>        gl.<span class="hljs-title function_">drawBuffers</span>(framebuffer.<span class="hljs-property">attachments</span>);<br>        ...<br>        <span class="hljs-keyword">return</span> framebuffer;<br>    &#125;<br>&#125;<br>camera.<span class="hljs-property">fbo</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">FBO</span>(gl, <span class="hljs-number">4</span>);<br><span class="hljs-keyword">const</span> directionLight = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectionalLight</span>(lightRadiance, lightPos, lightDir, lightUp, renderer.<span class="hljs-property">gl</span>);<br></code></pre></td></tr></table></figure>其中<code>ShadowBuffer</code>在创建方向光对象时被创建，而<code>Gbuffer</code>附加在相机对象上，<code>Gbuffer</code>包含的<code>4</code>张纹理如下：<br /><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>) &#123;<br>  vec3 kd = <span class="hljs-title function_">texture</span>(uKd, vTextureCoord).<span class="hljs-property">rgb</span>;<br>  <span class="hljs-comment">//albedo </span><br>  <span class="hljs-title class_">Frag0</span> = <span class="hljs-title function_">vec4</span>(kd, <span class="hljs-number">1.0</span>);<br>  <span class="hljs-comment">//depth not linear</span><br>  <span class="hljs-title class_">Frag1</span> = <span class="hljs-title function_">vec4</span>(<span class="hljs-title function_">vec3</span>(gl_FragCoord.<span class="hljs-property">z</span>), <span class="hljs-number">1.0</span>);<br>  <span class="hljs-comment">//world space normal(uNt)</span><br>  <span class="hljs-title class_">Frag2</span> = <span class="hljs-title function_">vec4</span>(<span class="hljs-title class_">ApplyTangentNormalMap</span>(), <span class="hljs-number">1.0</span>);<br>  <span class="hljs-comment">//shadow value 0 or 1</span><br>  <span class="hljs-title class_">Frag3</span> = <span class="hljs-title function_">vec4</span>(<span class="hljs-title function_">vec3</span>(<span class="hljs-title class_">SimpleShadowMap</span>(vPosWorld.<span class="hljs-property">xyz</span>, <span class="hljs-number">1e-4</span>)), <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><code>Gbuffer</code>准备好以后，我们就可以得到直接光的效果了：<br /><img src="/img/00017/image-1.png" alt="5" /></p><h3 id="screen-space-ray-tracing">Screen Space Ray Tracing</h3><p><code>SSR</code>就是在屏幕空间上做实时全局光照的一种方法。也就是在屏幕空间做<code>Ray Tracing</code>，而且我们不需要知道三维物体的三角形以及加速结构等，只需要屏幕空间的信息即<code>Gbuffer</code>的内容就可以完成<code>Ray Tracing</code>，也就是得到场景最外的一层壳，然后和这层壳求交。碰到交点后，还要算交点对<code>ShadingPoint</code>的贡献。</p><p>具体实现步骤如下图所示：<br /><img src="/img/00017/image-2.png" alt="6" /><br />根据<code>BRDF</code>的<code>lobe</code>，生成一根或多根光线，我们假设这里是镜面反射，那就只需要考虑一根反射光线，然后以固定步长沿着反射光线进行步进，每次步进都需要检查步进后光线的深度和场景的深度，直到光线深度大于等于场景深度，就获取该交点处的<code>albedo</code>，然后根据渲染方程进行<code>Shading</code>：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">RayMarch</span><span class="hljs-params">(vec3 ori, vec3 dir, out vec3 hitPos)</span> </span>&#123;<br>  <span class="hljs-type">float</span> step = <span class="hljs-number">0.02</span>;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> totalStepTimes = <span class="hljs-number">1000</span>; <br>  <span class="hljs-type">int</span> curStepTimes = <span class="hljs-number">0</span>;<br>  vec3 stepDir = <span class="hljs-built_in">normalize</span>(dir) * step;<br>  vec3 curPos = ori;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> curStepTimes = <span class="hljs-number">0</span>; curStepTimes &lt; totalStepTimes; curStepTimes++)<br>  &#123;<br>    <span class="hljs-type">float</span> curDepth = <span class="hljs-built_in">GetDepth</span>(curPos);<br>    vec2 curScreenUV = <span class="hljs-built_in">GetScreenCoordinate</span>(curPos);<br>    <span class="hljs-type">float</span> gBufferDepth = <span class="hljs-built_in">GetGBufferDepth</span>(curScreenUV);<br><br>    <span class="hljs-keyword">if</span>(curDepth - gBufferDepth &gt; <span class="hljs-number">0.0001</span>)&#123;<br>      hitPos = curPos;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">//o + t * d</span><br>    curPos += stepDir;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">// test Screen Space Ray Tracing </span><br><span class="hljs-function">vec3 <span class="hljs-title">EvalReflect</span><span class="hljs-params">(vec3 wi, vec3 wo, vec2 uv)</span> </span>&#123;<br>  vec3 worldNormal = <span class="hljs-built_in">GetGBufferNormalWorld</span>(uv);<br>  vec3 relfectDir = <span class="hljs-built_in">normalize</span>(<span class="hljs-built_in">reflect</span>(-wo, worldNormal));<br>  vec3 hitPos;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">RayMarch</span>(vPosWorld.xyz, relfectDir, hitPos))&#123;<br>      vec2 screenUV = <span class="hljs-built_in">GetScreenCoordinate</span>(hitPos);<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">GetGBufferDiffuse</span>(screenUV);<br>  &#125;<br>  <span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">//test</span><br>L = <span class="hljs-built_in">EvalReflect</span>(wi,wo,screenUV);<br></code></pre></td></tr></table></figure>当然我们这里只是测试<code>SSR</code>是否能正常工作，没有考虑渲染方程，所以这里<code>EvalReflect</code>只是简单的返回交点处的<code>Albedo</code>。一切正常的话就会得到下面的图片：<br /><img src="/img/00017/world-space.png" alt="7" /></p><h3 id="间接光照">间接光照</h3><p>有了上面的基础，间接光照就是直接算渲染方程的积分值。<br />在算积分之前，我们需要知道采样方向以及它的<code>Pdf</code>，然后用蒙特卡洛积分来计算。这里对于兰伯特材质直接使用<code>Cos-weighted</code>采样。其过程如下：<br />使用<code>Cos-weighted</code>采样，意味着<code>Pdf</code>和<code>Cos</code>项成正比，即<code>pdf(w)=c*cosθ</code>，则：<br /><span class="math display">\[\begin{align}&amp; \int_{\Omega^+}pdf(w)dw=1 \\&amp; \int_{\Omega^+}c\cdot\cos\theta dw=1 \\&amp; \int_{0}^{2\pi}\int_{0}^{\pi/2}c\cdot\cos\theta\sin\theta d\thetad\phi \\&amp; =\int_{0}^{2\pi}\int_{0}^{\pi/2}c\cdot\sin\theta d\sin\theta d\phi\\&amp; =\int_{0}^{2\pi}c\cdot \frac{\sin^2\theta}{2}\vert_{0}^{\pi/2}d\phi \\&amp; =c\cdot\pi \tag{3}\end{align}\]</span>则c=1/π，pdf=cosθ/π。采样方向还是用逆变换采样的方式来获取：<br />分别求其边缘概率密度函数：<br /><span class="math display">\[\begin{align}&amp; p(\theta)=\int_{0}^{2\pi}\frac{\cos\theta\sin\theta}{\pi}d\phi \\&amp; =2\cos\theta\sin\theta \\&amp; p(\phi)=\int_{0}^{\pi/2}\frac{\cos\theta\sin\theta}{\pi}d\theta \\&amp; =\frac{\sin^2\theta}{2\pi}\vert_{0}^{\pi/2} \\&amp; =\frac{1}{2\pi} \tag{4}\end{align}\]</span> 分别求其累积分布函数：<br /><span class="math display">\[\begin{align}&amp; P(\theta)=\int_{0}^{\theta}2\cos\theta\sin\theta d\theta \\&amp; =\sin^2\theta \\&amp; =1-\cos^2\theta \\&amp; P(\phi)=\int_{0}^{\phi}\frac{1}{2\pi}d\phi \\&amp; =\frac{\phi}{2\pi} \tag{5}\end{align}\]</span> 均匀的从<code>U[0,1]</code>中取出两个随机数<spanclass="math inline">\(X_{1}\)</span>和<spanclass="math inline">\(X_{2}\)</span>,则我们要的采样<code>θ</code>和<code>φ</code>为：<br /><span class="math display">\[\begin{align}\theta=\arccos(\sqrt{1-X_1}) \\\phi=2\pi X_2 \tag{6}\end{align}\]</span> 则采样方向vec(x,y,z)为：<br /><span class="math display">\[\begin{align}&amp; x=\sin\theta\cos\phi=\sqrt{X_1}\cos(2\pi X_2) \\&amp; y=\sin\theta\sin\phi=\sqrt{X_1}\sin(2\pi X_2) \\&amp; z=\cos\theta=\sqrt{1-X_1} \tag{7}\end{align}\]</span> 对应代码如下：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vec3 <span class="hljs-title">SampleHemisphereCos</span><span class="hljs-params">(inout <span class="hljs-type">float</span> s, out <span class="hljs-type">float</span> pdf)</span> </span>&#123;<br>  vec2 uv = <span class="hljs-built_in">Rand2</span>(s);<br>  <span class="hljs-type">float</span> z = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span> - uv.x);<br>  <span class="hljs-type">float</span> phi = uv.y * TWO_PI;<br>  <span class="hljs-type">float</span> sinTheta = <span class="hljs-built_in">sqrt</span>(uv.x);<br>  vec3 dir = <span class="hljs-built_in">vec3</span>(sinTheta * <span class="hljs-built_in">cos</span>(phi), sinTheta * <span class="hljs-built_in">sin</span>(phi), z);<br>  pdf = z * INV_PI;<br>  <span class="hljs-keyword">return</span> dir;<br>&#125;<br></code></pre></td></tr></table></figure>获得的采样方向还需要通过TBN矩阵将其从切线空间转换到世界空间，有了采样方向和<code>Pdf</code>，用蒙特卡洛公式计算积分值：<br /><span class="math display">\[\begin{align}L_o(p,w_o)\approx\frac{1}{N}\sum_{k=1}^{N}\frac{L_{i}(p,w_{i})f_{r}(p,w_{i},w_{o})\cos(\theta_{i})}{p(w_{i},w_{o})}\tag{8}\end{align}\]</span> 代码实现如下：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//直接光照</span><br><span class="hljs-comment">//L = V * Le * brdf * cos</span><br>vec3 L_Normal = <span class="hljs-built_in">GetGBufferNormalWorld</span>(screenUV);<br>L = <span class="hljs-built_in">EvalDiffuse</span>(screenUV) * <span class="hljs-built_in">EvalDirectionalLight</span>(screenUV) * <span class="hljs-built_in">max</span>(<span class="hljs-number">0.</span>, <span class="hljs-built_in">dot</span>(L_Normal, wi));<br><span class="hljs-comment">//间接光</span><br>vec3 L_ind = <span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SAMPLE_NUM; i++)&#123;<br>  <span class="hljs-type">float</span> pdf;<br>  vec3 localDir = <span class="hljs-built_in">SampleHemisphereCos</span>(s, pdf);<br>  vec3 L_ind_Normal = <span class="hljs-built_in">GetGBufferNormalWorld</span>(screenUV);<br>  vec3 b1, b2;<br>  <span class="hljs-built_in">LocalBasis</span>(L_ind_Normal, b1, b2);<br>  vec3 dir = <span class="hljs-built_in">normalize</span>(<span class="hljs-built_in">mat3</span>(b1, b2, L_ind_Normal) * localDir);<br>  <span class="hljs-comment">//world space pos</span><br>  vec3 hitPos;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">RayMarch</span>(worldPos, dir, hitPos))&#123;<br>    vec2 hitScreenUV = <span class="hljs-built_in">GetScreenCoordinate</span>(hitPos);<br>    <span class="hljs-comment">//castRay =  V * Le * brdf * cos.</span><br>    vec3 hitNormal = <span class="hljs-built_in">GetGBufferNormalWorld</span>(hitScreenUV);<br>    vec3 castRay = <span class="hljs-built_in">EvalDiffuse</span>(hitScreenUV) * <span class="hljs-built_in">EvalDirectionalLight</span>(hitScreenUV) * <span class="hljs-built_in">max</span>(<span class="hljs-number">0.</span>, <span class="hljs-built_in">dot</span>(hitNormal, wi));<br>    <span class="hljs-comment">//L_ind += castRay * brdf * cos / pdf</span><br>    L_ind += castRay * <span class="hljs-built_in">EvalDiffuse</span>(screenUV) * <span class="hljs-built_in">max</span>(<span class="hljs-number">0.</span>, <span class="hljs-built_in">dot</span>(L_ind_Normal, dir)) / pdf;<br>  &#125;<br>&#125;<br>L_ind /= <span class="hljs-built_in">float</span>(SAMPLE_NUM);<br>L = L + L_ind;<br></code></pre></td></tr></table></figure>如果一切顺利，<code>World Space Ray Marching SSR</code>的效果如下：<br /><img src="/img/00017/image-3.png" alt="8" /><br />要想得到不错的效果需要用实时光追降噪或者提高采样数量，读者可以自己学完实时光追降噪后应用于此，我电脑不行就不折腾了。下面是洞穴的效果：<br /><img src="/img/00017/image-4.png" alt="9" /></p><h2 id="efficient-gpu-ssr">Efficient GPU SSR</h2><h3 id="digital-differential-analyzer">Digital DifferentialAnalyzer</h3><p><code>Efficient GPU SSR</code>的核心思想是<code>DDA</code>(DigitalDifferential Analyzer)，该算法是用数值方法求解微分方程。<br />我们简单回顾一下<code>DDA</code>思想：<br />给定理想直线的起点坐标为<spanclass="math inline">\(P_0(x_0,y_0)\)</span>终点坐标为<spanclass="math inline">\(P_1(x_1,y_1)\)</span>，用斜截式表示的直线方程为：<br /><span class="math display">\[\begin{align}y=kx+b \tag{9}\end{align}\]</span> 其中直线的斜率为<span class="math inline">\(k=\frac{\Deltay}{\Delta x}\)</span>，<span class="math inline">\(\Deltax=x_1-x_0\)</span>为水平方向位移，<span class="math inline">\(\Deltay=y_1-y_0\)</span>为垂直方向位移，b为y轴上的截距。<br />在DDA算法中，常根据<span class="math inline">\(\Delta x\)</span>和<spanclass="math inline">\(\Deltay\)</span>的大小来确定绘图的主位移方向，在主位移方向上执行的是<spanclass="math inline">\(\pm 1\)</span>，选定<spanclass="math inline">\(\Delta\)</span>较大方向为主方向使得斜率k满足<spanclass="math inline">\(0\leqk\leq1\)</span>（若δy大于δx则交换它们的值）：<br /><img src="/img/00017/image-5.png" alt="10" /><br />确定主方向后，上面9式的微分表示为： <span class="math display">\[\begin{align}\frac{\text{d}y}{\text{d}x}=\frac{\Delta y}{\Delta x}=\frac{\deltay}{\delta x}=k \tag{10}\end{align}\]</span> 其有限差分近似解为：<br /><span class="math display">\[\begin{equation}\left\lbrace\begin{aligned}&amp; x_{i+1}=x_i+\delta x=x_i+1 \\&amp; y_{i+1}=y_i+\delta y=y_i+k\delta x=y_i+k\end{aligned}\right.\end{equation}\]</span> <span class="math inline">\(\Deltax\)</span>每次步进一个像素，根据上一次的点位<spanclass="math inline">\((x_i，y_i)\)</span>就可以确定当前的点<spanclass="math inline">\((x_{i+1},y_{i+1})\)</span>。最后将求得的点位进行<spanclass="math inline">\(\text{int}(y_{i+1}+0.5)\)</span>取整即可得到对应的像素。最后得到的效果如图：<br /><img src="/img/00017/image-6.png" alt="11" /></p><h3 id="an-efficient-gpu-dda-solution">An Efficient GPU DDASolution</h3><p>对于<code>3D</code>空间中大多数反射光线，<code>3D</code>线性采样并不等同于<code>2D</code>线性采样，如下图所示。因此，即使步长已经取的很小，一次步进可能也会跳过屏幕上的多个像素点（这里是误差的主要来源），而且会出现多次步进都是对同一个像素点采样的情况（低效的主要原因）。<br /><img src="/img/00017/image-8.png" alt="12" /><br />右边的效果是我们这一节的主要内容。</p><p>重点是<code>RayMarching</code>函数，该函数的输入是<code>ViewSpace</code>下的反射方向以及它的起点，为了方便这里还是以纯镜面反射为例，全局光照参考<code>World Space Ray Marching SSR</code>可以实现。获取这两个参数的代码如下：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vec3 <span class="hljs-title">EvalReflect</span><span class="hljs-params">(vec3 wo,vec2 screenUV)</span> </span>&#123;<br>  vec3 normalWS = <span class="hljs-built_in">GetGBufferNormalWorld</span>(screenUV);<br>  vec3 reflectDir = <span class="hljs-built_in">normalize</span>(<span class="hljs-built_in">reflect</span>(-wo,normalWS));<br>  vec3 rayOriginWS = vPosWorld.xyz;<br>  vec3 rayEndWS = rayOriginWS + reflectDir * <span class="hljs-number">1.0</span>;<br>  vec3 rayOriginVS = <span class="hljs-built_in">projectToViewSpace</span>(rayOriginWS);<br>  vec3 rayEndVS    = <span class="hljs-built_in">projectToViewSpace</span>(rayEndWS);<br>  vec3 reflectDirVS = <span class="hljs-built_in">normalize</span>(rayEndVS - rayOriginVS);<br>  Ray ray;<br>  ray.Origin = rayOriginVS;<br>  ray.Direction = reflectDirVS;<br><br>  Result result = <span class="hljs-built_in">RayMarching</span>(ray);<br>  <span class="hljs-keyword">if</span>(result.IsHit)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">GetGBufferDiffuse</span>(result.UV / <span class="hljs-built_in">vec2</span>(windowWidth,windowHeight)).xyz;<br>&#125;<br>  <span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><code>3D</code>线段光栅化与<code>2D</code>线段光栅化非常相似。光栅化可以很容易地沿迭代方向对任何属性进行线性插值。如果属性处于齐次空间，则结果将线性插值<code>3D</code>空间中对应的属性值。具体来说，设点<code>Q</code>为射线上的一个<code>3D</code>点，<code>H = M·(Q,1)</code>为其左乘透视投影矩阵<code>M</code>的齐次透视投影。属性<code>k = 1/(H·(0,0,0,1))</code>和<code>Q·k</code>可以在<code>2D</code>中线性插值。因此，如果把该点和齐次<code>w</code>的倒数看作是沿<code>2D</code>线的函数，那么<code>∂(Q·k) / ∂x</code>，<code>∂k / ∂x</code>，<code>∂(Q·k) / ∂y</code>，和<code>∂k / ∂y</code>在屏幕空间中都是常数。</p><p>其中<code>∂(Q·k) / ∂x</code>，<code>∂k / ∂x</code>，<code>∂(Q·k) / ∂y</code>，和<code>∂k / ∂y</code>是函数<code>Q·k</code>的偏微分表示。<br /><code>∂(Q·k) / ∂x</code>表示函数 Q·k 对 x 的偏微分，即改变 x 时 Q·k的变化情况。<br /><code>∂k / ∂x</code>表示函数 k 对 x 的偏微分，即改变 x 时 k的变化情况。<br /><code>∂(Q·k) / ∂y</code>表示函数 Q·k 对 y 的偏微分，即改变 y 时 Q·k的变化情况。<br /><code>∂k / ∂y</code>表示函数 k 对 y 的偏微分，即改变 y 时 k的变化情况。</p><p>在任意<code>2D</code>线段上的点<spanclass="math inline">\(Q(x，y)\)</span>，其对应的三维点为<spanclass="math inline">\(Q&#39;\)</span>:<br /><span class="math display">\[\begin{align}&amp; Q&#39;(x,y)=\frac{(Q·k)(x,y)}{k(x,y)} \\&amp; Q&#39;(z)=\frac{(Q·k)(z)}{k(z)} \tag{11}\end{align}\]</span>有了3D深度信息后，我们就可以和Gbuffer中的深度信息进行比对了。在此之前我们需要知道<code>∂(Q·k) / ∂x</code>，<code>∂k / ∂x</code>偏微分的数值表示，而Gbuffer中的深度信息读取需要另一个偏微分<code>∂y / ∂x</code>。</p><p>在上面有提到在线性情况下，偏微分的值都是常数，则：<br /><span class="math display">\[\begin{align}&amp; \frac{∂(Q·k)}{∂x}=\frac{\Delta(Q·k)}{\Delta x}=\frac{\delta(Q·k)}{\delta x}=dQ \\&amp; \frac{∂k}{∂x}=\frac{\Delta k}{\Delta x}=dK \\&amp; \frac{∂y}{∂x}=\frac{\Delta y}{\Delta x}=dP \tag{12}\end{align}\]</span>为了方便这里常数分别取名为<code>dQ</code>，<code>dK</code>，<code>dP</code>。有了这些信息后，我们想要的属性就可以通过增量来算得了，假设<code>Q</code>为<code>(Q·k)</code>的别名，则<spanclass="math inline">\(Q_{i+1}.z=Q_i.z+δQ_i.z=Q_i.z+\delta x\cdotdQ\)</span>，其中<code>δx==1</code>，相应的<spanclass="math inline">\(k_{i+1}=k_i+dK\)</span>。<br />代码实现如下：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Result</span><br>&#123;<br>  <span class="hljs-type">bool</span> IsHit;<br>  vec2 UV;<br>  ...<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Query</span><span class="hljs-params">(<span class="hljs-type">float</span> depth, vec2 uv)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">float</span> depth1 = -<span class="hljs-built_in">LinearizeDepth</span>(<span class="hljs-built_in">texelFetch</span>(uGDepth,<span class="hljs-built_in">ivec2</span>(uv),<span class="hljs-number">0</span>).r);<br>  <span class="hljs-keyword">return</span> depth &lt; depth1;<br>&#125;<br><span class="hljs-comment">//DDA,数值方法求解微分方程的算法</span><br><span class="hljs-function">Result <span class="hljs-title">RayMarching</span><span class="hljs-params">(Ray ray)</span></span><br><span class="hljs-function"></span>&#123;<br>Result result;<br>  <span class="hljs-comment">//endPos 不能超出近平面，否则反射出的颜色是错误的。超过的话origin沿dir到近平面的距离 = origin到近平面的最短距离 / cosθ，cosθ = dir.z / r;</span><br>  <span class="hljs-type">float</span> rayLength = ((ray.Origin.z + ray.Direction.z * maxDistance) &gt; -uZBufferParams.x) ?<br>  (-uZBufferParams.x - ray.Origin.z) / ray.Direction.z : maxDistance;<br><br>vec3 V0 = ray.Origin;<br>vec3 V1 = ray.Origin + ray.Direction * rayLength;<br>  <span class="hljs-comment">//将viewSpace下的origin和endPos转到ClipSpace</span><br>vec4 H0 = <span class="hljs-built_in">projectToClipSpace</span>(V0);<br>vec4 H1 = <span class="hljs-built_in">projectToClipSpace</span>(V1);<br><br><span class="hljs-type">float</span> k0 = <span class="hljs-number">1.0</span> / H0.w;<br>  <span class="hljs-type">float</span> k1 = <span class="hljs-number">1.0</span> / H1.w;<br>vec3 Q0 = V0 * k0; <br>  vec3 Q1 = V1 * k1;<br><br><span class="hljs-comment">// NDC-space</span><br>  vec2 P0 = H0.xy * k0;<br>  vec2 P1 = H1.xy * k1;<br>vec2 Size = <span class="hljs-built_in">vec2</span>(windowWidth,windowHeight);<br><span class="hljs-comment">//Screen Space</span><br>P0 = (P0 + <span class="hljs-number">1.0</span>) / <span class="hljs-number">2.0</span> * Size;<br>P1 = (P1 + <span class="hljs-number">1.0</span>) / <span class="hljs-number">2.0</span> * Size;<br><br>vec2 Delta = P1 - P0;<br><br>  <span class="hljs-comment">//是否重新排序，我们只处理Delta较大情况</span><br><span class="hljs-type">bool</span> Permute = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(Delta.x) &lt; <span class="hljs-built_in">abs</span>(Delta.y)) &#123; <br>      Permute = <span class="hljs-literal">true</span>;<br>      Delta = Delta.yx; P0 = P0.yx; P1 = P1.yx; <br>  &#125;<br><span class="hljs-type">float</span> StepDir = <span class="hljs-built_in">sign</span>(Delta.x);<br>  <span class="hljs-type">float</span> Invdx = StepDir / Delta.x;<br><br>  <span class="hljs-comment">//偏微分的数值表示法</span><br>  vec3  dQ = (Q1 - Q0) * Invdx;<br>  <span class="hljs-type">float</span> dk = (k1 - k0) * Invdx;<br>  vec2  dP = <span class="hljs-built_in">vec2</span>(StepDir, Delta.y * Invdx);<br><span class="hljs-type">float</span> stride = <span class="hljs-number">2.0</span>;<span class="hljs-comment">//可调</span><br>  dP *= stride; dQ *= stride; dk *= stride;<br>  <span class="hljs-type">float</span> jitter = <span class="hljs-number">1.0</span>;<span class="hljs-comment">//可调</span><br>  P0 += dP * jitter; Q0 += dQ * jitter; k0 += dk * jitter;<br><br><span class="hljs-type">float</span> Step = <span class="hljs-number">0.0</span>;<br><span class="hljs-type">float</span> MaxStep = <span class="hljs-number">1000.0</span>;<br><span class="hljs-type">float</span> EndX = P1.x * StepDir;<br><br><span class="hljs-type">float</span> k = k0;<br>vec3 Q = Q0;<br>  vec2 P = P0;<br><span class="hljs-keyword">for</span>(;((P.x * StepDir) &lt;= EndX) &amp;&amp; <br>      Step &lt; MaxStep;<br>      Step+=<span class="hljs-number">1.0</span>,P += dP, Q.z += dQ.z, k += dk)<br>&#123;<br>result.UV = Permute ? P.yx : P;<br><span class="hljs-type">float</span> depth;<br>    <span class="hljs-comment">//At any 2D point (x,y), the corresponding 3D point is Q‘(x,y)=(Q·k)(x,y) / k(x,y)，Q’(z)=(Q·k)(z) / k(z)</span><br>depth = Q.z / k;<br><span class="hljs-keyword">if</span>(result.UV.x &gt; windowWidth || result.UV.x &lt; <span class="hljs-number">0.0</span> || result.UV.y &gt; windowHeight || result.UV.y &lt; <span class="hljs-number">0.0</span>)<br><span class="hljs-keyword">break</span>;<br>result.IsHit = <span class="hljs-built_in">Query</span>(depth, result.UV);<br>    <span class="hljs-keyword">if</span> (result.IsHit)<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>其中需要注意的一点是，<code>rayLength</code>光线的长度不能超过近平面，否则会出错，光线长度超出了近平面的范围则用下面等式进行约束:<br /><code>origin沿dir到近平面的距离 = origin到近平面的最短距离 / cosθ</code>，<code>cosθ = dir.z / r</code>（cartesianto spherical in tangent space）。<br />如果一切顺利，将会得到下面效果图：<br /><img src="/img/00017/image-7.png" alt="13" /></p><h2 id="hierarchical-z-ssr">Hierarchical-Z SSR</h2><p><code>Hi-Z</code>是为了优化线性步进的算法，因为步长是固定的，但是大部分时间都浪费在了没有碰撞的空间中。<br /><img src="/img/00017/image-9.png" alt="14" /><br />而<code>Hi-Z</code>会根据试探步来判断下一次步长的距离，如果试探步没有与场景相交，那下一次步进的距离就更大，这样求得的交点所使用的步进次数更少，在保证准确率的情况下，效率也得到了极大的提升！</p><p><code>Hi-Z</code>方法创建了一个<code>Depth Mipmap</code>加速结构，称为<code>Hi-Z buffer</code>。该结构本质上是场景深度的四叉树，其中每个四叉树层级中的每个单元格都被设置为上一层级中<code>4</code>个单元格的最小值（或最大值，取决于z轴方向）。<br /><img src="/img/00017/image-10.png" alt="15" /><br />值得注意的是，如果行或列不是偶数，采样需要额外多加一列或一行，如果都是奇数，那么还要额外多考虑一个右上角的像素，如图：<br /><img src="/img/00017/image-11.png" alt="16" /><br />这部分代码比较散就不列出来了，理解了这个过程，实现就不难了。<br /><code>Depth Mipmap</code>可以用另一个<code>Pass</code>来看每一层效果，效果如下：<br /><img src="/img/00017/depth-mipmap.gif" alt="17" /><br />越黑表示越近，纯白色就是深度为<code>1.0</code>的情况无限远。</p><p>有了<code>Depth Mipmap</code>，我们还需要屏幕空间的起点和方向。获取这些数据的过程和上一节差不多，代码实现如下：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vec3 <span class="hljs-title">EvalReflect</span><span class="hljs-params">(vec3 wo,vec2 screenUV)</span> </span>&#123;<br>  <span class="hljs-comment">//从世界坐标中恢复Ts中的原点和反射方向</span><br>  vec3 normalWS = <span class="hljs-built_in">GetGBufferNormalWorld</span>(screenUV);<br>  vec3 reflectDir = <span class="hljs-built_in">normalize</span>(<span class="hljs-built_in">reflect</span>(-wo,normalWS));<br>  vec3 rayOriginWS = vPosWorld.xyz;<br>  vec3 rayEndWS = rayOriginWS + reflectDir * <span class="hljs-number">1.0</span>;<br>  vec3 rayOriginVS = <span class="hljs-built_in">projectToViewSpace</span>(rayOriginWS);<br>  vec3 rayEndVS    = <span class="hljs-built_in">projectToViewSpace</span>(rayEndWS);<br>  vec4 rayOriginCS = <span class="hljs-built_in">projectToClipSpace</span>(rayOriginVS);<br>  vec4 rayEndCS    = <span class="hljs-built_in">projectToClipSpace</span>(rayEndVS);<br>  rayOriginCS = rayOriginCS.xyzw / rayOriginCS.w;<br>  rayEndCS    = rayEndCS.xyzw / rayEndCS.w;<br>  vec3 rayOriginTS = (<span class="hljs-built_in">vec3</span>(rayOriginCS) + <span class="hljs-number">1.0</span>) * <span class="hljs-number">0.5</span>;<br>  vec3 rayEndTS = (<span class="hljs-built_in">vec3</span>(rayEndCS) + <span class="hljs-number">1.0</span>) * <span class="hljs-number">0.5</span>;<br>  vec3 reflectDirTS = <span class="hljs-built_in">normalize</span>(rayEndTS - rayOriginTS);<br>  <span class="hljs-type">float</span> outMaxDistance = reflectDirTS.x &gt;= <span class="hljs-number">0.0</span> ? (<span class="hljs-number">1.0</span> - rayOriginTS.x) / reflectDirTS.x  : -rayOriginTS.x / reflectDirTS.x;<br>  outMaxDistance = <span class="hljs-built_in">min</span>(outMaxDistance, reflectDirTS.y &lt; <span class="hljs-number">0.0</span> ? (-rayOriginTS.y / reflectDirTS.y) : ( (<span class="hljs-number">1.0</span>-rayOriginTS.y) / reflectDirTS.y));<br>  outMaxDistance = <span class="hljs-built_in">min</span>(outMaxDistance, reflectDirTS.z &lt; <span class="hljs-number">0.0</span> ? (-rayOriginTS.z / reflectDirTS.z) : ((<span class="hljs-number">1.0</span>-rayOriginTS.z)/reflectDirTS.z));<br>  SSRay ray;<br>  ray.rayPosInTS = rayOriginTS;<br>  ray.rayDirInTS = reflectDirTS;<br>  ray.maxDistance = outMaxDistance;<br><br>  vec3 hitPos;<br>  vec3 reflectedColor = <span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.</span>);<br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">FindIntersection_HiZ</span>(ray, hitPos)) &#123;<br>    reflectedColor = <span class="hljs-built_in">GetGBufferDiffuse</span>(hitPos.xy);<br>  &#125;<br>  <span class="hljs-keyword">return</span> reflectedColor;<br>&#125;<br></code></pre></td></tr></table></figure>这里<code>outMaxDistance</code>是防止反射终点超出屏幕而浪费性能。</p><p>接下来就是重头戏，<code>FindIntersection_HiZ</code>函数的实现。<br />该函数核心地方就是试探步如何确定下次步进的距离，先说下这里试探步是怎么处理的，我先把相关代码贴出来，以便参考和解释。<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vec3 <span class="hljs-title">intersectDepthPlane</span><span class="hljs-params">(in vec3 o, in vec3 d, <span class="hljs-type">float</span> t)</span></span>&#123;<br>  <span class="hljs-keyword">return</span> o + d * t;<br>&#125;<br>...<br>vec3 start = ss_ray.rayPosInTS;<br>vec3 rayDir = ss_ray.rayDirInTS;<br><span class="hljs-type">float</span> maxTraceDistance = ss_ray.maxDistance;<br>vec3 ray = start;<br><span class="hljs-type">float</span> minZ = ray.z;<br><span class="hljs-type">float</span> maxZ = ray.z + rayDir.z * maxTraceDistance;<br><span class="hljs-type">float</span> deltaZ = (maxZ - minZ);<br>vec3 o = ray;<br>vec3 d = rayDir * maxTraceDistance;<br>...<br><span class="hljs-comment">//步进起点所在单元格的GbufferDepth</span><br><span class="hljs-type">float</span> cell_minZ = <span class="hljs-built_in">getMinimumDepthPlane</span>((oldCellIdx + <span class="hljs-number">0.5</span>) / cellCount, level);    <br><span class="hljs-comment">//试探步：步进起点的深度小于GbufferDepth，则步进到ray.z &gt;= gbufferDepth的地方，这可能会导致新的tmpRay.xy超过1.0，所以这里只是试探步，实际步进是用intersectCellBoundary这个函数完成。</span><br>vec3 tmpRay = (cell_minZ &gt; ray.z) ? <span class="hljs-built_in">intersectDepthPlane</span>(o, d, (cell_minZ - minZ) / deltaZ) : ray;<br></code></pre></td></tr></table></figure>以反射起点<code>ray</code>为例，我们假设这里<code>ray</code>已经向<code>rayDir</code>步进了一小段距离以防止自相交。我们先看下<code>intersectDepthPlane</code>这个函数，以公式<code>o+t*d</code>来确定步进后的点，需要注意的是，这里的<code>d</code>指代的是非单位向量，即：<code>光线终点 - 光线起点</code>。而<code>t</code>则是一个归一化的系数在<code>[0,1]</code>之间，有了<code>t</code>这个系数，这样我们就可以精确的得到起点沿光线步进后的点。<br />下面用图例的形式进一步解释试探步：<br /><img src="/img/00017/image-12.png" alt="18" /><br />可以看到如果起点<code>A</code>要试探地走一步，这一步有可能会直接跨出屏幕（假设白色线条代表屏幕的位置），或者跨过了多个像素，从而错过中间可能会相交的点。我们从试探步中得到的信息就是，它这一步是否跨过了起点<code>A</code>所在的像素，如果跨过了起点<code>A</code>所在的单元格(像素)，那我们就用另一个函数使得起点<code>A</code>步进到下一个单元格。需要注意的是这里的单元格和<code>Depth Mipmap</code>层级挂钩的，层级越大，一个单元格的步长就越大。</p><p>下面我们解释一下如何让起点<code>A</code>步进到下一个单元格，还是先看下相关代码：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">FindIntersection_HiZ</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  in SSRay ss_ray,</span></span><br><span class="hljs-params"><span class="hljs-function">  out vec3 intersection</span></span><br><span class="hljs-params"><span class="hljs-function">)</span> </span>&#123;<br>  vec3 start = ss_ray.rayPosInTS;<br>  vec3 rayDir = ss_ray.rayDirInTS;<br>  <span class="hljs-type">float</span> maxTraceDistance = ss_ray.maxDistance;<br><br>  vec2 crossStep = <span class="hljs-built_in">vec2</span>(rayDir.x &gt;= <span class="hljs-number">0.0</span> ? <span class="hljs-number">1.0</span> : <span class="hljs-number">-1.0</span>, rayDir.y &gt;= <span class="hljs-number">0.0</span> ? <span class="hljs-number">1.0</span> : <span class="hljs-number">-1.0</span>);<br>  vec2 crossOffset = crossStep / <span class="hljs-built_in">vec2</span>(windowWidth,windowHeight) / <span class="hljs-number">128.</span>;<br>  <span class="hljs-comment">//假设reflectDir不与屏幕的宽高平行,如果是向前步进一个单元格的距离，boundary = (rayCell + crossStep )/ cell_count + crossOffset,其中crossOffset &gt; 0.</span><br>  <span class="hljs-comment">//如果是向后步进一个单元格的距离，boundary = (rayCell + vec(0,0) )/ cell_count + crossOffset,其中crossOffset &lt; 0.</span><br>  crossStep = <span class="hljs-built_in">saturate</span>(crossStep);<br><br>  vec3 ray = start;<br>  <span class="hljs-type">float</span> minZ = ray.z;<br>  <span class="hljs-type">float</span> maxZ = ray.z + rayDir.z * maxTraceDistance;<br>  <span class="hljs-type">float</span> deltaZ = (maxZ - minZ);<br><br>  vec3 o = ray;<br>  vec3 d = rayDir * maxTraceDistance;<br><br>  <span class="hljs-type">int</span> startLevel = <span class="hljs-number">2</span>;<br>  <span class="hljs-type">int</span> stopLevel = <span class="hljs-number">0</span>;<br><br>  vec2 startCellCount = <span class="hljs-built_in">vec2</span>(<span class="hljs-built_in">getCellCount</span>(startLevel));<br>  <span class="hljs-comment">//步进起点所在的单元格。</span><br>  vec2 rayCell = <span class="hljs-built_in">getCell</span>(ray.xy, startCellCount);<br>  <span class="hljs-comment">//防止自相交。</span><br>  ray = <span class="hljs-built_in">intersectCellBoundary</span>(o, d, rayCell, startCellCount, crossStep, crossOffset * <span class="hljs-number">128.</span> * <span class="hljs-number">2.</span> );<br><br>  <span class="hljs-type">int</span> level = startLevel;<br>  <span class="hljs-type">int</span> iter = <span class="hljs-number">0</span>;<br>  ...<br><br>  <span class="hljs-keyword">while</span>( level &gt;= stopLevel &amp;&amp; ray.z &lt;= maxZ  &amp;&amp; ++iter &lt; <span class="hljs-number">1000</span>)&#123;<br>    <span class="hljs-comment">//获取纹理分辨率</span><br>    vec2 cellCount = <span class="hljs-built_in">vec2</span>(<span class="hljs-built_in">getCellCount</span>(level));<br>    <span class="hljs-comment">//步进起点所在的单元格索引</span><br>    vec2 oldCellIdx = <span class="hljs-built_in">getCell</span>(ray.xy, cellCount);<br>    <span class="hljs-comment">//步进起点所在单元格的GbufferDepth</span><br>    <span class="hljs-type">float</span> cell_minZ = <span class="hljs-built_in">getMinimumDepthPlane</span>((oldCellIdx + <span class="hljs-number">0.5</span>) / cellCount, level);<br>    <span class="hljs-keyword">if</span>(cell_minZ == <span class="hljs-number">1.0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//解决SSR测试的问题</span><br>    <span class="hljs-comment">//试探步：步进起点的深度小于GbufferDepth，则步进到ray.z &gt;= gbufferDepth的地方，这可能会导致新的tmpRay.xy超过1.0，所以这里只是试探步，实际步进是用intersectCellBoundary这个函数完成。</span><br>    vec3 tmpRay = (cell_minZ &gt; ray.z) ? <span class="hljs-built_in">intersectDepthPlane</span>(o, d, (cell_minZ - minZ) / deltaZ) : ray;<br>    <span class="hljs-comment">//此次试探步终点所在单元格的索引</span><br>    vec2 newCellIdx = <span class="hljs-built_in">getCell</span>(tmpRay.xy, cellCount);<br>    <span class="hljs-comment">//如果到了第0层级，那么说明马上快要到交点处了，比较深度差值，如果差值大于某个阈值（0.0017），我们还需要在当前层级步进一个单元格。</span><br>    <span class="hljs-type">float</span> thickness = level == <span class="hljs-number">0</span> ? (ray.z - cell_minZ) : <span class="hljs-number">0.</span>;<br>    <span class="hljs-comment">//步进起点和终点不在同一个单元格为true。</span><br>    <span class="hljs-type">bool</span> crossed  = (thickness &gt; MAX_THICKNESS)|| <span class="hljs-built_in">crossedCellBoundary</span>(oldCellIdx, newCellIdx);<br>    <span class="hljs-comment">//步进：不在同一个单元格 则寻找最近的一个单元格进行步进,在同一个单元格则步进到试探步的地方。</span><br>    ray = crossed ? <span class="hljs-built_in">intersectCellBoundary</span>(o, d, oldCellIdx, cellCount, crossStep, crossOffset) : tmpRay;<br>    <span class="hljs-comment">//不在同一个单元格 则步进距离再次增大，在同一个单元格则距离减小。</span><br>    level = crossed ? <span class="hljs-built_in">min</span>(MAX_MIPMAP_LEVEL, level + <span class="hljs-number">1</span>): level - <span class="hljs-number">1</span>;<br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>可以看到我们用<code>tmpRay</code>接收了试探步的位置。下面则是通过<code>crossedCellBoundary(oldCellIdx, newCellIdx)</code>来判断<code>tmpRay</code>是否和起点<code>A</code>在相同单元格。如果不在同一个单元格则<code>crossed</code>为<code>true</code>，我们需要用<code>intersectCellBoundary</code>来使起点<code>A</code>步进到下一个单元格。<code>intersectCellBoundary</code>函数的代码实现如下：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vec3 <span class="hljs-title">intersectCellBoundary</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  vec3 o, </span></span><br><span class="hljs-params"><span class="hljs-function">  vec3 d, </span></span><br><span class="hljs-params"><span class="hljs-function">  vec2 rayCell, </span></span><br><span class="hljs-params"><span class="hljs-function">  vec2 cell_count, </span></span><br><span class="hljs-params"><span class="hljs-function">  vec2 crossStep, </span></span><br><span class="hljs-params"><span class="hljs-function">  vec2 crossOffset</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>&#123;<br>  <span class="hljs-comment">//光线所在单元格的下一个单元格</span><br>  vec2 index = rayCell + crossStep;<br>  <span class="hljs-comment">//下一个单元格的边界，根据当前level的单元格数量决定</span><br>  vec2 boundary = index / cell_count;<br>  <span class="hljs-comment">//边界偏移一点，防止步进时落在边界上。</span><br>  boundary += crossOffset;<br>  <span class="hljs-comment">//步进的距离</span><br>  vec2 delta = boundary - o.xy;<br>  <span class="hljs-comment">//标准化</span><br>  delta /= d.xy;<br>  <span class="hljs-comment">//选择最小被标准化后的步进值，代表朝着 离现在光线所在单元格最近的一个单元格 步进</span><br>  <span class="hljs-type">float</span> t = <span class="hljs-built_in">min</span>(delta.x, delta.y);<br>  <span class="hljs-comment">//步进后的点</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">intersectDepthPlane</span>(o, d, t);<br>&#125;<br></code></pre></td></tr></table></figure>我们看下这个函数相关的参数，<code>o</code>为步进起点的位置,<code>d</code>为非单位向量,<code>rayCell</code>为起点A所在的单元格,<code>cell_count</code>为当前DepthMipmap层级的分辨率,<code>crossStep</code>为该单元格向下一个单元格步进的向量,<code>crossOffset</code>为微小偏移防止步进后的点落在边界上。下面我还是用图例的形式进一步解释这个函数如何工作的，这里我们忽略z值：<br /><img src="/img/00017/image-13.png" alt="19" /><br />这里<code>o(0,0.125)</code>为光线起点，<code>endPos(1,0.5)</code>为光线终点，<code>c(0.45,0.3)</code>为步进起点，我们要求的点为<code>nextc</code>。光线起点<code>c</code>所在的单元格<code>rayCell(1,1)</code>，这里因为<code>d(1,0.375)</code>的两个分量都大于零所以<code>crossStep</code>为<code>(1,1)</code>，<code>cell_count</code>则是当前层级的分辨率为<code>(4,4)</code>。<br /><code>rayCell</code>根据<code>crossStep</code>，移动到下一个单元格，即紫色点所在位置（这里忽略了偏移值）。然后除以<code>cell_count</code>得到它们的相对位置即<code>boundary(0.5,0.5)</code>。<br />再通过公式<code>(boundary - o.xy) / d.xy</code>来确定归一化的系数<code>t</code>，通过图例和计算我们很容易的观察到，此时<code>x</code>分量的系数<code>t</code>是<code>y</code>分量的<code>0.5</code>倍，即光线<code>d</code>需要走到<code>endPos</code>，<code>nextc</code>的<code>y</code>分量才和<code>boundary</code>的<code>y</code>分量相等，而这并不是我们想要的，所以我们这里选择系数相对较小的来步进，这样通过公式<code>o+t*d</code>就可以准确得到步进到下一个单元格的相对坐标了（这里红色点和蓝色点应该在光线<code>d</code>上面，这里为了取值方便没有画在一起）。<br />同理当步进起点向反方向步进时，将<code>o</code>和<code>endPos</code>反过来，并且<code>crossStep</code>为<code>(0,0)</code>时也可以得到步进后的点，这里就不再解释了。</p><p>还有最后一件事情没做，我们上面讨论的情况只适用于向前追踪，如果向后追踪，即向<code>nearPlane</code>步进，直接用上面的算法会出错。这是因为试探步函数<code>intersectDepthPlane(o, d, (cell_minZ - minZ) / deltaZ)</code>，处理不了向后步进的情况，我们看下这个<code>cell_minZ</code>变量，如果是向后步进，这个变量的值只会一直递减，相应的系数<code>t</code>也会一直递减，从而无法完成试探步步进的工作。但是幸运的是，向后追踪的情况比向前追踪简单，我们只需要用一个方向布尔变量来控制算法流程。<br />在每次迭代中，我们得到了步进起点所对应的<code>Depth Mipmap</code>场景深度<code>cell_minZ</code>，当场景深度大于步进起点深度时，我们就调用<code>intersectCellBoundary</code>来步进到下一个单元格，而不需要经过试探步来决定。<br />整个<code>Hi-z</code>算法代码实现如下：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">FindIntersection_HiZ</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  in SSRay ss_ray,</span></span><br><span class="hljs-params"><span class="hljs-function">  out vec3 intersection</span></span><br><span class="hljs-params"><span class="hljs-function">)</span> </span>&#123;<br>  vec3 start = ss_ray.rayPosInTS;<br>  vec3 rayDir = ss_ray.rayDirInTS;<br>  <span class="hljs-type">float</span> maxTraceDistance = ss_ray.maxDistance;<br><br>  vec2 crossStep = <span class="hljs-built_in">vec2</span>(rayDir.x &gt;= <span class="hljs-number">0.0</span> ? <span class="hljs-number">1.0</span> : <span class="hljs-number">-1.0</span>, rayDir.y &gt;= <span class="hljs-number">0.0</span> ? <span class="hljs-number">1.0</span> : <span class="hljs-number">-1.0</span>);<br>  vec2 crossOffset = crossStep / <span class="hljs-built_in">vec2</span>(windowWidth,windowHeight) / <span class="hljs-number">128.</span>;<br>  <span class="hljs-comment">//假设reflectDir不与屏幕的宽高平行,如果是向前步进一个单元格的距离，boundary = (rayCell + crossStep )/ cell_count + crossOffset,其中crossOffset &gt; 0.</span><br>  <span class="hljs-comment">//如果是向后步进一个单元格的距离，boundary = (rayCell + vec(0,0) )/ cell_count + crossOffset,其中crossOffset &lt; 0.</span><br>  crossStep = <span class="hljs-built_in">saturate</span>(crossStep);<br><br>  vec3 ray = start;<br>  <span class="hljs-type">float</span> minZ = ray.z;<br>  <span class="hljs-type">float</span> maxZ = ray.z + rayDir.z * maxTraceDistance;<br>  <span class="hljs-type">float</span> deltaZ = (maxZ - minZ);<br><br>  vec3 o = ray;<br>  vec3 d = rayDir * maxTraceDistance;<br><br>  <span class="hljs-type">int</span> startLevel = <span class="hljs-number">2</span>;<br>  <span class="hljs-type">int</span> stopLevel = <span class="hljs-number">0</span>;<br><br>  vec2 startCellCount = <span class="hljs-built_in">vec2</span>(<span class="hljs-built_in">getCellCount</span>(startLevel));<br>  <span class="hljs-comment">//步进起点所在的单元格。</span><br>  vec2 rayCell = <span class="hljs-built_in">getCell</span>(ray.xy, startCellCount);<br>  <span class="hljs-comment">//防止自相交。</span><br>  ray = <span class="hljs-built_in">intersectCellBoundary</span>(o, d, rayCell, startCellCount, crossStep, crossOffset * <span class="hljs-number">128.</span> * <span class="hljs-number">2.</span> );<br><br>  <span class="hljs-type">int</span> level = startLevel;<br>  <span class="hljs-type">int</span> iter = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">bool</span> isBackwardRay = rayDir.z &lt; <span class="hljs-number">0.</span>;<br>  <span class="hljs-type">float</span> Dir = isBackwardRay ? <span class="hljs-number">-1.</span> : <span class="hljs-number">1.</span>;<br>  <span class="hljs-keyword">while</span>( level &gt;= stopLevel &amp;&amp; ray.z * Dir &lt;= maxZ * Dir &amp;&amp; ++iter &lt; <span class="hljs-number">1000</span>)&#123;<br>    <span class="hljs-comment">//获取纹理分辨率</span><br>    vec2 cellCount = <span class="hljs-built_in">vec2</span>(<span class="hljs-built_in">getCellCount</span>(level));<br>    <span class="hljs-comment">//步进起点所在的单元格索引</span><br>    vec2 oldCellIdx = <span class="hljs-built_in">getCell</span>(ray.xy, cellCount);<br>    <span class="hljs-comment">//步进起点所在单元格的GbufferDepth</span><br>    <span class="hljs-type">float</span> cell_minZ = <span class="hljs-built_in">getMinimumDepthPlane</span>((oldCellIdx + <span class="hljs-number">0.5</span>) / cellCount, level);<br>    <span class="hljs-keyword">if</span>(cell_minZ == <span class="hljs-number">1.0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//解决SSR测试的问题</span><br>    <span class="hljs-comment">//试探步：步进起点的深度小于GbufferDepth，则步进到ray.z &gt;= gbufferDepth的地方，这可能会导致新的tmpRay.xy超过1.0，所以这里只是试探步，实际步进是用intersectCellBoundary这个函数完成。</span><br>    vec3 tmpRay = ((cell_minZ &gt; ray.z) &amp;&amp; !isBackwardRay) ? <span class="hljs-built_in">intersectDepthPlane</span>(o, d, (cell_minZ - minZ) / deltaZ) : ray;<br>    <span class="hljs-comment">//此次试探步终点所在单元格的索引</span><br>    vec2 newCellIdx = <span class="hljs-built_in">getCell</span>(tmpRay.xy, cellCount);<br>    <span class="hljs-comment">//如果到了第0层级，那么说明马上快要到交点处了，比较深度差值，如果差值大于某个阈值（0.0017），我们还需要在当前层级步进一个单元格。</span><br>    <span class="hljs-type">float</span> thickness = level == <span class="hljs-number">0</span> ? (ray.z - cell_minZ) : <span class="hljs-number">0.</span>;<br>    <span class="hljs-comment">//步进起点和终点不在同一个单元格为true。</span><br>    <span class="hljs-type">bool</span> crossed  = (isBackwardRay &amp;&amp; (cell_minZ &gt; ray.z))||(thickness &gt; MAX_THICKNESS)|| <span class="hljs-built_in">crossedCellBoundary</span>(oldCellIdx, newCellIdx);<br>    <span class="hljs-comment">//步进：不在同一个单元格 则寻找最近的一个单元格进行步进,在同一个单元格则步进到试探步的地方。</span><br>    <span class="hljs-comment">//前向追踪不适合用在后向追踪，如果是backwardRay，没有试探步。cell_minZ &gt; ray.z为true则步进到下一个单元格level + 1，false则保留当前状态level - 1；</span><br>    ray = crossed ? <span class="hljs-built_in">intersectCellBoundary</span>(o, d, oldCellIdx, cellCount, crossStep, crossOffset) : tmpRay;<br>    <span class="hljs-comment">//不在同一个单元格 则步进距离再次增大，在同一个单元格则距离减小。</span><br>    level = crossed ? <span class="hljs-built_in">min</span>(MAX_MIPMAP_LEVEL, level + <span class="hljs-number">1</span>): level - <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-type">bool</span> intersected = (level &lt; stopLevel);<br>  intersection = intersected ? ray : <span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0</span>);<br>  <span class="hljs-keyword">return</span> intersected;<br>&#125;<br></code></pre></td></tr></table></figure>这里<code>thickness</code>是为了让光线穿过物体。不然我们会得到一些错误的结果。</p><p>这节的内容将的有点<code>HighLevel</code>，更多细节可以参考<ahref="https://sugulee.wordpress.com/2021/01/19/screen-space-reflections-implementation-and-optimization-part-2-hi-z-tracing-method/">Hierarchical-ZSSR</a>。<br />如果一切顺利，就会得到下面的效果：<br /><img src="/img/00017/image-14.png" alt="20" /><br />全局光照如何处理在上面<code>World Space Ray Marching SSR</code>已经讲过，这里只需要照着做就行。</p>]]></content>
    
    
    <categories>
      
      <category>Games202</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Games202 Hw3 Precomputed Radiance Transfer</title>
    <link href="/2023/05/29/00016.%20Games202%20Hw3/"/>
    <url>/2023/05/29/00016.%20Games202%20Hw3/</url>
    
    <content type="html"><![CDATA[<h1 id="效果图">效果图</h1><p><img src="/img/00016/PRT.gif" alt="0" /><br /><code>GI</code>是两次<code>Bounce</code>的效果，<code>DI</code>是直接光照的效果。</p><h1 id="作业总览">作业总览</h1><ol type="1"><li>预计算环境光照。<br /></li><li>预计算<code>Diffuse Unshadowed LT</code>（本文不讲）。<br /></li><li>预计算<code>Diffuse Shadowed LT</code>。<br /></li><li>使用预计算的数据。<br /></li><li><code>Bonus 1</code>：正确实现预计算<code>Diffuse Inter-reflection</code>。<br /></li><li><code>Bonus 2</code>：正确实现<code>SH</code>旋转（未实现）。</li></ol><h1 id="源码">源码</h1><p>暂未公开。</p><h1 id="前言">前言</h1><p>本文重点放在算法本身，源码中相关地方注释很明确，对于框架的理解不再做过多解释。<br />预计算光传输（Precomputed RadianceTransfer）的主要目标是在复杂光照环境下实现实时渲染。它其中的一种方法是基于球面谐波函数（<ahref="https://en.wikipedia.org/wiki/Spherical_harmonics">Sphericalharmonics</a>）来完成环境光的预计算以及光传输的预计算，然后将它们投影后得到的球面谐波系数进行点乘就可以得到全局光照的效果。除了使用球面谐波函数以外还有其他的方法，其中另一种是使用小波变（<ahref="https://en.wikipedia.org/wiki/Wavelet_transform">Wavelettransform</a>）换来进行预计算，小波变换能够更好地处理高频细节。本文会讲球面谐波函数在<code>PRT</code>中的应用以及它的计算方法，如果对小波变换感兴趣可以自行研究。</p><h1 id="实现">实现</h1><p>在讲解作业的实现之前，我们先理解一下<code>Spherical Harmonic</code>和<code>Precomputed Radiance Transfer</code>的关系，以便后面理解上没有困难。</p><h2 id="relationship-between-sh-and-prt">Relationship between SH andPRT</h2><p>球面谐波函数是一系列定义在球面上的二维基函数（关于方向(θ，φ)的函数），这些基函数又由伴随勒让德多项式（<ahref="https://en.wikipedia.org/wiki/Associated_Legendre_polynomials">AssociatedLegendrepolynomials</a>）组成的。伴随勒让德多项式是勒让德方程的一类解，而勒让德方程则是一组偏微分方程，我们就简单理解成一种数学工具就行。<br />后面对球面谐波基函数的数学表达式以<spanclass="math inline">\(B(w)\)</span>来表示。<br />现在的问题是我们该怎么用这个数学工具来帮我们预计算环境光以及光传输。首先我们还是从傅里叶变换说起：<br /><img src="/img/00016/image.png" alt="1" /><br /><code>f(x)</code>函数可以由若干个<code>sin</code>和<code>cos</code>函数来逼近，这里因为<code>f(x)</code>比较特殊，是偶函数，<code>sin</code>项全是零了。这里<code>t,3t,5t...</code>是用来控制<code>cos</code>的频率，而<spanclass="math inline">\(\frac{2A}{\pi}\)</span>这种系数是控制相位，这样由无穷个<code>cos</code>组成的函数可以无限逼近原函数<code>f(x)</code>。一个函数可以表示成其他函数的线性组合，那么我们称些函数为<code>基函数</code>。这里基函数前面乘上一个系数然后加起来就可以得到原函数了:<br /><span class="math display">\[\begin{align}f(x)=\sum_{i}c_i\cdot B_i(x) \tag{1}\end{align}\]</span>这些系数可以由投影操作得到，也就是两种函数<code>f(w)</code>,<code>B(w)</code>的乘积再积分：<br /><span class="math display">\[\begin{align}c_i=\int_{\Omega}f(w)B_i(w)\text{d}w \tag{2}\end{align}\]</span>这里<code>f(w)</code>就是我们要的<code>原函数</code>，<code>B(w)</code>则是一系列<code>球面谐波基函数</code>。只要有两种函数存在这样的一种计算方式，我们也认为这存在一定的滤波意义。而滤波后得到的值，该值的频率由<code>f(w)</code>和<code>B(w)</code>中最低频的函数决定。</p><p>球面谐波基函数的可视化如下：<br /><img src="/img/00016/image-1.png" alt="2" /><br />其中前<code>n</code>层的基函数个数为<code>n^2</code>，颜色表基函数的值，越蓝的地方值越大，越黄的地方其绝对值越大。而频率就是这些值的变化，可以看到下面的函数频率比上面的函数要大。<code>l</code>层数越大用到的基函数越多，就能表示原函数更高频的内容，但是如果原函数本来就很低频，或者因为该函数<code>f(x)</code>与一个很低频的函数<code>g(x)</code>进行乘积再积分，那我们只需要用前几层的基函数就可以恢复出原函数。<br />所以我们用球面谐波基函数来恢复<code>Diffuse</code>物体的光照就非常合适，<code>Diffuse</code>物体的<code>BRDF</code>是一个常数<spanclass="math inline">\(\frac{c}{\pi}\)</span>，而所需要的光照也不需要很高频。实验表明，用前三层的基函数恢复出的光照信息就可以使<code>Diffuse</code>物体的<code>Shading</code>结果非常正确，平均误差小于<code>3%</code>:<br /><img src="/img/00016/image-2.png" alt="3" /><br />需要注意的是球面谐波基函数是用来恢复光照和光传输。</p><p>接下来我们来看一下渲染方程：<br /><img src="/img/00016/image-3.png" alt="4" /><br /><code>Lighting</code>部分和<code>Light transport</code>部分都可以通过球面谐波基函数来近似。对于<code>Lighting</code>部分，由于基函数是固定的，只要我们求出了场景光照对应的基函数系数，在场景切换时，<code>shading</code>结果也可以发生改变。但是<code>Light transport</code>部分，由于预计算时，每一个<code>Shading point</code>看向场景的<code>visibility</code>项需要固定住，所以场景中的物体不能发生改动，这是一个缺点。</p><p>对于这样一个渲染方程，我们假设光源可能发生变化，场景中的物体都不会发生变化，我们可以将<code>Lighting</code>和<code>Light transport</code>投影到球面谐波基函数上，然后进行预计算，得到他们的基函数系数，最后用这些系数来计算<code>shading</code>的结果，这就是<code>PRT</code>做的事情。<br />现在的问题是我们怎么通过这些基函数系数来得到我们想要的<code>Shading</code>结果，我们来深入了解一下渲染方程经过投影的形式，这里以<code>Diffuse</code>物体的渲染方程为例：<br /><img src="/img/00016/image-4.png" alt="5" /><br />这里<span class="math inline">\(f_r(p,w_i,w_o)\)</span>为常数<spanclass="math inline">\(\frac{c}{\pi}\)</span>，整个右边橙色框内的函数，是一个二维的球面函数，因为<code>Diffuse</code>物体在任何方向看到结果都是一样的，即跟<code>W_o</code>无关。将<code>Lighting</code>和<code>Light transport</code>用基函数系数和基函数的表达式带入方程中得：<br /><span class="math display">\[\begin{align}&amp;L_o(p,w_o)=\int_{\Omega+}L_i(p,w_i)f_r(p,w_i,w_o)cos\theta_iV(p,w_i)\text{d}w_i\\&amp; =\int_{\Omega+}\sum_pl_pB_p(w_i)\sum_qt_qB_q(w_i) \\&amp; =\sum_p\sum_ql_pt_q\int_{\Omega+}B_p(w_i)B_q(w_i)\text{d}w_i\tag{3}\end{align}\]</span>这里求和的积分和积分的求和在图形学中大多数情况都是可以交换的。<br />由于球面谐波基函数是一组标准正交基函数，所以其具备一下性质：<br /><span class="math display">\[\begin{align}&amp; \int_{\Omega+}B_i(w)B_j(w)\text{d}w=0,i\neq j \\&amp; \int_{\Omega+}B_i(w)B_j(w)\text{d}w=1,i=j \tag{4}\end{align}\]</span> 所以上面<code>3</code>式可以写成以下形式：<br /><span class="math display">\[\begin{align}&amp; =\sum_p\sum_ql_pt_q\int_{\Omega+}B_p(w_i)B_q(w_i)\text{d}w_i \\&amp; =\sum_il_it_i \tag{5}\end{align}\]</span>如果<code>Lighting</code>和<code>Light transport</code>投影到球面谐波基函数的前<code>3</code>层，则最后得到的基函数系数<code>l_i</code>和<code>t_i</code>,都是<code>9</code>维向量，在最后<code>shading</code>时，像素显示出来的颜色就是它们的点乘结果。</p><h2 id="calculate-the-real-basis-spherical-harmonics">Calculate the realbasis spherical harmonics</h2><p>上面小节我们已经大致理解了球面谐波基函数是如何用来预计算光照和光传输，但是对于这个基函数是怎么来的，我想很多人跟我一样有些疑惑。这一小节我们就来看下具体的一个基函数是怎么样算得的，以后如果需要用到高层基函数，能自己通过程序算出来。下面内容大部分来自维基百科，我只是做好了整理工作方便大家理解。</p><p><code>SH函数</code>通常是在复数域上定义的，而实数域的<code>SH基函数</code>又可以由复数域上定义的<code>SH函数</code>算得，<code>SH基函数</code>则是由<code>伴随勒让德多项式</code>以及<code>归一化系数</code>组成：<br />The real spherical harmonics<br /><img src="/img/00016/image-5.png" alt="6" /><br />The complex spherical harmonics<br /><img src="/img/00016/image-6.png" alt="7" /><br />The real basis spherical harmonics<br /><img src="/img/00016/image-7.png" alt="8" /><br />其中<spanclass="math inline">\(P_{l}^{m}(cos\theta)\)</span>为<code>伴随勒让德多项式</code>，它是<code>勒让德偏微分方程</code>的一组解，其闭式为：<br /><img src="/img/00016/image-8.png" alt="9" /><br />其中后面两个括号括起来的东西叫做<ahref="%5BBinomial%20coefficient%5D(https://en.wikipedia.org/wiki/Binomial_coefficient#Generalization_and_connection_to_the_binomial_series)">二项式系数</a>，其阶乘式如下：<br /><img src="/img/00016/image-9.png" alt="10" /><br />上面式子的来源或定义啥的，我们就不在细究了，我们的目的是要搞懂<code>实域SH基函数</code>怎么算！</p><p>这个伴随勒让德多项式的闭式有点复杂，可以用来计算，但是如果用计算机来算的话这个式子不是很友好，但是在<code>l</code>和<code>m</code>相等时，它可以写成另一种表达式，下面式子<ahref="https://mathworld.wolfram.com/AssociatedLegendrePolynomial.html">来源于此</a>：<br /><span class="math display">\[\begin{align}P_{m}^{m}=(-1)^m(2m-1)!!(1-x^2)^{\frac{m}{2}} \tag{6}\end{align}\]</span> <span class="math display">\[\begin{align}P_{m+1}^{m}=x(2m+1)P_{m}^{m} \tag{7}\end{align}\]</span> 有了这两个递推公式，高层<spanclass="math inline">\(P_{l}^{m}(x)\)</span>，就可以通过程序来递推生成，当然我这里没有用代码来实现这个算法，等到什么时候要用的时候再来实现也不迟😏。</p><p>好了虽然没有用代码来实现这部分内容，但是我可以手算一个例子，来理一下逻辑，就以<code>Real spherical harmonics</code>的<spanclass="math inline">\(Y_{1,-1}\)</span>为例，例子可以在<ahref="https://en.wikipedia.org/wiki/Table_of_spherical_harmonics">这里</a>找到：<br /><img src="/img/00016/image-10.png" alt="11" />将l=1,m=-1带入到上面<code>The real spherical harmonics</code>得：<br /><span class="math display">\[\begin{align}Y_{1,-1}=\frac{i}{\sqrt{2}}(Y_{1}^{-1}+Y_{1}^{1}) \tag{7}\end{align}\]</span> 其中<span class="math inline">\(Y_{1}^{-1}\)</span>和<spanclass="math inline">\(Y_{1}^{1}\)</span>是复数域的<code>SH函数</code>，根据欧拉公式和<code>SH</code>基函数公式以及伴随勒让德公式，分别计算它们：<br /><span class="math display">\[\begin{align}\text{e}^{\pm i\phi}=\cos\phi\pm i\sin\phi \tag{8}\end{align}\]</span> <span class="math display">\[\begin{align}&amp;Y_{1}^{-1}=\frac{1}{\sqrt{2}}(-\sqrt{\frac{3}{4\pi}})\cdot(-(1-\cos^2\theta)^{\frac{1}{2}})\cdot(\cos(\phi)-i\sin(\phi))\\&amp;Y_{1}^{-1}=\frac{1}{2}\sqrt{\frac{3}{2\pi}}\sin\theta\cdot\text{e}^{-i\phi}\tag{9}\end{align}\]</span> <span class="math display">\[\begin{align}&amp;Y_{1}^{1}=-\frac{1}{\sqrt{2}}(-\sqrt{\frac{3}{4\pi}})\cdot(-(1-\cos^2\theta)^{\frac{1}{2}})\cdot(\cos(\phi)+i\sin(\phi))\\&amp;Y_{1}^{1}=-\frac{1}{2}\sqrt{\frac{3}{2\pi}}\sin\theta\cdot\text{e}^{i\phi}\tag{10}\end{align}\]</span>再根据球坐标转笛卡尔坐标公式，得到复数域笛卡尔坐标系下的<code>SH函数</code>：<br /><img src="/img/00016/image-11.png" alt="12" /><br /><span class="math display">\[\begin{align}&amp;Y_{1}^{-1}=\frac{1}{2}\sqrt{\frac{3}{2\pi}}\sin\theta\cdot\text{e}^{-i\phi}\\&amp; Y_{1}^{-1}=\frac{1}{2}\sqrt{\frac{3}{2\pi}}\frac{x-iy}{r} \tag{11}\end{align}\]</span> <span class="math display">\[\begin{align}&amp;Y_{1}^{1}=-\frac{1}{2}\sqrt{\frac{3}{2\pi}}\sin\theta\cdot\text{e}^{i\phi}\\&amp; Y_{1}^{1}=-\frac{1}{2}\sqrt{\frac{3}{2\pi}}\frac{x+iy}{r} \tag{12}\end{align}\]</span>将上面<code>11</code>式和<code>12</code>式带入到<code>7</code>式中：<br /><span class="math display">\[\begin{align}&amp; Y_{1,-1}=\frac{i}{\sqrt{2}}(Y_{1}^{-1}+Y_{1}^{1}) \\&amp;Y_{1,-1}=\frac{i}{\sqrt{2}}(\frac{1}{2}\sqrt{\frac{3}{2\pi}}\frac{x-iy}{r}-\frac{1}{2}\sqrt{\frac{3}{2\pi}}\frac{x+iy}{r})\\&amp; Y_{1,-1}=\frac{1}{\sqrt{2}}\sqrt{\frac{3}{2\pi}}\frac{-i^2y}{r} \\&amp; Y_{1,-1}=\sqrt{\frac{3}{4\pi}}\frac{y}{r} \tag{13}\end{align}\]</span></p><p>这样就得到了图形学中经常用<code>SH函数</code>。我们可以将这个式子硬编码在代码中：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">HardcodedSH1n1</span><span class="hljs-params">(<span class="hljs-type">const</span> Eigen::Vector3d&amp; d)</span> </span>&#123;<br>  <span class="hljs-comment">// -sqrt(3/(4pi)) * y</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-0.488603</span> * d.<span class="hljs-built_in">y</span>();<br>&#125;<br></code></pre></td></tr></table></figure>这里<code>r</code>=1，但是我目前还不知道为什么要加负号😑，可能是<code>cubemap</code>方向向量的坐标系和<code>SH函数</code>的坐标系不同导致的。</p><h2 id="预计算环境光照">预计算环境光照</h2><p>这部分还是根据上面<code>2</code>式投影公式来算环境光照的<code>SH</code>系数，这里将它转换为黎曼和求其积分:<br /><span class="math display">\[\begin{align}&amp; SH_{coeff}=\int_{S}L_{env}(w_i)SH(w_i)\text{d}w_i \\&amp; \widehat{SH_{coeff}}=\sum_iL_{env}(w_i)SH(w_i)\Delta w_i \tag{14}\end{align}\]</span> 这里用黎曼和的方式求积分的好处是，<ahref="https://www.rorydriscoll.com/2012/01/15/cubemap-texel-solid-angle/">有个办法</a>可以精确求出像素投影到单位球上的面积，如图：<br /><img src="/img/00016/image-12.png" alt="13" /><br />我这里简单概述一下它这个方法是怎么处理的。首先我们可以通过框架给的方法求出每个像素对应的向量（未归一化）：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//索引像素对应的方向</span><br>Eigen::Vector3f dir = cubemapDirs[i * width * height + y * width + x];<br></code></pre></td></tr></table></figure> 然后我们就可以得到该向量归一化后的表达式：<br /><span class="math display">\[\begin{align}\vec{p}=\frac{(x,y,1)}{\sqrt{x^2+y^2+1}} \tag{15}\end{align}\]</span> 这个向量的<code>z</code>分量如下：<br /><span class="math display">\[\begin{align}&amp; p_z=\frac{1}{\sqrt{x^2+y^2+1}} \\&amp; =(x^2+y^2+1)^{-\frac{1}{2}} \\&amp; =u^{-\frac{1}{2}}\tag{16}\end{align}\]</span>然后通过链式法则，对它进行求偏导，得到该<code>z</code>分量沿<code>x</code>轴的变化率：<br /><span class="math display">\[\begin{align}&amp;\frac{\partial{p_z}}{\partial{x}}=\frac{\partial{p_z}}{\partial{u}}\frac{\partial{u}}{\partial{x}}\\&amp; =-\frac{x}{(x^2+y^2+1)^{\frac{3}{2}}}\tag{17}\end{align}\]</span>有了<code>z</code>分量的偏导，<code>x</code>分量可以表示为：<br /><span class="math display">\[\begin{align}&amp; p_x=\frac{x}{\sqrt{x^2+y^2+1}} \\&amp; =xp_z\end{align} \tag{18}\]</span> 对其求偏导可以用乘积法则写成以下形式：<br /><span class="math display">\[\begin{align}&amp;\frac{\partial{p_x}}{\partial{x}}=p_z\frac{\partial{x}}{\partial{x}}+x\frac{\partial{p_z}}{\partial{x}}\\&amp; =\frac{y^2+1}{(x^2+y^2+1)^{\frac{3}{2}}}\end{align} \tag{19}\]</span> <code>y</code>分量也可以用相同方式求偏导：<br /><span class="math display">\[\begin{align}&amp; p_y=\frac{y}{\sqrt{x^2+y^2+1}}=yp_z \\&amp;\frac{\partial{p_y}}{\partial{x}}=p_z\frac{\partial{y}}{\partial{x}}+y\frac{\partial{p_z}}{\partial{x}}\\&amp; =-\frac{xy}{(x^2+y^2+1)^{\frac{3}{2}}}\end{align} \tag{19}\]</span> 以相同方式可以求得该向量沿<code>y</code>轴的变化率：<br /><span class="math display">\[\begin{align}&amp;\frac{\partial{\vec{p}}}{\partial{x}}=\frac{(y^2+1,-xy,-x)}{(x^2+y^2+1)^{\frac{3}{2}}}\\&amp;\frac{\partial{\vec{p}}}{\partial{y}}=\frac{(-xy,x^2+1,-y)}{(x^2+y^2+1)^{\frac{3}{2}}}\end{align} \tag{20}\]</span>然后算<code>x</code>轴的变化率叉乘<code>y</code>轴变化率，得到叉乘后的向量，再求它的模就是原点和变化点间的微分面积：<br /><span class="math display">\[\begin{align}&amp;\vec{r}=\frac{\partial{\vec{p}}}{\partial{x}}\times\frac{\partial{\vec{p}}}{\partial{y}}\\&amp; =\frac{(x,y,1)}{(x^2+y^2+1)^2}\end{align} \tag{21}\]</span> <span class="math display">\[\begin{align}&amp; \partial{A}=\sqrt{\vec{r}\cdot\vec{r}} \\&amp; =\frac{1}{(x^2+y^2+1)^{\frac{3}{2}}}\end{align} \tag{22}\]</span>最后一步是在像素空间内对微分面积进行积分，以获得像素投影到单位球上的立体角。我们可以计算原点<code>(0,0)</code>到<code>cubemap</code>上的某个点<code>(s,t)</code>的积分值：<br /><span class="math display">\[\begin{align}&amp;f(s,t)=\int_{y=0}^{t}\int_{x=0}^{s}\frac{1}{(x^2+y^2+1)^{\frac{3}{2}}}\text{d}x\text{d}y\\&amp; =\tan^{-1}\frac{st}{\sqrt{s^2+t^2+1}}\end{align} \tag{23}\]</span>有了这个公式，我们可以通过将两个右对角<code>A</code>和<code>C</code>的面积加在一起，减去左对角<code>B</code>和<code>D</code>的面积来计算任何像素投影到单位球的立体角：<br /><img src="/img/00016/image-13.png" alt="14" /><br />对应的代码实现如下：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">CalcPreArea</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">float</span> &amp;x, <span class="hljs-type">const</span> <span class="hljs-type">float</span> &amp;y)</span></span>&#123;<br>    <span class="hljs-comment">//atan2的优势是可以正确处理异常的情况</span><br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">atan2</span>(x * y, std::<span class="hljs-built_in">sqrt</span>(x * x + y * y + <span class="hljs-number">1.0</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">CalcArea</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">float</span> &amp;u_, <span class="hljs-type">const</span> <span class="hljs-type">float</span> &amp;v_, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;width,</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;height)</span></span>&#123;<br>    <span class="hljs-comment">// transform from [0,1] to [-1,1]</span><br>    <span class="hljs-comment">// ( 0.5 is for texel center addressing)</span><br>    <span class="hljs-type">float</span> u = (<span class="hljs-number">2.0</span> * (u_ + <span class="hljs-number">0.5</span>) / width) - <span class="hljs-number">1.0</span>;<br>    <span class="hljs-type">float</span> v = (<span class="hljs-number">2.0</span> * (v_ + <span class="hljs-number">0.5</span>) / height) - <span class="hljs-number">1.0</span>;<br><br>    <span class="hljs-type">float</span> invResolutionW = <span class="hljs-number">1.0</span> / width;<br>    <span class="hljs-type">float</span> invResolutionH = <span class="hljs-number">1.0</span> / height;<br><br>    <span class="hljs-comment">// u and v are the [-1,1] texture coordinate on the current face.</span><br>    <span class="hljs-comment">// get projected area for this texel</span><br>    <span class="hljs-type">float</span> x0 = u - invResolutionW;<br>    <span class="hljs-type">float</span> y0 = v - invResolutionH;<br>    <span class="hljs-type">float</span> x1 = u + invResolutionW;<br>    <span class="hljs-type">float</span> y1 = v + invResolutionH;<br>    <span class="hljs-type">float</span> angle = <span class="hljs-built_in">CalcPreArea</span>(x0, y0) - <span class="hljs-built_in">CalcPreArea</span>(x0, y1) -<br>                    <span class="hljs-built_in">CalcPreArea</span>(x1, y0) + <span class="hljs-built_in">CalcPreArea</span>(x1, y1);<br><br>    <span class="hljs-keyword">return</span> angle;<br>&#125;<br></code></pre></td></tr></table></figure> 回到上面<code>14</code>式：<br /><span class="math display">\[\begin{align}&amp; \widehat{SH_{coeff}}=\sum_iL_{env}(w_i)SH(w_i)\Delta w_i\end{align}\]</span>有了立体角的面积，框架也提供了环境光的<code>RGB</code>值以及硬编码的<code>SH</code>函数，实现就是下面的代码：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; height; y++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; width; x++)&#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> here you need to compute light sh of each pixel of each face of cubemap </span><br><br>        <span class="hljs-comment">//索引像素对应的方向</span><br>        Eigen::Vector3f dir = cubemapDirs[i * width * height + y * width + x];<br>        <span class="hljs-comment">//像素的索引</span><br>        <span class="hljs-type">int</span> index = (y * width + x) * channel;<br>        <span class="hljs-comment">//RGB值</span><br>        <span class="hljs-function">Eigen::Array3f <span class="hljs-title">Le</span><span class="hljs-params">(images[i][index + <span class="hljs-number">0</span>], images[i][index + <span class="hljs-number">1</span>],</span></span><br><span class="hljs-params"><span class="hljs-function">                            images[i][index + <span class="hljs-number">2</span>])</span></span>;<br><br>        <span class="hljs-comment">// Edit Start</span><br>        <span class="hljs-keyword">auto</span> delta_w = <span class="hljs-built_in">CalcArea</span>(x, y, width, height);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; l &lt;= SHOrder; l++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> m = -l; m &lt;= l; m++) &#123;<br>                <span class="hljs-comment">//获取基函数</span><br>                <span class="hljs-keyword">auto</span> basic_sh_proj = sh::<span class="hljs-built_in">EvalSH</span>(l, m, Eigen::<span class="hljs-built_in">Vector3d</span>(dir.<span class="hljs-built_in">x</span>(), dir.<span class="hljs-built_in">y</span>(), dir.<span class="hljs-built_in">z</span>()).<span class="hljs-built_in">normalized</span>());<br>                <span class="hljs-comment">//计算le在基函数上的投影，并且用黎曼和近似积分</span><br>                SHCoeffiecents[sh::<span class="hljs-built_in">GetIndex</span>(l, m)] += Le * basic_sh_proj * delta_w;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// Edit End</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 最后生成的<code>SHCoeffiecents</code>如下：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    R               G               B<br><span class="hljs-number">1.91613</span>         <span class="hljs-number">1.71772</span>         <span class="hljs-number">1.07797</span><br><span class="hljs-number">-0.0591127</span>      <span class="hljs-number">-0.0574315</span>      <span class="hljs-number">-0.0346851</span><br><span class="hljs-number">-3.8612e-05</span>     <span class="hljs-number">-2.09015e-05</span>    <span class="hljs-number">-1.35017e-05</span><br><span class="hljs-number">0.439589</span>        <span class="hljs-number">-0.431271</span>       <span class="hljs-number">-0.0800766</span><br><span class="hljs-number">-0.0306302</span>      <span class="hljs-number">0.0319348</span>       <span class="hljs-number">0.00328068</span><br><span class="hljs-number">0.0758103</span>       <span class="hljs-number">0.0710374</span>       <span class="hljs-number">0.0591078</span><br><span class="hljs-number">0.311676</span>        <span class="hljs-number">0.269456</span>        <span class="hljs-number">0.309399</span><br><span class="hljs-number">-4.15644e-05</span>    <span class="hljs-number">6.26793e-05</span>     <span class="hljs-number">3.12488e-05</span><br><span class="hljs-number">-0.541544</span>       <span class="hljs-number">-0.468526</span>       <span class="hljs-number">-0.536088</span><br></code></pre></td></tr></table></figure></p><h2 id="预计算光传输">预计算光传输</h2><p>在上一节我们已经将环境光照投影到SH函数上，得到了对应的<code>SHCoeffiecents</code>，剩下的部分对于有自阴影的<code>Shadowed</code>漫反射传输，预计算方程多了一项可见性(Visibilityterm)：<br /><span class="math display">\[\begin{align}L_{DS}=\frac{c}{\pi}\int_{S}V(w_i)max(N_x\cdot w_i,0)\text{d}w_i\end{align} \tag{24}\]</span>对于这个式子，我们还是用蒙特卡洛来求积分，这里<code>S</code>表示整个球，其实我觉得用半球的<code>Cos weight</code>更好，但是当时是直接实现的整球采样，后面就一直没改了。所以现在还是以整球为例来讲解采样过程，<code>Cos weight</code>类似其过程：<br />单位球上的一个采样点落在<code>dw_i</code>的概率密度函数设为<spanclass="math inline">\(P(w_i)\)</span>：<br />对于这个<code>PDF</code>，在整球范围内积分为<code>1</code>，则我们可以得到如下等式：<br /><span class="math display">\[\begin{align}\int_{\phi}\int_{\theta}P(w_i)\text{d}w_i=1\end{align} \tag{25}\]</span>由于<code>dw</code>在整球范围内积分的结果是<code>4πR^2</code>，单位整球则是<code>4π</code>，<code>PDF</code>的值为<code>1/4π</code>，则上述式子可以写成：<br /><span class="math display">\[\begin{align}\int_{\phi}\int_{\theta}\frac{1}{4\pi}\sin\theta\text{d}\theta\text{d}\phi=1\end{align} \tag{26}\]</span> 分别计算它们的边缘概率密度函数：<br /><span class="math display">\[\begin{align}&amp;P(\theta)=\int_{0}^{2\pi}\frac{1}{4\pi}\sin\theta\text{d}\phi=\frac{\sin\theta}{2}\\&amp; P(\phi)=\int_{0}^{\pi}\frac{1}{4\pi}\sin\theta\text{d}\theta \\&amp; =-\frac{1}{4\pi}\cos\theta|_{0}^{\pi} \\&amp; =\frac{1}{2\pi}\end{align} \tag{26}\]</span> 分别计算它们的累积分布函数：<br /><span class="math display">\[\begin{align}&amp; F(\theta)=\int_{0}^{\theta}\frac{\sin\theta}{2}\text{d}\theta \\&amp; =-\frac{\cos\theta}{2}|_{0}^{\theta} \\&amp; =\frac{1-\cos\theta}{2} \\&amp;F(\phi)=\int_{0}^{\phi}\frac{1}{2\pi}\text{d}\phi=\frac{\phi}{2\pi}\end{align} \tag{27}\]</span> 均匀的从<code>U[0,1]</code>中取出两个随机数<spanclass="math inline">\(X_{1}\)</span>和<spanclass="math inline">\(X_{2}\)</span>,则我们要的采样<code>θ</code>和<code>φ</code>为：<span class="math display">\[\begin{align}&amp; F^{-1}(\theta)=\theta=\arccos(1-2X_1) \\&amp; F^{-1}(\phi)=\phi=2\pi X_2\end{align} \tag{27}\]</span> 这种方式得到的采样点如下：<br /><img src="/img/00016/image-14.png" alt="15" /><br />有了采样方向，就可以算积分值了，代码实现如下：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = <span class="hljs-number">0</span>; t &lt; sample_side; t++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = <span class="hljs-number">0</span>; p &lt; sample_side; p++) &#123;<br>        <span class="hljs-comment">//分层采样，使采样点更加均匀。</span><br>        <span class="hljs-type">double</span> x1 = (t + nori::<span class="hljs-built_in">genRandomFloat</span>()) / sample_side;<br>        <span class="hljs-type">double</span> x2 = (p + nori::<span class="hljs-built_in">genRandomFloat</span>()) / sample_side;<br><br>        <span class="hljs-type">double</span> phi = <span class="hljs-number">2.0</span> * M_PI * x1;<br>        <span class="hljs-type">double</span> theta = <span class="hljs-built_in">acos</span>(<span class="hljs-number">2.0</span> * x2 - <span class="hljs-number">1.0</span>);<br><br>        <span class="hljs-type">double</span> func_value = <span class="hljs-built_in">func</span>(phi, theta);<br><br>        <span class="hljs-comment">// evaluate the SH basis functions up to band O, scale them by the</span><br>        <span class="hljs-comment">// function&#x27;s value and accumulate them over all generated samples</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; l &lt;= order; l++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> m = -l; m &lt;= l; m++) &#123;<br>            <span class="hljs-type">double</span> sh = <span class="hljs-built_in">EvalSH</span>(l, m, phi, theta);<br>            <span class="hljs-comment">//蒙特卡洛积分</span><br>            <span class="hljs-type">double</span> pdf = <span class="hljs-number">1.0</span> / (<span class="hljs-number">4</span> * M_PI);<br>            (*coeffs)[<span class="hljs-built_in">GetIndex</span>(l, m)] += <span class="hljs-number">1</span> / M_PI * func_value * sh / pdf / sample_count;<br>        &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><code>func_value</code>就是渲染方程中<code>Cos</code>值，如果顶点向外发射光线时没有被挡住则<code>func_value == dot(N,w)</code>，挡住了就是<code>0</code>。至于这里<code>θ</code>为什么和上面的公式不一样，我当时是直接用的<ahref="https://www.bogotobogo.com/Algorithms/uniform_distribution_sphere.php">这篇文章</a>算出来的结果，现在过来写博客时发现他算错了，不过不影响最后的结果，就是θ值互补。</p><h2 id="预计算间接光传输">预计算间接光传输</h2><p>有了直接光的光传输，间接光的光传输就好办了，但是直接看作业文档给的公式容易被误导，不过好在它下面给出了解释，我这里就不列公式了，看下它的解释：<br />1. 对于每个顶点，计算它的<spanclass="math inline">\(L_{DS}\)</span>，在上一节内容中，我们已经做了这个事情，可以拿来复用。2.从当前顶点发射光线，如果当前光线与其他三角形相交，则在交点处求出重心坐标插值后的球面谐波系数，这个系数就表示间接光照的球面谐波系数，所以这里其实不用算积分值。3. 对于这个反射回来的间接光，乘以几何项<code>dot(N,w_i)</code>。 4.以当前射线为交点，从第<code>2</code>步计算以当前交点为初试顶点的<spanclass="math inline">\(L_{DS}\)</span>，重复这个步骤直到<code>Bounce</code>次数到达预设值，然后结束递归。实现如下：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>std::unique_ptr&lt;std::vector&lt;<span class="hljs-type">double</span>&gt;&gt; <span class="hljs-built_in">computeInterreflectionSH</span>(Eigen::MatrixXf* directTSHCoeffs, <br>                                                            <span class="hljs-type">const</span> Point3f&amp; pos, <span class="hljs-type">const</span> Normal3f&amp; normal, T&amp;&amp; Lds,<br>                                                            <span class="hljs-type">const</span> Scene* scene, <span class="hljs-type">int</span> bounces)<br>&#123;<br>    std::unique_ptr&lt;std::vector&lt;<span class="hljs-type">double</span>&gt;&gt; <span class="hljs-built_in">coeffs</span>(<span class="hljs-keyword">new</span> std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">double</span>&gt;());<br>    coeffs-&gt;<span class="hljs-built_in">assign</span>(SHCoeffLength, <span class="hljs-number">0.0</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coeffs-&gt;<span class="hljs-built_in">size</span>(); i++)&#123;<br>        (*coeffs)[i] += Lds[i];<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (bounces &gt;= m_Bounce)<br>        <span class="hljs-keyword">return</span> coeffs;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> sample_side = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">sqrt</span>(m_SampleCount)));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = <span class="hljs-number">0</span>; t &lt; sample_side; t++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = <span class="hljs-number">0</span>; p &lt; sample_side; p++) &#123;<br>            <span class="hljs-type">double</span> x1 = (t + nori::<span class="hljs-built_in">genRandomFloat</span>()) / sample_side;<br>            <span class="hljs-type">double</span> x2 = (p + nori::<span class="hljs-built_in">genRandomFloat</span>()) / sample_side;<br>            <span class="hljs-type">double</span> phi = <span class="hljs-number">2.0</span> * M_PI * x1;<br>            <span class="hljs-type">double</span> theta = <span class="hljs-built_in">acos</span>(<span class="hljs-number">2.0</span> * x2 - <span class="hljs-number">1.0</span>);<br><br>            Eigen::Array3d d = sh::<span class="hljs-built_in">ToVector</span>(phi, theta);<br>            <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> wi = <span class="hljs-built_in">Vector3f</span>(d.<span class="hljs-built_in">x</span>(), d.<span class="hljs-built_in">y</span>(), d.<span class="hljs-built_in">z</span>());<br>            <span class="hljs-type">double</span> pdf = <span class="hljs-number">1.0</span> / (<span class="hljs-number">4</span> * M_PI);<br>            <span class="hljs-type">double</span> H = wi.<span class="hljs-built_in">normalized</span>().<span class="hljs-built_in">dot</span>(normal);<br>            Intersection its;<br>            <span class="hljs-keyword">if</span> (H &gt; <span class="hljs-number">0.0</span> &amp;&amp; scene-&gt;<span class="hljs-built_in">rayIntersect</span>(<span class="hljs-built_in">Ray3f</span>(pos, wi.<span class="hljs-built_in">normalized</span>()), its))&#123;<br>                MatrixXf normals = its.mesh-&gt;<span class="hljs-built_in">getVertexNormals</span>();<br>                Point3f idx = its.tri_index;<br>                Point3f hitPos = its.p;<br>                Vector3f bary = its.bary;<br>                <span class="hljs-comment">//利用重心坐标插值三角形各顶点的法向量</span><br>                Normal3f hitNormal =<br>                    <span class="hljs-built_in">Normal3f</span>(normals.<span class="hljs-built_in">col</span>(idx.<span class="hljs-built_in">x</span>()).<span class="hljs-built_in">normalized</span>() * bary.<span class="hljs-built_in">x</span>() +<br>                        normals.<span class="hljs-built_in">col</span>(idx.<span class="hljs-built_in">y</span>()).<span class="hljs-built_in">normalized</span>() * bary.<span class="hljs-built_in">y</span>() +<br>                        normals.<span class="hljs-built_in">col</span>(idx.<span class="hljs-built_in">z</span>()).<span class="hljs-built_in">normalized</span>() * bary.<span class="hljs-built_in">z</span>())<br>                    .<span class="hljs-built_in">normalized</span>();<br>                <span class="hljs-comment">//重心坐标插值三角形各顶点的(V * brdf * wiDotN)投影到球谐基函数后得到的coeffs值</span><br>                <span class="hljs-keyword">auto</span> interpolateSH = <br>                        directTSHCoeffs-&gt;<span class="hljs-built_in">col</span>(idx.<span class="hljs-built_in">x</span>()) * bary.<span class="hljs-built_in">x</span>() +<br>                        directTSHCoeffs-&gt;<span class="hljs-built_in">col</span>(idx.<span class="hljs-built_in">y</span>()) * bary.<span class="hljs-built_in">y</span>() +<br>                        directTSHCoeffs-&gt;<span class="hljs-built_in">col</span>(idx.<span class="hljs-built_in">z</span>()) * bary.<span class="hljs-built_in">z</span>();<br>                <span class="hljs-keyword">auto</span> nextBouncesCoeffs = <span class="hljs-built_in">computeInterreflectionSH</span>(directTSHCoeffs, hitPos, hitNormal, interpolateSH ,scene, bounces + <span class="hljs-number">1</span>);<br><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SHCoeffLength; i++)&#123;<br>                    <span class="hljs-comment">//采样到投影后的coeffes乘以cos做权重，这里不是蒙特卡洛积分。</span><br>                    (*coeffs)[i] +=  (*nextBouncesCoeffs)[i] * H / m_SampleCount;<br>                    <span class="hljs-comment">// (*coeffs)[i] += 1 / M_PI * (*nextBouncesCoeffs)[i] * H / pdf / m_SampleCount;//Incorrect method</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> coeffs;<br>&#125;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> leave for bonus</span><br>m_InterTransportSHCoeffs.<span class="hljs-built_in">resize</span>(SHCoeffLength, mesh-&gt;<span class="hljs-built_in">getVertexCount</span>());<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel for</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; mesh-&gt;<span class="hljs-built_in">getVertexCount</span>(); i++)&#123;<br>    <span class="hljs-type">const</span> Point3f&amp; v = mesh-&gt;<span class="hljs-built_in">getVertexPositions</span>().<span class="hljs-built_in">col</span>(i);<br>    <span class="hljs-type">const</span> Normal3f&amp; n = mesh-&gt;<span class="hljs-built_in">getVertexNormals</span>().<span class="hljs-built_in">col</span>(i).<span class="hljs-built_in">normalized</span>();<br>    <span class="hljs-keyword">auto</span> indirectCoeffs = <span class="hljs-built_in">computeInterreflectionSH</span>(&amp;m_TransportSHCoeffs, v, n,m_TransportSHCoeffs.<span class="hljs-built_in">col</span>(i), scene, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SHCoeffLength; j++)&#123;<br>        m_InterTransportSHCoeffs.<span class="hljs-built_in">col</span>(i).<span class="hljs-built_in">coeffRef</span>(j) = (*indirectCoeffs)[j];<br>    &#125;<br>&#125;<br>m_TransportSHCoeffs = m_InterTransportSHCoeffs;<br></code></pre></td></tr></table></figure> 效果如下：<br /><img src="/img/00016/PRT.gif" alt="16" /><br />读者有时间可以优化一下这个算法，吧对整球的采样改成<code>cos weight</code>半球采样，速度更快效果更好。</p><h2 id="使用预计算的数据进行shading">使用预计算的数据进行Shading</h2><p>我们回顾一下上面5式的结果：<br /><span class="math display">\[\begin{align}&amp; L_o(p,w_o)=\sum_il_it_i\end{align}\]</span>在<code>webgl</code>中要做的事情就是将预计算的<code>SHCoeffiecents</code>向量，传入到顶点着色器里，然后逐点相乘再求和，就是我们要的颜色值。最后做一下<code>Gamma Correction</code>和<code>Tone Mapping</code>将线性空间的颜色转换到sRGB空间。<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp">attribute vec3 aVertexPosition;<br>attribute vec3 aNormalPosition;<br><span class="hljs-comment">//光传输投影到前三层SH函数得到的系数，一个顶点包含9个系数，用mat3来存储。</span><br>attribute mat3 aPrecomputeLT;<br><span class="hljs-comment">//光照投影到前三层SH函数得到的系数，一个顶点包含27个系数，R对应9个，G对应9个，B对应9个，用三个mat3来存储</span><br>uniform mat3 uPrecomputeL[<span class="hljs-number">3</span>];<br>varying highp vec3 vColor;<br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">L_dot_LT</span><span class="hljs-params">(mat3 PrecomputeL, mat3 PrecomputeLT)</span> </span>&#123;<br>  vec3 L_0 = PrecomputeL[<span class="hljs-number">0</span>];<br>  vec3 L_1 = PrecomputeL[<span class="hljs-number">1</span>];<br>  vec3 L_2 = PrecomputeL[<span class="hljs-number">2</span>];<br>  vec3 LT_0 = PrecomputeLT[<span class="hljs-number">0</span>];<br>  vec3 LT_1 = PrecomputeLT[<span class="hljs-number">1</span>];<br>  vec3 LT_2 = PrecomputeLT[<span class="hljs-number">2</span>];<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">dot</span>(L_0, LT_0) + <span class="hljs-built_in">dot</span>(L_1, LT_1) + <span class="hljs-built_in">dot</span>(L_2, LT_2);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)&#123;<br>    <span class="hljs-comment">//RGB对应的SH系数分别做点乘，得到最后RGB值。</span><br>    vColor[i] = <span class="hljs-built_in">L_dot_LT</span>(uPrecomputeL[i],aPrecomputeLT);<br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>这个<code>Gamma Correction</code>和<code>Tone Mapping</code>在<code>Nori</code>框架中有个API已经实现，我们用它那个就行：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Color3f <span class="hljs-title">Color3f::toSRGB</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    Color3f result;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">3</span>; ++i) &#123;<br>        <span class="hljs-type">float</span> value = <span class="hljs-built_in">coeff</span>(i);<br>        <span class="hljs-keyword">if</span> (value &lt;= <span class="hljs-number">0.0031308f</span>)<br>            result[i] = <span class="hljs-number">12.92f</span> * value;<br>        <span class="hljs-keyword">else</span><br>            result[i] = (<span class="hljs-number">1.0f</span> + <span class="hljs-number">0.055f</span>)<br>                * std::<span class="hljs-built_in">pow</span>(value, <span class="hljs-number">1.0f</span>/<span class="hljs-number">2.4f</span>) -  <span class="hljs-number">0.055f</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Games202</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>c++对象模型之虚表，虚表指针，thunk，多态，多重继承this指针偏移，多重继承virtual析构函数，多重虚继承下的访问虚基类成员变量时虚表的工作原理</title>
    <link href="/2022/02/19/00006.%20c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B9%8B%E8%99%9A%E8%A1%A8%EF%BC%8C%E8%99%9A%E8%A1%A8%E6%8C%87%E9%92%88%E7%AD%89/"/>
    <url>/2022/02/19/00006.%20c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B9%8B%E8%99%9A%E8%A1%A8%EF%BC%8C%E8%99%9A%E8%A1%A8%E6%8C%87%E9%92%88%E7%AD%89/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><blockquote><p><strong>本篇文章为笔者的读书笔记，未经允许请勿转载。</strong><br />上两篇文章将c++的核心部件（<ahref="https://en.cppreference.com/w/cpp/language/value_category">Valuecategories</a>）讲清楚了，这篇文章将会带大家分析c++对象模型的底层原理。笔者这里用的编译器是<code>clang version 10.0.0-4ubuntu1</code>，不同编译器对数据布局的处理可能会不同（《深度探索c++对象模型》中已阐述原因，感兴趣的读者可以自行阅读）。友情提示：本文章涉及<code>ATT式</code>和<code>intel式</code>汇编代码的相关知识。</p></blockquote><hr /><h1 id="虚表和虚表指针vtbl-vptr">虚表和虚表指针（vtbl &amp; vptr）</h1><blockquote><ul><li>每个class产生出一堆指向virtualfunction的指针，放在表格之中，这个表格被称为virtual table（vtbl）。</li><li>每一个class object被安插一个指针，指向相关的virtualtable。通常这个指针被称为vptr。vptr的设定（setting）和重置（resetting）都由每一个class的constructor、destructor和copyassignment运算符自动完成。每一个class所关联的type_infoobject（用以支持runtime type identification，RTTI）也经由virtualtable被指出来，通常放在表格的第一个slot（clang++不是放在第一个slot，文章后面会讲到）。</li></ul></blockquote><hr /><blockquote><p>接下来笔者写两个测试用例来帮大家分析clang++编译器下的vtbl &amp;vptr。 ## 首先咱们来看下vptr放在对象的什么位置： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">testfunc</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//虚函数表指针位置分析</span><br>    <span class="hljs-comment">//类：有虚函数，这个类会产生一个虚函数表。</span><br>    <span class="hljs-comment">//类对象，有一个指针，指针（vptr）会指向这个虚函数表的开始地址。</span><br>    A obj;<br>    <span class="hljs-type">int</span> objLen = <span class="hljs-built_in">sizeof</span>(obj);<br>    std::cout&lt;&lt; objLen &lt;&lt; std::endl; <span class="hljs-comment">//x86-64 16字节</span><br><br>    <span class="hljs-comment">/*p1获取对象首地址，p2获取对象数据成员i的地址，两者都以低层次char *去解释，以便用旁观者角度去比较*/</span><br>    <span class="hljs-type">char</span> *p1 = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span> *&gt;(&amp;obj);<span class="hljs-comment">//reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。</span><br>    <span class="hljs-type">char</span> *p2 = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span> *&gt;(&amp;(obj.i));<br>    <span class="hljs-keyword">if</span>(p1 == p2)<span class="hljs-comment">//说明obj.i和obj的位置相同，说明i在对象obj内存布局的上边。虚函数表指针vptr在下边</span><br>    &#123;<br>        std::cout&lt;&lt; <span class="hljs-string">&quot;虚函数表指针位于对象内存的 末尾 &quot;</span> &lt;&lt;std::endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        std::cout&lt;&lt; <span class="hljs-string">&quot;虚函数表指针位于对象内存的 开头 &quot;</span> &lt;&lt;std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>运行结果如下：<br /><img src="/img/00006/1.png" alt="请添加图片描述" /> 可以看到<code>obj</code>对象的大小是16字节，<code>vptr</code>位于对象的开头。</p></blockquote><hr /><blockquote><h2id="接下里咱们不走virtual机制直接从虚表中获取虚函数并且运行对应虚函数">接下里咱们不走virtual机制，直接从虚表中获取虚函数并且运行对应虚函数。</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Base::f()&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Base::g()&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Base::h()&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Derive::g()&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Derive* pd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<span class="hljs-comment">//派生类指针。</span><br>    <span class="hljs-type">long</span>* pd_cast = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span>*&gt;(pd);<span class="hljs-comment">//获取较低层次上的重新解释。</span><br>    <span class="hljs-type">long</span>* vptr_pd = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span>*&gt;(*pd_cast);<br>    <span class="hljs-comment">/*解引用派生类指针得到虚表指针，而不是得到派生类，因为做了位模式的低层次转换。</span><br><span class="hljs-comment">    得到虚表指针后，将虚表指针的类型从long重新解释为long*。</span><br><span class="hljs-comment">    使用long过渡，是因为long在32位编译器和64位编译器所占用的空间大小和指针是一样的*/</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;vptr_pd[%d] 的内容为： %p\n&quot;</span>,i,vptr_pd[i]);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*Func)</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<span class="hljs-comment">//定义一个函数指针类型</span><br>    Func f_pd = (Func)vptr_pd[<span class="hljs-number">0</span>];<br>    Func g_pd = (Func)vptr_pd[<span class="hljs-number">1</span>];<br>    Func h_pd = (Func)vptr_pd[<span class="hljs-number">2</span>];<br><br>    <span class="hljs-built_in">f_pd</span>();<br>    <span class="hljs-built_in">g_pd</span>();<br>    <span class="hljs-built_in">h_pd</span>();<br><br>    Base* pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Base</span>();<span class="hljs-comment">//派生类指针。</span><br>    <span class="hljs-type">long</span>* pb_cast = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span>*&gt;(pb);<br>    <span class="hljs-type">long</span>* vptr_pb = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span>*&gt;(*pb_cast);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;vptr_pb[%d] 的内容为： %p\n&quot;</span>,i,vptr_pb[i]);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*Func)</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<span class="hljs-comment">//定义一个函数指针类型</span><br>    Func f_pb = (Func)vptr_pb[<span class="hljs-number">0</span>];<br>    Func g_pb = (Func)vptr_pb[<span class="hljs-number">1</span>];<br>    Func h_pb = (Func)vptr_pb[<span class="hljs-number">2</span>];<br><br>    <span class="hljs-built_in">f_pb</span>();<br>    <span class="hljs-built_in">g_pb</span>();<br>    <span class="hljs-built_in">h_pb</span>();<br><br>    <span class="hljs-keyword">delete</span> pd;<br>    <span class="hljs-keyword">delete</span> pb;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果为： <img src="/img/00006/2.png" alt="请添加图片描述" />或者用GDB命令打印出vtbl的样子： <code>gef➤  info vtbl pd</code> <imgsrc="/img/00006/3.png" alt="请添加图片描述" />和上面代码运行的结果一致！值得关注的一点是，<code>vtbl</code>是存在于只读数据段，而<code>vptr</code>在堆中（<code>vptr</code>也可以在栈中）。下面用一张图来描述上述代码的行为： <img src="/img/00006/4.png"alt="请添加图片描述" />--------------------------------------------------------</p></blockquote><blockquote><h2 id="vptr-vtbl的创建时机以及vptr初始化问题">vptr &amp;vtbl的创建时机以及vptr初始化问题</h2><p>引用《深度探索C++对象模型》p45中的一段话：下面两个扩张行动会在编译期间发生： - 一个virtual functiontable会被编译器产生出来，内放class的virtual functions地址 -在每一个class object中，一个额外的pointermember会被编译器合成出来，内含相关的class vtbl的地址</p><p>在c++中，virtualfunctions可以在编译时期获知。此外，这一组地址是固定不变的，执行期不可能新增或替换它。由于程序执行时，表格的大小和内容都不会改变，所以其构建和存取皆可以由编译器完全掌握，不需要执行期的任何介入。值得注意的是<code>vptr的初始化</code>问题：这里笔者就不带大家画堆栈图，过程如下！ 相关ATT式反汇编代码如下：<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs apache">    <span class="hljs-attribute">Derive</span>* pd = new Derive();//派生类指针。<br>  <span class="hljs-attribute">401222</span>:bf <span class="hljs-number">08</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x8,%edi<br>  <span class="hljs-attribute">401227</span>:e8 <span class="hljs-number">64</span> fe ff ff       callq  <span class="hljs-number">401090</span> &lt;operator new(unsigned long)@plt&gt;<br>  <span class="hljs-attribute">40122c</span>:<span class="hljs-number">31</span> f6                xor    %esi,%esi<br>  <span class="hljs-attribute">40122e</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c1             mov    %rax,%rcx<br>  <span class="hljs-attribute">401231</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> cf             mov    %rcx,%rdi<br>  <span class="hljs-attribute">401234</span>:ba <span class="hljs-number">08</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x8,%edx<br>  <span class="hljs-attribute">401239</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">45</span> <span class="hljs-number">80</span>          mov    %rax,-<span class="hljs-number">0</span>x80(%rbp)<br>  <span class="hljs-attribute">40123d</span>:e8 <span class="hljs-number">0</span>e fe ff ff       callq  <span class="hljs-number">401050</span> &lt;memset@plt&gt;<br>  <span class="hljs-attribute">401242</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">7</span>d <span class="hljs-number">80</span>          mov    -<span class="hljs-number">0</span>x80(%rbp),%rdi<br>  <span class="hljs-attribute">401246</span>:e8 <span class="hljs-number">95</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">4013</span>e0 &lt;Derive::Derive()&gt;<br>  <span class="hljs-attribute">40124b</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> <span class="hljs-number">80</span>          mov    -<span class="hljs-number">0</span>x80(%rbp),%rax<br>  <span class="hljs-attribute">40124f</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">45</span> f0          mov    %rax,-<span class="hljs-number">0</span>x10(%rbp)<br>  <br>  <span class="hljs-attribute">00000000004013e0</span> &lt;Derive::Derive()&gt;:<br><span class="hljs-attribute">class</span> Derive : public Base<br>  <span class="hljs-attribute">4013e0</span>:<span class="hljs-number">55</span>                   push   %rbp<br>  <span class="hljs-attribute">4013e1</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> e5             mov    %rsp,%rbp<br>  <span class="hljs-attribute">4013e4</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">10</span>          sub    $<span class="hljs-number">0</span>x10,%rsp<br>  <span class="hljs-attribute">4013e8</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">7</span>d f8          mov    %rdi,-<span class="hljs-number">0</span>x8(%rbp)<br>  <span class="hljs-attribute">4013ec</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> f8          mov    -<span class="hljs-number">0</span>x8(%rbp),%rax<br>  <span class="hljs-attribute">4013f0</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c1             mov    %rax,%rcx<br>  <span class="hljs-attribute">4013f3</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> cf             mov    %rcx,%rdi<br>  <span class="hljs-attribute">4013f6</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">45</span> f0          mov    %rax,-<span class="hljs-number">0</span>x10(%rbp)<br>  <span class="hljs-attribute">4013fa</span>:e8 <span class="hljs-number">21</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">401420</span> &lt;Base::Base()&gt;<br>  <span class="hljs-attribute">4013ff</span>:<span class="hljs-number">48</span> b8 <span class="hljs-number">70</span> <span class="hljs-number">20</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> movabs $<span class="hljs-number">0</span>x402070,%rax<br>  <span class="hljs-attribute">401406</span>:<span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br>  <span class="hljs-attribute">401409</span>:<span class="hljs-number">48</span> <span class="hljs-number">05</span> <span class="hljs-number">10</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    add    $<span class="hljs-number">0</span>x10,%rax<br>  <span class="hljs-attribute">40140f</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">4</span>d f0          mov    -<span class="hljs-number">0</span>x10(%rbp),%rcx<br>  <span class="hljs-attribute">401413</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">01</span>             mov    %rax,(%rcx)<br>  <span class="hljs-attribute">401416</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">10</span>          add    $<span class="hljs-number">0</span>x10,%rsp<br>  <span class="hljs-attribute">40141a</span>:<span class="hljs-number">5</span>d                   pop    %rbp<br>  <span class="hljs-attribute">40141b</span>:c3                   retq   <br>  <span class="hljs-attribute">40141c</span>:<span class="hljs-number">0</span>f <span class="hljs-number">1</span>f <span class="hljs-number">40</span> <span class="hljs-number">00</span>          nopl   <span class="hljs-number">0</span>x0(%rax)<br><br><span class="hljs-attribute">0000000000401420</span> &lt;Base::Base()&gt;:<br><span class="hljs-attribute">class</span> Base<br>  <span class="hljs-attribute">401420</span>:<span class="hljs-number">55</span>                   push   %rbp<br>  <span class="hljs-attribute">401421</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> e5             mov    %rsp,%rbp<br>  <span class="hljs-attribute">401424</span>:<span class="hljs-number">48</span> b8 d0 <span class="hljs-number">20</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> movabs $<span class="hljs-number">0</span>x4020d0,%rax<br>  <span class="hljs-attribute">40142b</span>:<span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br>  <span class="hljs-attribute">40142e</span>:<span class="hljs-number">48</span> <span class="hljs-number">05</span> <span class="hljs-number">10</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    add    $<span class="hljs-number">0</span>x10,%rax<br>  <span class="hljs-attribute">401434</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">7</span>d f8          mov    %rdi,-<span class="hljs-number">0</span>x8(%rbp)<br>  <span class="hljs-attribute">401438</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">4</span>d f8          mov    -<span class="hljs-number">0</span>x8(%rbp),%rcx<br>  <span class="hljs-attribute">40143c</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">01</span>             mov    %rax,(%rcx)<br>  <span class="hljs-attribute">40143f</span>:<span class="hljs-number">5</span>d                   pop    %rbp<br>  <span class="hljs-attribute">401440</span>:c3                   retq   <br>  <span class="hljs-attribute">401441</span>:<span class="hljs-number">66</span> <span class="hljs-number">2</span>e <span class="hljs-number">0</span>f <span class="hljs-number">1</span>f <span class="hljs-number">84</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> nopw   %cs:<span class="hljs-number">0</span>x0(%rax,%rax,<span class="hljs-number">1</span>)<br>  <span class="hljs-attribute">401448</span>:<span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br>  <span class="hljs-attribute">40144b</span>:<span class="hljs-number">0</span>f <span class="hljs-number">1</span>f <span class="hljs-number">44</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       nopl   <span class="hljs-number">0</span>x0(%rax,%rax,<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>--------------------------------------------------------</p></blockquote><blockquote><p><img src="/img/00006/5.png" alt="请添加图片描述" />该图对应<code>mov    %rax,-0x80(%rbp)</code>执行完。已经发生的事情有：new表达式通过<code>operator new(unsigned long)</code>这个动态函数申请了首地址为<code>0x0000000000416eb0</code>的堆内存，并将其赋给了栈空间为<code>rbp-0x80（0x00007fffffffe060）</code>的地址中，下一条反汇编代码将会为首地址为<code>0x0000000000416eb0</code>的堆内存进行内存初始化。（延迟绑定:动态函数比静态函数绑定要晚静态函数在<code>a.out</code>生成的时候地址已经被绑定动态函数需要动态库加载到内存中，然后用动态库里面的函数地址替换掉类似于反汇编出来的<code>@plt</code>，之后得到动态函数的地址进行调用。）</p></blockquote><hr /><blockquote><p><img src="/img/00006/6.png" alt="请添加图片描述" />该图对应<code>0x40143c &lt;Base::Base()+28&gt; mov    QWORD PTR [rcx], rax</code>执行完。已经发生的事情有：调用了<code>Derive合成默认构造函数</code>，并且在其中又调用了<code>Base合成默认构造函数</code>，首地址为<code>0x0000000000416eb0</code>的堆内存指针赋给了第一参数寄存器<code>rdi</code>，<code>0x4020d0立即数</code>（Base虚表地址）赋给了临时寄存器<code>rax</code>，<code>rdi</code>寄存器又将堆内存指针赋给了Base合成默认构造函数的<code>rbp-0x8</code>地址上，最后由<code>rax</code>寄存器将Base虚表地址赋给了堆内存指针所指向的地址中。至此new出来的Derive类对象的<code>vptr</code>已经获取到Base类的虚表地址（注意现在还没有获取到Derive类的虚表地址）。</p></blockquote><hr /><blockquote><p><img src="/img/00006/7.png" alt="请添加图片描述" />该图对应<code>0x401413 &lt;Derive::Derive()+51&gt; mov    QWORD PTR [rcx], rax</code>执行完。已经发生的事情有：<code>Base的合成默认构造函数</code>已<code>return</code>，接着<code>0x402070立即数</code>赋给了<code>rax</code>寄存器，<code>rax</code>将其值加上<code>0x10</code>后就得到了Derive类的虚表地址。然后<code>rax</code>将该地址赋给了堆内存指针所指向的地址中。至此伴随着<code>Derive合成默认构造函数</code>的结束，new出来的Derive类对象的<code>vptr</code>获得了自己的虚表地址。</p></blockquote><hr /><h3 id="vptr初始化小结">vptr初始化小结</h3><blockquote><p>可以发现，<code>vptr的初始化</code>并不是一开始就获得了自己的虚表地址，而是伴随父类合成默认构造函数的结束，先获得父类虚表地址，然后伴随自身合成默认构造函数的结束，再获得自身虚表地址。</p></blockquote><hr /><h2id="编译器会合成出nontrivial-default-constructor的4种情况深度探索c对象模型p40">编译器会合成出nontrivialdefault constructor的4种情况（《深度探索c++对象模型》p40）</h2><blockquote><ul><li>带有default constructor的member class object</li></ul><p>如果一个class没有任何constructor，但它内含一个memberobject，而后者有default constructor，那么这个class的implicit defaultconstructor就是nontrivial，编译器需要为该class合成出一个defaultconstructor。 - 带有default constructor的base class</p><p>如果一个没有任何constructor的class派生自一个带有defaultconstructor的base class，那么这个derived class的defaultconstructor会被视为nontrivial，并因此需要被合成出来。它将调用上一层baseclasses的default constructor（根据它们的声明顺序）。 - 带有一个virtualfunction的class</p><p>对于那些未声明任何constructor的classes，编译器会为它们合成一个defaultconstructor，以便正确地初始化每一个class object的vptr。 -带有一个virtual base class的class</p><p>Virtual base class的实现方法在不同编译器之间有极大的差异。然而，每一种实现方法的共同点在于必须使virtualbase class在其每一个derived classobject中的位置，能够于执行期准备妥当。在未声明任何constructor的derivedclass object中，编译器必须为它合成一个defaultconstructor，并安插那些“允许每一个virtual baseclass的执行期存取操作”的代码。</p></blockquote><hr /><h1id="多重继承下的virtual-functionthunk以及编译期绑定和运行期绑定动态绑定">多重继承下的virtualfunction，thunk，以及编译期绑定和运行期绑定（动态绑定）</h1><blockquote><p>在多重继承中支持virtual function，其复杂度围绕在第二个以及后继的baseclasses身上，以及“必须在执行期调整this指针”这一点，以下面的class体系为例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;base1::f()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;base1::g()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//基类2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;base2::h()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">i</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;base2::i()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>:<span class="hljs-keyword">public</span> Base1,<span class="hljs-keyword">public</span> Base2<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span><span class="hljs-comment">//覆盖父类1的虚函数</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;derived::f()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">i</span><span class="hljs-params">()</span><span class="hljs-comment">//覆盖父类2的虚函数</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;derived::i()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">//我们自己的虚函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">myFunc1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;derived::myFunc1()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-comment">//非虚函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunc2</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;derived::myFunc2()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Base1) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Base2) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Derived) &lt;&lt; std::endl;<br><br>    Derived ins;<br>    Base1&amp; b1 = ins;<span class="hljs-comment">//为了支持多态《深度探索c++对象模型p25》</span><br>    Base2&amp; b2 = ins;<br>    Derived&amp; d = ins;<br><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*Func)</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br>    <span class="hljs-comment">/*获得Base1类的第虚表指针*/</span><br>    Base1 temp1;<br>    <span class="hljs-type">long</span>* base1_cast = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span>*&gt;(&amp;temp1);<span class="hljs-comment">//重新解释类对象,获得虚表指针的地址。</span><br>    <span class="hljs-type">long</span>* base1_vptr = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span>*&gt;(*base1_cast);<span class="hljs-comment">//虚表指针的类型从long重新解释为long*。让它体现出指针的性质而不是long数值</span><br>    <span class="hljs-comment">//打印虚函数地址</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;base1_vptr[%d] 的内容为： %p\n&quot;</span>,i,base1_vptr[i]);<br>        ((Func)base1_vptr[i])();<br>    &#125;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;----------------------------&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">/*获得Base2类的第虚表指针*/</span><br>    Base2 temp2;<br>    <span class="hljs-type">long</span>* base2_cast = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span>*&gt;(&amp;temp2);<span class="hljs-comment">//重新解释类对象,获得第虚表指针的地址。</span><br>    <span class="hljs-type">long</span>* base2_vptr = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span>*&gt;(*base2_cast);<span class="hljs-comment">//虚表指针的类型从long重新解释为long*。让它体现出指针的性质而不是long数值</span><br>    <span class="hljs-comment">//打印虚函数地址</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;base2_vptr[%d] 的内容为： %p\n&quot;</span>,i,base2_vptr[i]);<br>        ((Func)base2_vptr[i])();<br>    &#125;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;----------------------------&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">/*获得derived类的第一个虚表指针*/</span><br>    <span class="hljs-type">long</span>* ins_cast1 = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span>*&gt;(&amp;ins);<span class="hljs-comment">//重新解释类对象,获得第一个虚表指针的地址。</span><br>    <span class="hljs-type">long</span>* vptr1 = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span>*&gt;(*ins_cast1);<span class="hljs-comment">//虚表指针的类型从long重新解释为long*。让它体现出指针的性质而不是long数值</span><br>    <span class="hljs-comment">//打印虚函数地址</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;vptr1[%d] 的内容为： %p\n&quot;</span>,i,vptr1[i]);<br>        ((Func)vptr1[i])();<br>    &#125;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;----------------------------&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">/*获得derived类的第二个虚表指针*/</span><br>    <span class="hljs-type">long</span>* ins_cast2 = ins_cast1 + <span class="hljs-number">1</span>;<span class="hljs-comment">//偏移到第二个虚表指针的地址上</span><br>    <span class="hljs-type">long</span>* vptr2 = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span>*&gt;(*ins_cast2);<span class="hljs-comment">//虚表指针的类型从long重新解释为long*。让它体现出指针的性质而不是long数值</span><br>    <span class="hljs-comment">//打印虚函数地址</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;vptr2[%d] 的内容为： %p\n&quot;</span>,i,vptr2[i]);<br>        ((Func)vptr2[i])();<br>    &#125;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;----------------------------&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">//动态绑定</span><br>    b1.<span class="hljs-built_in">f</span>();<br>    b2.<span class="hljs-built_in">i</span>();<br>    d.<span class="hljs-built_in">f</span>();<br>    d.<span class="hljs-built_in">i</span>();<br>    d.<span class="hljs-built_in">g</span>();<br>    d.<span class="hljs-built_in">myFunc1</span>();<br>    <span class="hljs-comment">//编译期绑定</span><br>    d.<span class="hljs-built_in">myFunc2</span>();<br>&#125;<br></code></pre></td></tr></table></figure>在这个例子中，我们的子类会有两个虚指针，两张虚表，第一张虚表是重写父类虚函数、自身虚函数以及base1虚函数共享的虚表，第二张则是针对base2的。下面来看下运行结果：<img src="/img/00006/8.png" alt="请添加图片描述" />重写的父类虚函数：<code>f()</code>，<code>i()</code>、自身虚函数：<code>myFunc1()</code>、base1虚函数：<code>g()</code>都在第一张虚表。而第二张虚表中，<code>h()</code>的出现很正常，但是这个被重写的父类虚函数<code>i()</code>，为什么会再次出现呢？，不应该只在表一出现吗？这里表二中被重写的父类虚函数<code>i()</code>，其真名叫<code>nonvirtual thunk</code>函数。咱们用指令来更清晰的观察Derived类对象ins的两张虚表： （注意：必须在支持多态的情况下观察Derived类对象ins，具体原因请参考《深度探索c++对象模型》p13）<img src="/img/00006/9.png" alt="请添加图片描述" />上文说过“必须在执行期调整this指针”，而thunk函数的真正目的为： -以适当的offset值调整this指针 - 跳到virtual function去</p><p>其实thunk函数就是一段assembly代码，下面我会带大家一起揭开thunk函数的真正面纱！首先要想知道thunk函数干了什么，就要想个办法去调用它，然后跟踪进去。我们上面的示例代码中有一行代码：<code>b2.i();</code>会调用thunk函数。原因是<code>Base2&amp; b2 = ins;</code>中，b2的this指针指向的ins对象的第二个虚表指针，在调用ins对象的被重写父类虚函数<code>i()</code>时，需要调整this指针。具体分析过程如下： <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs apache">    <span class="hljs-attribute">b2</span>.i();<br>  <span class="hljs-attribute">401553</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> d8          mov    -<span class="hljs-number">0</span>x28(%rbp),%rax//rbp-<span class="hljs-number">0</span>x28里面存着b2的this指针，指向ins对象的第二个虚表指针<br>  <span class="hljs-attribute">401557</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">08</span>             mov    (%rax),%rcx//将ins虚表二的第一个虚函数指针赋给了rcx寄存器<br>  <span class="hljs-attribute">40155a</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi//将b2的this指针存到rdi寄存器作为thunk函数的第一参数<br>  <span class="hljs-attribute">40155d</span>:ff <span class="hljs-number">51</span> <span class="hljs-number">08</span>             callq  *<span class="hljs-number">0</span>x8(%rcx)//偏移<span class="hljs-number">0</span>x8字节后调用thunk函数，*<span class="hljs-number">0</span>x8(%rcx)的值为<span class="hljs-number">0</span>x4017f0<br><br><span class="hljs-attribute">00000000004017f0</span> &lt;non-virtual thunk to Derived::i()&gt;:<br>  <span class="hljs-attribute">4017f0</span>:<span class="hljs-number">55</span>                   push   %rbp<br>  <span class="hljs-attribute">4017f1</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> e5             mov    %rsp,%rbp<br>  <span class="hljs-attribute">4017f4</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">7</span>d f8          mov    %rdi,-<span class="hljs-number">0</span>x8(%rbp)//将b2的this指针存放到该thunk函数rbp-<span class="hljs-number">0</span>x8的地址中<br>  <span class="hljs-attribute">4017f8</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> f8          mov    -<span class="hljs-number">0</span>x8(%rbp),%rax//将b2的this指针存放到rax临时寄存器中<br>  <span class="hljs-attribute">4017fc</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c0 f8          add    $<span class="hljs-number">0</span>xfffffffffffffff8,%rax//this指针的值（<span class="hljs-number">0</span>x00007fffffffe120）加上<span class="hljs-number">0</span>xfffffffffffffff8，因为溢出，相当于<span class="hljs-number">0</span>x00007fffffffe120-<span class="hljs-number">0</span>x8，结果为<span class="hljs-number">0</span>x00007fffffffe118即ins对象的首地址<br>  <span class="hljs-attribute">401800</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi//将偏移后的this指针存到rdi第一参数寄存器中，作为&lt;Derived::i()&gt;的参数<br>  <span class="hljs-attribute">401803</span>:<span class="hljs-number">5</span>d                   pop    %rbp<br>  <span class="hljs-attribute">401804</span>:e9 <span class="hljs-number">27</span> ff ff ff       jmpq   <span class="hljs-number">401730</span> &lt;Derived::i()&gt;<br>  <span class="hljs-attribute">401809</span>:<span class="hljs-number">0</span>f <span class="hljs-number">1</span>f <span class="hljs-number">80</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> nopl   <span class="hljs-number">0</span>x0(%rax)<br></code></pre></td></tr></table></figure>后面就是调用虚函数<code>&lt;Derived::i()&gt;</code>后的过程，不再赘述。经过分析，可以发现thunk函数就做了两件事，以适当的<code>offset</code>值调整this指针，跳到virtualfunction去。和上面说的两点完全一致。</p></blockquote><hr /><h2id="编译期绑定和运行期绑定动态绑定">编译期绑定和运行期绑定（动态绑定）</h2><blockquote><p>还是用上面的示例，可以看到子类中有定义一个非虚函数。咱们就来看下什么是运行期绑定和动态绑定的区别是什么。在此之前，先看下绑定的概念：调用代码跟函数地址什么时候关联到一起。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//编译期绑定</span><br>d.<span class="hljs-built_in">myFunc2</span>();<br></code></pre></td></tr></table></figure> <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">d</span>.myFunc2();<br><span class="hljs-attribute">401596</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">7</span>d d0          mov    -<span class="hljs-number">0</span>x30(%rbp),%rdi<br><span class="hljs-attribute">40159a</span>:e8 d1 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">401670</span> &lt;Derived::myFunc2()&gt;<br></code></pre></td></tr></table></figure><code>编译期绑定</code>：调用代码跟函数在编译期就关联到一起。可以看到函数调用是直接调用指定地址的函数，而且机器码会出现E8的字样，表示直接调用，俗称<code>E8CALL</code>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//动态绑定</span><br>b1.<span class="hljs-built_in">f</span>();<br>b2.<span class="hljs-built_in">i</span>();<br>d.<span class="hljs-built_in">f</span>();<br>d.<span class="hljs-built_in">i</span>();<br>d.<span class="hljs-built_in">g</span>();<br>d.<span class="hljs-built_in">myFunc1</span>();<br></code></pre></td></tr></table></figure> <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs apache"> <span class="hljs-attribute">b1</span>.f();<br><span class="hljs-attribute">401540</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">4</span>d e0          mov    -<span class="hljs-number">0</span>x20(%rbp),%rcx<br><span class="hljs-attribute">401544</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">11</span>             mov    (%rcx),%rdx<br><span class="hljs-attribute">401547</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> cf             mov    %rcx,%rdi<br><span class="hljs-attribute">40154a</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">85</span> <span class="hljs-number">20</span> ff ff ff mov    %rax,-<span class="hljs-number">0</span>xe0(%rbp)<br><span class="hljs-attribute">401551</span>:ff <span class="hljs-number">12</span>                callq  *(%rdx)<br>  <span class="hljs-attribute">b2</span>.i();<br><span class="hljs-attribute">401553</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> d8          mov    -<span class="hljs-number">0</span>x28(%rbp),%rax<br><span class="hljs-attribute">401557</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">08</span>             mov    (%rax),%rcx<br><span class="hljs-attribute">40155a</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br><span class="hljs-attribute">40155d</span>:ff <span class="hljs-number">51</span> <span class="hljs-number">08</span>             callq  *<span class="hljs-number">0</span>x8(%rcx)<br>  <span class="hljs-attribute">d</span>.f();<br><span class="hljs-attribute">401560</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> d0          mov    -<span class="hljs-number">0</span>x30(%rbp),%rax<br><span class="hljs-attribute">401564</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">08</span>             mov    (%rax),%rcx<br><span class="hljs-attribute">401567</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br><span class="hljs-attribute">40156a</span>:ff <span class="hljs-number">11</span>                callq  *(%rcx)<br>  <span class="hljs-attribute">d</span>.i();<br><span class="hljs-attribute">40156c</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> d0          mov    -<span class="hljs-number">0</span>x30(%rbp),%rax<br><span class="hljs-attribute">401570</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">08</span>             mov    (%rax),%rcx<br><span class="hljs-attribute">401573</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br><span class="hljs-attribute">401576</span>:ff <span class="hljs-number">51</span> <span class="hljs-number">10</span>             callq  *<span class="hljs-number">0</span>x10(%rcx)<br>  <span class="hljs-attribute">d</span>.g();<br><span class="hljs-attribute">401579</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> d0          mov    -<span class="hljs-number">0</span>x30(%rbp),%rax<br><span class="hljs-attribute">40157d</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c1             mov    %rax,%rcx<br><span class="hljs-attribute">401580</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">00</span>             mov    (%rax),%rax<br><span class="hljs-attribute">401583</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> cf             mov    %rcx,%rdi<br><span class="hljs-attribute">401586</span>:ff <span class="hljs-number">50</span> <span class="hljs-number">08</span>             callq  *<span class="hljs-number">0</span>x8(%rax)<br>  <span class="hljs-attribute">d</span>.myFunc1();<br><span class="hljs-attribute">401589</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> d0          mov    -<span class="hljs-number">0</span>x30(%rbp),%rax<br><span class="hljs-attribute">40158d</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">08</span>             mov    (%rax),%rcx<br><span class="hljs-attribute">401590</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br><span class="hljs-attribute">401593</span>:ff <span class="hljs-number">51</span> <span class="hljs-number">18</span>             callq  *<span class="hljs-number">0</span>x18(%rcx)<br></code></pre></td></tr></table></figure><code>动态绑定</code>：调用代码跟函数在运行期才能关联到一起。通过上面的反汇编代码可以发现，函数的调用地址是基于某个寄存器的偏移值而确定的，无法在编译期确定。而且在函数调用机器码中会出现ff的字样，表示间接调用，俗称<code>FFCALL</code>。动态绑定还有一个别名叫<code>多态</code>，只有虚函数才能是动态绑定。</p></blockquote><hr /><h1id="多重继承下的成员布局以及this指针偏移">多重继承下的成员布局以及this指针偏移</h1><blockquote><p>经过上文的分析，我们已经熟知多重继承下虚机制是如何工作的。这一小节，我将带大家分析父类含成员变量时多重继承的成员布局。在父类指针支持多态时会发生this指针偏移，deletethis指针偏移后的父类指针会导致异常。说的有点繁琐，不要紧，咱们看下文：代码示例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//基类1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base1</span>():<span class="hljs-built_in">b1</span>(<span class="hljs-number">1</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;base1::f()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-type">int</span> b1;<br>&#125;;<br><span class="hljs-comment">//基类2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base2</span>():<span class="hljs-built_in">b2</span>(<span class="hljs-number">2</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;base2::h()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-type">int</span> b2;<br>&#125;;<br><span class="hljs-comment">//子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>:<span class="hljs-keyword">public</span> Base1,<span class="hljs-keyword">public</span> Base2<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>():<span class="hljs-built_in">m</span>(<span class="hljs-number">3</span>),<span class="hljs-built_in">n</span>(<span class="hljs-number">4</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span><span class="hljs-comment">//覆盖父类1的虚函数</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;derived::f()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;derived::h()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> n;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Derived类的大小%d\n&quot;</span>,<span class="hljs-built_in">sizeof</span>(Derived));<br>    <span class="hljs-comment">//打印成员变量的偏移值</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Derived::b1 = %d\n&quot;</span>,&amp;Derived::b1);<span class="hljs-comment">//b1是基于Base1的偏移</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Derived::b2 = %d\n&quot;</span>,&amp;Derived::b2);<span class="hljs-comment">//b2是基于Base2的偏移</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Derived::m = %d\n&quot;</span>,&amp;Derived::m);<span class="hljs-comment">//m基于Derived的偏移</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Derived::n = %d\n&quot;</span>,&amp;Derived::n);<span class="hljs-comment">//n基于Derived的偏移</span><br><br>    Derived obj;<br>    Base1 *pbase1 = &amp;obj;<span class="hljs-comment">//this指针没有调整。</span><br>    Base2 *pbase2 = &amp;obj;<span class="hljs-comment">//this指针向下调整0x10字节。</span><br><br>    <span class="hljs-comment">//现在我们知道Base2在支持多态时会调整this指针。如果我们的obj是new出来的，当我们用delete去删除pbase2时会发生什么？</span><br>    Base2 *new_pbase2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    <span class="hljs-comment">//delete new_pbase2;异常</span><br>    <span class="hljs-built_in">delete</span> (Derived*)new_pbase2;<span class="hljs-comment">//让编译器重新调整this指针，再delete掉。</span><br>&#125;<br></code></pre></td></tr></table></figure> 运行结果如下： <img src="/img/00006/10.png"alt="请添加图片描述" />根据数据成员的偏移值，我们可以得出该类的成员布局： <imgsrc="/img/00006/11.png" alt="请添加图片描述" />用GDB打印出空间布局，以及虚表内的虚函数： <img src="/img/00006/12.png"alt="请添加图片描述" /> 和上述说明一致！值得关注的一个问题是，Base2在支持多态时会调整this指针。如果我们的obj是new出来的，当我们用delete去删除pbase2时会报异常，其原因在于直接delete调整后的this指针无法将new出来的derived类对象完整删除。除非我们将该this指针继续调整到derived类对象的开头，或者在父类和基类中添加virtual析构函数。下一小节咱们继续深入探讨多重继承下virtual析构函数的工作原理以及虚表对应的变化！</p></blockquote><hr /><h1id="多重继承下virtual析构函数的工作原理以及虚表的变化">多重继承下virtual析构函数的工作原理以及虚表的变化</h1><blockquote><p>继上一小节，我们已经知道多重继承下数据成员的分布，为了更好的解决deletethis指针偏移后的父类指针，我们必须在父类和基类中添加virtual析构函数。这样编译器就会为虚表多加几个槽，目的在于帮助this指针偏移后的父类指针回调到derived类对象的开头，进而完成delete。示例代码和上一小节差不多，如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//基类1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base1</span>():<span class="hljs-built_in">b1</span>(<span class="hljs-number">1</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;base1::f()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base1</span>() &#123;&#125;<br>    <span class="hljs-type">int</span> b1;<br>&#125;;<br><span class="hljs-comment">//基类2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base2</span>():<span class="hljs-built_in">b2</span>(<span class="hljs-number">2</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;base2::h()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base2</span>() &#123;&#125;<br>    <span class="hljs-type">int</span> b2;<br>&#125;;<br><span class="hljs-comment">//子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>:<span class="hljs-keyword">public</span> Base1,<span class="hljs-keyword">public</span> Base2<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>():<span class="hljs-built_in">m</span>(<span class="hljs-number">3</span>),<span class="hljs-built_in">n</span>(<span class="hljs-number">4</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span><span class="hljs-comment">//覆盖父类1的虚函数</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;derived::f()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;derived::h()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Derived</span>() &#123;&#125;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> n;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Derived *new_pderived = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    <span class="hljs-comment">//打印第一张虚表</span><br>    <span class="hljs-type">long</span>* pderived_cast1 = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span>*&gt;(new_pderived);<span class="hljs-comment">//重新解释类对象,获得虚表指针的地址。</span><br>    <span class="hljs-type">long</span>* pderived_vptr1 = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span>*&gt;(*pderived_cast1);<span class="hljs-comment">//虚表指针的类型从long重新解释为long*。让它体现出指针的性质而不是long数值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pderived_vptr1[%d] 的内容为： %p\n&quot;</span>,i,pderived_vptr1[i]);<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;----------------------------&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-comment">//打印第二张虚表</span><br>    <span class="hljs-type">long</span>* pderived_cast2 = pderived_cast1 + <span class="hljs-number">2</span>;<span class="hljs-comment">//偏移到第二个虚表指针的地址上</span><br>    <span class="hljs-type">long</span>* pderived_vptr2 = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span>*&gt;(*pderived_cast2);<span class="hljs-comment">//虚表指针的类型从long重新解释为long*。让它体现出指针的性质而不是long数值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pderived_vptr2[%d] 的内容为： %p\n&quot;</span>,i,pderived_vptr2[i]);<br>    &#125;<br>    <span class="hljs-keyword">delete</span> new_pderived;<br><br>    Base2 *new_pbase2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    <span class="hljs-keyword">delete</span> new_pbase2;<br>&#125;<br></code></pre></td></tr></table></figure>其对应的反汇编代码如下(我将有用的部分贴在下面)： <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs apache">    <span class="hljs-attribute">Base2</span> *new_pbase2 = new Derived();<br>  <span class="hljs-attribute">40136e</span>:e8 <span class="hljs-number">0</span>d fd ff ff       callq  <span class="hljs-number">401080</span> &lt;operator new(unsigned long)@plt&gt;<br>  <span class="hljs-attribute">401373</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c1             mov    %rax,%rcx<br>  <span class="hljs-attribute">401376</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c2             mov    %rax,%rdx<br>  <span class="hljs-attribute">401379</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br>  <span class="hljs-attribute">40137c</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">4</span>d <span class="hljs-number">88</span>          mov    %rcx,-<span class="hljs-number">0</span>x78(%rbp)<br>  <span class="hljs-attribute">401380</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">55</span> <span class="hljs-number">80</span>          mov    %rdx,-<span class="hljs-number">0</span>x80(%rbp)<br>  <span class="hljs-attribute">401384</span>:e8 <span class="hljs-number">87</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">401410</span> &lt;Derived::Derived()&gt;<br>  <span class="hljs-attribute">401389</span>:e9 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       jmpq   <span class="hljs-number">40138</span>e &lt;main+<span class="hljs-number">0</span>x16e&gt;<br>  <span class="hljs-attribute">40138e</span>:<span class="hljs-number">31</span> c0                xor    %eax,%eax<br>  <span class="hljs-attribute">401390</span>:<span class="hljs-number">89</span> c1                mov    %eax,%ecx<br>  <span class="hljs-attribute">401392</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">55</span> <span class="hljs-number">80</span>          mov    -<span class="hljs-number">0</span>x80(%rbp),%rdx<br>  <span class="hljs-attribute">401396</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> fa <span class="hljs-number">00</span>          cmp    $<span class="hljs-number">0</span>x0,%rdx<br>  <span class="hljs-attribute">40139a</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">8</span>d <span class="hljs-number">78</span> ff ff ff mov    %rcx,-<span class="hljs-number">0</span>x88(%rbp)<br>  <span class="hljs-attribute">4013a1</span>:<span class="hljs-number">0</span>f <span class="hljs-number">84</span> <span class="hljs-number">11</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    je     <span class="hljs-number">4013</span>b8 &lt;main+<span class="hljs-number">0</span>x198&gt;<br>  <span class="hljs-attribute">4013a7</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> <span class="hljs-number">80</span>          mov    -<span class="hljs-number">0</span>x80(%rbp),%rax<br>  <span class="hljs-attribute">4013ab</span>:<span class="hljs-number">48</span> <span class="hljs-number">05</span> <span class="hljs-number">10</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    add    $<span class="hljs-number">0</span>x10,%rax<br>  <span class="hljs-attribute">4013b1</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">85</span> <span class="hljs-number">78</span> ff ff ff mov    %rax,-<span class="hljs-number">0</span>x88(%rbp)<br>  <span class="hljs-attribute">4013b8</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">85</span> <span class="hljs-number">78</span> ff ff ff mov    -<span class="hljs-number">0</span>x88(%rbp),%rax<br>  <span class="hljs-attribute">4013bf</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">45</span> a8          mov    %rax,-<span class="hljs-number">0</span>x58(%rbp)<br>    <span class="hljs-attribute">delete</span> new_pbase2;<br>  <span class="hljs-attribute">4013c3</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> a8          mov    -<span class="hljs-number">0</span>x58(%rbp),%rax<br>  <span class="hljs-attribute">4013c7</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> f8 <span class="hljs-number">00</span>          cmp    $<span class="hljs-number">0</span>x0,%rax<br>  <span class="hljs-attribute">4013cb</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">85</span> <span class="hljs-number">70</span> ff ff ff mov    %rax,-<span class="hljs-number">0</span>x90(%rbp)<br>  <span class="hljs-attribute">4013d2</span>:<span class="hljs-number">0</span>f <span class="hljs-number">84</span> <span class="hljs-number">10</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    je     <span class="hljs-number">4013</span>e8 &lt;main+<span class="hljs-number">0</span>x1c8&gt;<br>  <span class="hljs-attribute">4013d8</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">85</span> <span class="hljs-number">70</span> ff ff ff mov    -<span class="hljs-number">0</span>x90(%rbp),%rax<br>  <span class="hljs-attribute">4013df</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">08</span>             mov    (%rax),%rcx<br>  <span class="hljs-attribute">4013e2</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br>  <span class="hljs-attribute">4013e5</span>:ff <span class="hljs-number">51</span> <span class="hljs-number">10</span>             callq  *<span class="hljs-number">0</span>x10(%rcx)<br>  <span class="hljs-attribute">4013e8</span>:<span class="hljs-number">8</span>b <span class="hljs-number">45</span> fc             mov    -<span class="hljs-number">0</span>x4(%rbp),%eax<br>  <span class="hljs-attribute">4013eb</span>:<span class="hljs-number">48</span> <span class="hljs-number">81</span> c4 <span class="hljs-number">90</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> add    $<span class="hljs-number">0</span>x90,%rsp<br>  <span class="hljs-attribute">4013f2</span>:<span class="hljs-number">5</span>d                   pop    %rbp<br>  <span class="hljs-attribute">4013f3</span>:c3                   retq  <br><br><span class="hljs-attribute">0000000000401540</span> &lt;Derived::~Derived()&gt;:<br>    <span class="hljs-attribute">virtual</span> ~Derived() &#123;&#125;<br>  <span class="hljs-attribute">401540</span>:<span class="hljs-number">55</span>                   push   %rbp<br>  <span class="hljs-attribute">401541</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> e5             mov    %rsp,%rbp<br>  <span class="hljs-attribute">401544</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">10</span>          sub    $<span class="hljs-number">0</span>x10,%rsp<br>  <span class="hljs-attribute">401548</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">7</span>d f8          mov    %rdi,-<span class="hljs-number">0</span>x8(%rbp)<br>  <span class="hljs-attribute">40154c</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> f8          mov    -<span class="hljs-number">0</span>x8(%rbp),%rax<br>  <span class="hljs-attribute">401550</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c1             mov    %rax,%rcx<br>  <span class="hljs-attribute">401553</span>:<span class="hljs-number">48</span> <span class="hljs-number">81</span> c1 <span class="hljs-number">10</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> add    $<span class="hljs-number">0</span>x10,%rcx<br>  <span class="hljs-attribute">40155a</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> cf             mov    %rcx,%rdi<br>  <span class="hljs-attribute">40155d</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">45</span> f0          mov    %rax,-<span class="hljs-number">0</span>x10(%rbp)<br>  <span class="hljs-attribute">401561</span>:e8 aa <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">401710</span> &lt;Base2::~Base2()&gt;<br>  <span class="hljs-attribute">401566</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> f0          mov    -<span class="hljs-number">0</span>x10(%rbp),%rax<br>  <span class="hljs-attribute">40156a</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br>  <span class="hljs-attribute">40156d</span>:e8 <span class="hljs-number">1</span>e <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">401690</span> &lt;Base1::~Base1()&gt;<br>  <span class="hljs-attribute">401572</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">10</span>          add    $<span class="hljs-number">0</span>x10,%rsp<br>  <span class="hljs-attribute">401576</span>:<span class="hljs-number">5</span>d                   pop    %rbp<br>  <span class="hljs-attribute">401577</span>:c3                   retq   <br>  <span class="hljs-attribute">401578</span>:<span class="hljs-number">0</span>f <span class="hljs-number">1</span>f <span class="hljs-number">84</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> nopl   <span class="hljs-number">0</span>x0(%rax,%rax,<span class="hljs-number">1</span>)<br>  <span class="hljs-attribute">40157f</span>:<span class="hljs-number">00</span> <br><br><span class="hljs-attribute">0000000000401580</span> &lt;Derived::~Derived()&gt;:<br>  <span class="hljs-attribute">401580</span>:<span class="hljs-number">55</span>                   push   %rbp<br>  <span class="hljs-attribute">401581</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> e5             mov    %rsp,%rbp<br>  <span class="hljs-attribute">401584</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">10</span>          sub    $<span class="hljs-number">0</span>x10,%rsp<br>  <span class="hljs-attribute">401588</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">7</span>d f8          mov    %rdi,-<span class="hljs-number">0</span>x8(%rbp)<br>  <span class="hljs-attribute">40158c</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> f8          mov    -<span class="hljs-number">0</span>x8(%rbp),%rax<br>  <span class="hljs-attribute">401590</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br>  <span class="hljs-attribute">401593</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">45</span> f0          mov    %rax,-<span class="hljs-number">0</span>x10(%rbp)<br>  <span class="hljs-attribute">401597</span>:e8 a4 ff ff ff       callq  <span class="hljs-number">401540</span> &lt;Derived::~Derived()&gt;<br>  <span class="hljs-attribute">40159c</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> f0          mov    -<span class="hljs-number">0</span>x10(%rbp),%rax<br>  <span class="hljs-attribute">4015a0</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br>  <span class="hljs-attribute">4015a3</span>:e8 b8 fa ff ff       callq  <span class="hljs-number">401060</span> &lt;operator delete(void*)@plt&gt;<br>  <span class="hljs-attribute">4015a8</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">10</span>          add    $<span class="hljs-number">0</span>x10,%rsp<br>  <span class="hljs-attribute">4015ac</span>:<span class="hljs-number">5</span>d                   pop    %rbp<br>  <span class="hljs-attribute">4015ad</span>:c3                   retq   <br>  <span class="hljs-attribute">4015ae</span>:<span class="hljs-number">66</span> <span class="hljs-number">90</span>                xchg   %ax,%ax<br><br><span class="hljs-attribute">0000000000401610</span> &lt;non-virtual thunk to Derived::~Derived()&gt;:<br>  <span class="hljs-attribute">401610</span>:<span class="hljs-number">55</span>                   push   %rbp<br>  <span class="hljs-attribute">401611</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> e5             mov    %rsp,%rbp<br>  <span class="hljs-attribute">401614</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">7</span>d f8          mov    %rdi,-<span class="hljs-number">0</span>x8(%rbp)<br>  <span class="hljs-attribute">401618</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> f8          mov    -<span class="hljs-number">0</span>x8(%rbp),%rax<br>  <span class="hljs-attribute">40161c</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c0 f0          add    $<span class="hljs-number">0</span>xfffffffffffffff0,%rax<br>  <span class="hljs-attribute">401620</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br>  <span class="hljs-attribute">401623</span>:<span class="hljs-number">5</span>d                   pop    %rbp<br>  <span class="hljs-attribute">401624</span>:e9 <span class="hljs-number">17</span> ff ff ff       jmpq   <span class="hljs-number">401540</span> &lt;Derived::~Derived()&gt;<br>  <span class="hljs-attribute">401629</span>:<span class="hljs-number">0</span>f <span class="hljs-number">1</span>f <span class="hljs-number">80</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> nopl   <span class="hljs-number">0</span>x0(%rax)<br><br><span class="hljs-attribute">0000000000401630</span> &lt;non-virtual thunk to Derived::~Derived()&gt;:<br>  <span class="hljs-attribute">401630</span>:<span class="hljs-number">55</span>                   push   %rbp<br>  <span class="hljs-attribute">401631</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> e5             mov    %rsp,%rbp<br>  <span class="hljs-attribute">401634</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">7</span>d f8          mov    %rdi,-<span class="hljs-number">0</span>x8(%rbp)<br>  <span class="hljs-attribute">401638</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> f8          mov    -<span class="hljs-number">0</span>x8(%rbp),%rax<br>  <span class="hljs-attribute">40163c</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c0 f0          add    $<span class="hljs-number">0</span>xfffffffffffffff0,%rax<br>  <span class="hljs-attribute">401640</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br>  <span class="hljs-attribute">401643</span>:<span class="hljs-number">5</span>d                   pop    %rbp<br>  <span class="hljs-attribute">401644</span>:e9 <span class="hljs-number">37</span> ff ff ff       jmpq   <span class="hljs-number">401580</span> &lt;Derived::~Derived()&gt;<br>  <span class="hljs-attribute">401649</span>:<span class="hljs-number">0</span>f <span class="hljs-number">1</span>f <span class="hljs-number">80</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> nopl   <span class="hljs-number">0</span>x0(%rax)<br></code></pre></td></tr></table></figure>因为virtual析构函数的加入，我将打印的步骤简化了，否则显示会混乱。运行结果如下：<img src="/img/00006/13.png" alt="在这里插入图片描述" />这种情况下GDB打印出来的虚表内容有错误，或者是它故意隐瞒，其原因不得而知，我将补充后的结果贴在这里：<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&gt;gef➤  info vtbl *new_pderived<br>&gt;vtable <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;Derived&#x27;</span> @ <span class="hljs-number">0</span>x4020b0 (subobject @ <span class="hljs-number">0</span>x416eb0):<br>&gt;<span class="hljs-selector-attr">[0]</span>: <span class="hljs-number">0</span>x401500 &lt;Derived::<span class="hljs-built_in">f</span>()&gt;<br>&gt;<span class="hljs-selector-attr">[1]</span>: <span class="hljs-number">0</span>x401540 &lt;Derived::~<span class="hljs-built_in">Derived</span>()&gt;<br>&gt;<span class="hljs-selector-attr">[2]</span>: <span class="hljs-number">0</span>x401580 &lt;Derived::~<span class="hljs-built_in">Derived</span>()&gt;<br>&gt;<span class="hljs-selector-attr">[3]</span>: <span class="hljs-number">0</span>x4015b0 &lt;Derived::<span class="hljs-built_in">h</span>()&gt;<br>&gt;vtable <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;Base2&#x27;</span> @ <span class="hljs-number">0</span>x4020e0 (subobject @ <span class="hljs-number">0</span>x416ec0):<br>&gt;<span class="hljs-selector-attr">[0]</span>: <span class="hljs-number">0</span>x4015f0 &lt;non-virtual thunk to Derived::<span class="hljs-built_in">h</span>()&gt;<br>&gt;<span class="hljs-selector-attr">[1]</span>: <span class="hljs-number">0</span>x401610 &lt;non-virtual thunk to Derived::~<span class="hljs-built_in">Derived</span>()&gt;<span class="hljs-comment">//笔者补充上的</span><br>&gt;<span class="hljs-selector-attr">[2]</span>: <span class="hljs-number">0</span>x401630 &lt;non-virtual thunk to Derived::~<span class="hljs-built_in">Derived</span>()&gt;<span class="hljs-comment">//笔者补充上的</span><br></code></pre></td></tr></table></figure>我们重点关注最后两行：<code>Base2 *new_pbase2 = new Derived();delete new_pbase2;</code>看编译如何完成this指针的回调：<img src="/img/00006/14.png" alt="在这里插入图片描述" />反汇编代码运行到<code>0x4013c3 &lt;main+419&gt;       mov    rax, QWORD PTR [rbp-0x58]</code>之前发生的事情有：Derived类对象在<code>0x416eb0</code>堆内存地址上进行构造，<code>0x416eb0+0x10</code>后的堆指针（Base2类对象的this指针）存储在<code>$rbp-0x58</code>（0x7fffffffe0d8）栈内存中。这一过程的结果我用一张图进行表达：<img src="/img/00006/15.png" alt="请添加图片描述" /></p></blockquote><blockquote><p><img src="/img/00006/16.png" alt="在这里插入图片描述" />该图在<code>0x4013e5 &lt;main+453&gt;       call   QWORD PTR [rcx+0x10]</code>还未执行时发生的事情有：编译器将Base2类对象的this指针存储在<code>rdi</code>参数寄存器中，作为<code>&lt;non-virtual thunk to Derived::~Derived()&gt;</code>函数（<code>rcx+0x10</code>）的第一参数。该函数指针指向文本段<code>0x401630</code>处。<img src="/img/00006/17.png" alt="在这里插入图片描述" />反汇编代码运行到<code>0x401644 &lt;non-virtual+0&gt;  jmp    0x401580 &lt;Derived::~Derived()&gt;</code>之前发生的事情有：rdi参数寄存器将其值保存到<code>rax</code>临时寄存器中，<code>rax</code>将该值（<code>0x416ec0</code>）加上<code>0xfffffffffffffff0</code>，由于溢出，相当于<code>-0x10</code>，得到的新值（<code>0x416eb0</code>）存储到<code>rax</code>寄存器中。随后调用带<code>operator delete(void*)</code>的virtual析构函数。至此完成this指针回调，delete可以正常销毁掉new出来Derived类对象。</p></blockquote><hr /><h1id="多重虚继承下的访问虚基类成员变量时虚表的工作原理以及子类成员布局">多重虚继承下的访问虚基类成员变量时虚表的工作原理，以及子类成员布局</h1><blockquote><p>在分析之前，咱们先回顾一下《深度探索c++对象模型》p120提出来的一个问题：每一个对象必须针对其每一个virtual baseclass背负一个额外的指针，然而理想上我们却希望classobject有固定的负担，不因为其virtual baseclasses的个数而有所变化。想想看这该如何解决？ -一般而言有两种解决方法。Microsoft 编译器引入所谓的virtual base classtable。每一个class object如果有一个或者多个virtual baseclasses，就会由编译器安插一个指针，指向virtual base classtable。至于真正的virtual base class指针，当然是被放在该表格中。 -第二个解决方法，是在virtual function table 中放置virtual base class 的offset（而不是第一种办法中说的virtual baseclass指针）。编译器可以通过virtual functiontable的正负值来索引该offset。如果是正值，显然索引到的是virtualfunction；如果是负值，则是索引到virtual base class offsets。</p><p>正如上面第二种方法所述，clang编译器采取的就是基于vtbl的offset来获取虚基类的this指针，进而完成虚基类数据成员的访问。咱们来看具体分析过程，如下： 先设计一个菱形继承的Derived类。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//爷爷类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">grandpa</span><span class="hljs-comment">//类名首字母忘记大写了，抱歉</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">grandpa</span>():<span class="hljs-built_in">pa</span>(<span class="hljs-number">1</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;grandpa::f()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;grandpa::g()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">grandpa</span>() &#123;&#125;<br>    <span class="hljs-type">int</span> pa;<br>&#125;;<br><span class="hljs-comment">//父类1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span>:<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> grandpa<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base1</span>():<span class="hljs-built_in">b1</span>(<span class="hljs-number">2</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;base1::h()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">i</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;base1::i()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base1</span>() &#123;&#125;<br>    <span class="hljs-type">int</span> b1;<br>&#125;;<br><span class="hljs-comment">//父类2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base2</span>:<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> grandpa<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base2</span>():<span class="hljs-built_in">b2</span>(<span class="hljs-number">3</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">j</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;base2::j()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">k</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;base2::k()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base2</span>() &#123;&#125;<br>    <span class="hljs-type">int</span> b2;<br>&#125;;<br><span class="hljs-comment">//子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>:<span class="hljs-keyword">public</span> Base1,<span class="hljs-keyword">public</span> Base2<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>():<span class="hljs-built_in">m</span>(<span class="hljs-number">4</span>),<span class="hljs-built_in">n</span>(<span class="hljs-number">5</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span><span class="hljs-comment">//覆盖爷爷类的虚函数</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;derived::f()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span><span class="hljs-comment">//覆盖父类1的虚函数</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;derived::h()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">j</span><span class="hljs-params">()</span><span class="hljs-comment">//覆盖父类2的虚函数</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;derived::j()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">l</span><span class="hljs-params">()</span><span class="hljs-comment">//derived类自己的虚函数</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;derived::l()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Derived</span>() &#123;&#125;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> n;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Derived *new_pderived = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    new_pderived-&gt;pa = <span class="hljs-number">11</span>;<br>    <span class="hljs-keyword">delete</span> new_pderived;<br><br>    Base1 *new_pbase1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    new_pbase1-&gt;pa = <span class="hljs-number">11</span>;<br>    <span class="hljs-keyword">delete</span> new_pbase1;<br><br>    Base2 *new_pbase2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    new_pbase2-&gt;pa = <span class="hljs-number">11</span>;<br>    <span class="hljs-keyword">delete</span> new_pbase2;<br>&#125;<br></code></pre></td></tr></table></figure> 需要用到的反汇编代码如下： <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs apache">  <span class="hljs-attribute">Derived</span> *new_pderived = new Derived();<br><span class="hljs-attribute">401227</span>:e8 <span class="hljs-number">44</span> fe ff ff       callq  <span class="hljs-number">401070</span> &lt;operator new(unsigned long)@plt&gt;<br><span class="hljs-attribute">40122c</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c1             mov    %rax,%rcx<br><span class="hljs-attribute">40122f</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c2             mov    %rax,%rdx<br><span class="hljs-attribute">401232</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br><span class="hljs-attribute">401235</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">4</span>d c8          mov    %rcx,-<span class="hljs-number">0</span>x38(%rbp)<br><span class="hljs-attribute">401239</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">55</span> c0          mov    %rdx,-<span class="hljs-number">0</span>x40(%rbp)<br><span class="hljs-attribute">40123d</span>:e8 <span class="hljs-number">7</span>e <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">4013</span>c0 &lt;Derived::Derived()&gt;<br><span class="hljs-attribute">401242</span>:e9 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       jmpq   <span class="hljs-number">401247</span> &lt;main+<span class="hljs-number">0</span>x37&gt;<br><span class="hljs-attribute">401247</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> c0          mov    -<span class="hljs-number">0</span>x40(%rbp),%rax<br><span class="hljs-attribute">40124b</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">45</span> f0          mov    %rax,-<span class="hljs-number">0</span>x10(%rbp)<br>  <span class="hljs-attribute">new_pderived</span>-&gt;pa = <span class="hljs-number">11</span>;<br><span class="hljs-attribute">40124f</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">4</span>d f0          mov    -<span class="hljs-number">0</span>x10(%rbp),%rcx<br><span class="hljs-attribute">401253</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">11</span>             mov    (%rcx),%rdx<br><span class="hljs-attribute">401256</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">52</span> e8          mov    -<span class="hljs-number">0</span>x18(%rdx),%rdx<br><span class="hljs-attribute">40125a</span>:c7 <span class="hljs-number">44</span> <span class="hljs-number">11</span> <span class="hljs-number">08</span> <span class="hljs-number">0</span>b <span class="hljs-number">00</span> <span class="hljs-number">00</span> movl   $<span class="hljs-number">0</span>xb,<span class="hljs-number">0</span>x8(%rcx,%rdx,<span class="hljs-number">1</span>)<br><span class="hljs-attribute">401261</span>:<span class="hljs-number">00</span> <br>  <span class="hljs-attribute">delete</span> new_pderived;<br><span class="hljs-attribute">401262</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">4</span>d f0          mov    -<span class="hljs-number">0</span>x10(%rbp),%rcx<br><span class="hljs-attribute">401266</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> f9 <span class="hljs-number">00</span>          cmp    $<span class="hljs-number">0</span>x0,%rcx<br><span class="hljs-attribute">40126a</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">4</span>d b8          mov    %rcx,-<span class="hljs-number">0</span>x48(%rbp)<br><span class="hljs-attribute">40126e</span>:<span class="hljs-number">0</span>f <span class="hljs-number">84</span> <span class="hljs-number">0</span>d <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    je     <span class="hljs-number">401281</span> &lt;main+<span class="hljs-number">0</span>x71&gt;<br><span class="hljs-attribute">401274</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> b8          mov    -<span class="hljs-number">0</span>x48(%rbp),%rax<br><span class="hljs-attribute">401278</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">08</span>             mov    (%rax),%rcx<br><span class="hljs-attribute">40127b</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br><span class="hljs-attribute">40127e</span>:ff <span class="hljs-number">51</span> <span class="hljs-number">18</span>             callq  *<span class="hljs-number">0</span>x18(%rcx)<br><span class="hljs-attribute">401281</span>:bf <span class="hljs-number">38</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x38,%edi<br><br>  <span class="hljs-attribute">Base1</span> *new_pbase1 = new Derived();<br><span class="hljs-attribute">401286</span>:e8 e5 fd ff ff       callq  <span class="hljs-number">401070</span> &lt;operator new(unsigned long)@plt&gt;<br><span class="hljs-attribute">40128b</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c1             mov    %rax,%rcx<br><span class="hljs-attribute">40128e</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c2             mov    %rax,%rdx<br><span class="hljs-attribute">401291</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br><span class="hljs-attribute">401294</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">4</span>d b0          mov    %rcx,-<span class="hljs-number">0</span>x50(%rbp)<br><span class="hljs-attribute">401298</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">55</span> a8          mov    %rdx,-<span class="hljs-number">0</span>x58(%rbp)<br><span class="hljs-attribute">40129c</span>:e8 <span class="hljs-number">1</span>f <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">4013</span>c0 &lt;Derived::Derived()&gt;<br><span class="hljs-attribute">4012a1</span>:e9 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       jmpq   <span class="hljs-number">4012</span>a6 &lt;main+<span class="hljs-number">0</span>x96&gt;<br><span class="hljs-attribute">4012a6</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> a8          mov    -<span class="hljs-number">0</span>x58(%rbp),%rax<br><span class="hljs-attribute">4012aa</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">45</span> d8          mov    %rax,-<span class="hljs-number">0</span>x28(%rbp)<br>  <span class="hljs-attribute">new_pbase1</span>-&gt;pa = <span class="hljs-number">11</span>;<br><span class="hljs-attribute">4012ae</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> d8          mov    -<span class="hljs-number">0</span>x28(%rbp),%rax<br><span class="hljs-attribute">4012b2</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">08</span>             mov    (%rax),%rcx<br><span class="hljs-attribute">4012b5</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">49</span> e8          mov    -<span class="hljs-number">0</span>x18(%rcx),%rcx<br><span class="hljs-attribute">4012b9</span>:c7 <span class="hljs-number">44</span> <span class="hljs-number">08</span> <span class="hljs-number">08</span> <span class="hljs-number">0</span>b <span class="hljs-number">00</span> <span class="hljs-number">00</span> movl   $<span class="hljs-number">0</span>xb,<span class="hljs-number">0</span>x8(%rax,%rcx,<span class="hljs-number">1</span>)<br><span class="hljs-attribute">4012c0</span>:<span class="hljs-number">00</span> <br>  <span class="hljs-attribute">delete</span> new_pbase1;<br><span class="hljs-attribute">4012c1</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> d8          mov    -<span class="hljs-number">0</span>x28(%rbp),%rax<br><span class="hljs-attribute">4012c5</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> f8 <span class="hljs-number">00</span>          cmp    $<span class="hljs-number">0</span>x0,%rax<br><span class="hljs-attribute">4012c9</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">45</span> a0          mov    %rax,-<span class="hljs-number">0</span>x60(%rbp)<br><span class="hljs-attribute">4012cd</span>:<span class="hljs-number">0</span>f <span class="hljs-number">84</span> <span class="hljs-number">0</span>d <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    je     <span class="hljs-number">4012</span>e0 &lt;main+<span class="hljs-number">0</span>xd0&gt;<br><span class="hljs-attribute">4012d3</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> a0          mov    -<span class="hljs-number">0</span>x60(%rbp),%rax<br><span class="hljs-attribute">4012d7</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">08</span>             mov    (%rax),%rcx<br><span class="hljs-attribute">4012da</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br><span class="hljs-attribute">4012dd</span>:ff <span class="hljs-number">51</span> <span class="hljs-number">18</span>             callq  *<span class="hljs-number">0</span>x18(%rcx)<br><span class="hljs-attribute">4012e0</span>:bf <span class="hljs-number">38</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x38,%edi<br><br>  <span class="hljs-attribute">Base2</span> *new_pbase2 = new Derived();<br><span class="hljs-attribute">4012e5</span>:e8 <span class="hljs-number">86</span> fd ff ff       callq  <span class="hljs-number">401070</span> &lt;operator new(unsigned long)@plt&gt;<br><span class="hljs-attribute">4012ea</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c1             mov    %rax,%rcx<br><span class="hljs-attribute">4012ed</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c2             mov    %rax,%rdx<br><span class="hljs-attribute">4012f0</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br><span class="hljs-attribute">4012f3</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">4</span>d <span class="hljs-number">98</span>          mov    %rcx,-<span class="hljs-number">0</span>x68(%rbp)<br><span class="hljs-attribute">4012f7</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">55</span> <span class="hljs-number">90</span>          mov    %rdx,-<span class="hljs-number">0</span>x70(%rbp)<br><span class="hljs-attribute">4012fb</span>:e8 c0 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">4013</span>c0 &lt;Derived::Derived()&gt;<br><span class="hljs-attribute">401300</span>:e9 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       jmpq   <span class="hljs-number">401305</span> &lt;main+<span class="hljs-number">0</span>xf5&gt;<br><span class="hljs-attribute">401305</span>:<span class="hljs-number">31</span> c0                xor    %eax,%eax<br><span class="hljs-attribute">401307</span>:<span class="hljs-number">89</span> c1                mov    %eax,%ecx<br><span class="hljs-attribute">401309</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">55</span> <span class="hljs-number">90</span>          mov    -<span class="hljs-number">0</span>x70(%rbp),%rdx<br><span class="hljs-attribute">40130d</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> fa <span class="hljs-number">00</span>          cmp    $<span class="hljs-number">0</span>x0,%rdx<br><span class="hljs-attribute">401311</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">4</span>d <span class="hljs-number">88</span>          mov    %rcx,-<span class="hljs-number">0</span>x78(%rbp)<br><span class="hljs-attribute">401315</span>:<span class="hljs-number">0</span>f <span class="hljs-number">84</span> <span class="hljs-number">0</span>e <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    je     <span class="hljs-number">401329</span> &lt;main+<span class="hljs-number">0</span>x119&gt;<br><span class="hljs-attribute">40131b</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> <span class="hljs-number">90</span>          mov    -<span class="hljs-number">0</span>x70(%rbp),%rax<br><span class="hljs-attribute">40131f</span>:<span class="hljs-number">48</span> <span class="hljs-number">05</span> <span class="hljs-number">10</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    add    $<span class="hljs-number">0</span>x10,%rax<br><span class="hljs-attribute">401325</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">45</span> <span class="hljs-number">88</span>          mov    %rax,-<span class="hljs-number">0</span>x78(%rbp)<br><span class="hljs-attribute">401329</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> <span class="hljs-number">88</span>          mov    -<span class="hljs-number">0</span>x78(%rbp),%rax<br><span class="hljs-attribute">40132d</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">45</span> d0          mov    %rax,-<span class="hljs-number">0</span>x30(%rbp)<br>  <span class="hljs-attribute">new_pbase2</span>-&gt;pa = <span class="hljs-number">11</span>;<br><span class="hljs-attribute">401331</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> d0          mov    -<span class="hljs-number">0</span>x30(%rbp),%rax<br><span class="hljs-attribute">401335</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">08</span>             mov    (%rax),%rcx<br><span class="hljs-attribute">401338</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">49</span> e8          mov    -<span class="hljs-number">0</span>x18(%rcx),%rcx<br><span class="hljs-attribute">40133c</span>:c7 <span class="hljs-number">44</span> <span class="hljs-number">08</span> <span class="hljs-number">08</span> <span class="hljs-number">0</span>b <span class="hljs-number">00</span> <span class="hljs-number">00</span> movl   $<span class="hljs-number">0</span>xb,<span class="hljs-number">0</span>x8(%rax,%rcx,<span class="hljs-number">1</span>)<br><span class="hljs-attribute">401343</span>:<span class="hljs-number">00</span> <br>  <span class="hljs-attribute">delete</span> new_pbase2;<br><span class="hljs-attribute">401344</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> d0          mov    -<span class="hljs-number">0</span>x30(%rbp),%rax<br><span class="hljs-attribute">401348</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> f8 <span class="hljs-number">00</span>          cmp    $<span class="hljs-number">0</span>x0,%rax<br><span class="hljs-attribute">40134c</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">45</span> <span class="hljs-number">80</span>          mov    %rax,-<span class="hljs-number">0</span>x80(%rbp)<br><span class="hljs-attribute">401350</span>:<span class="hljs-number">0</span>f <span class="hljs-number">84</span> <span class="hljs-number">0</span>d <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    je     <span class="hljs-number">401363</span> &lt;main+<span class="hljs-number">0</span>x153&gt;<br><span class="hljs-attribute">401356</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> <span class="hljs-number">80</span>          mov    -<span class="hljs-number">0</span>x80(%rbp),%rax<br><span class="hljs-attribute">40135a</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">08</span>             mov    (%rax),%rcx<br><span class="hljs-attribute">40135d</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br><span class="hljs-attribute">401360</span>:ff <span class="hljs-number">51</span> <span class="hljs-number">18</span>             callq  *<span class="hljs-number">0</span>x18(%rcx)<br><span class="hljs-attribute">401363</span>:<span class="hljs-number">8</span>b <span class="hljs-number">45</span> fc             mov    -<span class="hljs-number">0</span>x4(%rbp),%eax<br><span class="hljs-attribute">401366</span>:<span class="hljs-number">48</span> <span class="hljs-number">81</span> c4 <span class="hljs-number">80</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> add    $<span class="hljs-number">0</span>x80,%rsp<br><span class="hljs-attribute">40136d</span>:<span class="hljs-number">5</span>d                   pop    %rbp<br><span class="hljs-attribute">40136e</span>:c3                   retq   <br><span class="hljs-attribute">40136f</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">45</span> e8          mov    %rax,-<span class="hljs-number">0</span>x18(%rbp)<br><span class="hljs-attribute">401373</span>:<span class="hljs-number">89</span> <span class="hljs-number">55</span> e4             mov    %edx,-<span class="hljs-number">0</span>x1c(%rbp)<br><span class="hljs-attribute">401376</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">7</span>d c8          mov    -<span class="hljs-number">0</span>x38(%rbp),%rdi<br></code></pre></td></tr></table></figure>Derived类的vtbl内容如下(编译器没有完全打印出来，笔者将补充后的列在下面)：<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gef➤  info vtbl *new_pderived<br>vtable <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;Derived&#x27;</span> @ <span class="hljs-number">0</span>x402020 (subobject @ <span class="hljs-number">0</span>x416eb0):<br><span class="hljs-selector-attr">[0]</span>: <span class="hljs-number">0</span>x401850 &lt;Derived::<span class="hljs-built_in">h</span>()&gt;<br><span class="hljs-selector-attr">[1]</span>: <span class="hljs-number">0</span>x4015b0 &lt;Base1::<span class="hljs-selector-tag">i</span>()&gt;<br><span class="hljs-selector-attr">[2]</span>: <span class="hljs-number">0</span>x401890 &lt;Derived::~<span class="hljs-built_in">Derived</span>()&gt;<br><span class="hljs-selector-attr">[3]</span>: <span class="hljs-number">0</span>x4018d0 &lt;Derived::~<span class="hljs-built_in">Derived</span>()&gt;<br><span class="hljs-selector-attr">[4]</span>: <span class="hljs-number">0</span>x401900 &lt;Derived::<span class="hljs-built_in">f</span>()&gt;<br><span class="hljs-selector-attr">[5]</span>: <span class="hljs-number">0</span>x401940 &lt;Derived::<span class="hljs-built_in">j</span>()&gt;<br><span class="hljs-selector-attr">[6]</span>: <span class="hljs-number">0</span>x401980 &lt;Derived::<span class="hljs-built_in">l</span>()&gt;<br>vtable <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;Base2&#x27;</span> @ <span class="hljs-number">0</span>x402070 (subobject @ <span class="hljs-number">0</span>x416ec0):<br><span class="hljs-selector-attr">[0]</span>: <span class="hljs-number">0</span>x4019c0 &lt;non-virtual thunk to Derived::<span class="hljs-built_in">j</span>()&gt;<br><span class="hljs-selector-attr">[1]</span>: <span class="hljs-number">0</span>x401760 &lt;Base2::<span class="hljs-built_in">k</span>()&gt;<br><span class="hljs-selector-attr">[2]</span>: <span class="hljs-number">0</span>x4019e0 &lt;non-virtual thunk to Derived::~<span class="hljs-built_in">Derived</span>()&gt;<span class="hljs-comment">//笔者补充的</span><br><span class="hljs-selector-attr">[3]</span>: <span class="hljs-number">0</span>x401a00 &lt;non-virtual thunk to Derived::~<span class="hljs-built_in">Derived</span>()&gt;<span class="hljs-comment">//笔者补充的</span><br>vtable <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;grandpa&#x27;</span> @ <span class="hljs-number">0</span>x4020b8 (subobject @ <span class="hljs-number">0</span>x416ed8):<br><span class="hljs-selector-attr">[0]</span>: <span class="hljs-number">0</span>x401a20 &lt;virtual thunk to Derived::<span class="hljs-built_in">f</span>()&gt;<br><span class="hljs-selector-attr">[1]</span>: <span class="hljs-number">0</span>x4016a0 &lt;grandpa::<span class="hljs-built_in">g</span>()&gt;<br><span class="hljs-selector-attr">[2]</span>: <span class="hljs-number">0</span>x401a40 &lt;virtual thunk to Derived::~<span class="hljs-built_in">Derived</span>()&gt;<span class="hljs-comment">//笔者补充的</span><br><span class="hljs-selector-attr">[3]</span>: <span class="hljs-number">0</span>x401a60 &lt;virtual thunk to Derived::~<span class="hljs-built_in">Derived</span>()&gt;<span class="hljs-comment">//笔者补充的</span><br></code></pre></td></tr></table></figure>至于为什么Base2类和grandpa类会多出两个thunk函数，上一小节已经分析过。这里补充一点，因为Derived类对象的数据布局最上面是Base1类对象，中间是Base2类对象，virtualgrandpa对象永远是在最下面。这样就导致Base2类在支持多态时调用被重写的虚函数以及调用Derived类的virtual析构函数时，需要调整this指针。grandpa类道理一样。咱们用GDB查看Derived类对象的内存布局，并用图画方式直观表达出来： <imgsrc="/img/00006/18.png" alt="在这里插入图片描述" /> <imgsrc="/img/00006/19.png" alt="请添加图片描述" />上图中，笔者将offset出现的地方明确标明出来了，下面咱们就来看下编译是如何取出这个offsets的！<img src="/img/00006/20.png" alt="请添加图片描述" />反汇编代码<code>0x401256 &lt;main+70&gt;        mov    rdx, QWORD PTR [rdx-0x18]</code>还未执行时，发生的事情有：Derived类对象在<code>0x416eb0</code>堆内存中进行了构造。new_pderived指针的地址为<code>rbp-0x10</code>，它指向<code>0x416eb0</code>堆内存。编译器将Derived类<code>vptr1</code>指向的虚表地址存储到<code>rdx</code>中。接下来将会发生的事情有：编译器将该虚表地址偏移<code>-0x18</code>字节并获取该地址中的内容（<code>offset</code>），将其值（<code>0x28</code>）存入<code>rdx</code>寄存器中。最后将<code>十进制11</code>存入this指针偏移后的地址中（<code>rcx+rdx*1+0x8</code>：<code>0x416eb0+0x28*1+0x8 = 0x416ee0</code>，即<code>pa</code>的地址）。<img src="/img/00006/21.png" alt="在这里插入图片描述" />代码段<code>new_pbase1-&gt;pa = 11;</code>和<code>new_pbase2-&gt;pa = 11;</code>同样会出现取<code>offset</code>进行偏移后，然后存取grandpa的成员变量pa的情况。<code>new_pbase1-&gt;pa</code>取到的<code>offset</code>值和<code>new_pderived-&gt;pa</code>一样是<code>0x28</code>。而<code>new_pbase2-&gt;pa</code>取到的值为<code>0x18</code>。<img src="/img/00006/22.png" alt="在这里插入图片描述" />如果是虚基类grandpa在支持多态时，且<code>new_pgrandpa-&gt;pa</code>进行存取操作，则不用偏移this指针，也就不需要取<code>offset</code>。该虚基类的虚表中也没有存<code>offset</code>。<img src="/img/00006/23.png" alt="在这里插入图片描述" />可以看到<code>0x4020b8-0x18</code>地址上的值是个牛马值 🤪--------------------------------------------------------</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++11,14,17中auto和decltype相关知识及拓展</title>
    <link href="/2022/02/09/00005.%20C++11,14,17%E4%B8%ADauto%E5%92%8Cdecltype%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E5%8F%8A%E6%8B%93%E5%B1%95/"/>
    <url>/2022/02/09/00005.%20C++11,14,17%E4%B8%ADauto%E5%92%8Cdecltype%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E5%8F%8A%E6%8B%93%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><blockquote><p><strong>本篇文章为笔者的读书笔记，未经允许请勿转载。</strong><br />这篇文章是上篇文章《<ahref="https://blog.csdn.net/Howl_1/article/details/122625409">C++prvalue，xvalue和lvalue的相关知识</a>》的续作，上次我们已经把prvalue，xvalue和lvalue说清楚了，本篇文章就来探讨一下prvalue，xvalue和lvalue与decltype之间的联系。顺便咱们也把auto类型说明符也都拓展一下。</p></blockquote><hr /><h1id="从初始化器和表达式中推导-deduction-from-initializers-and-expressions">从初始化器和表达式中推导（Deduction from Initializers and Expressions）</h1><blockquote><p>C++11包括声明一个类型是从其初始化器推导出变量类型的能力（auto）。它还提供了一种机制来表示已命名对象（变量或函数）或表达式的类型（decltype）。这些设施原来非常方便，而C++14和C++17在这个主题上增加了额外的变体。</p></blockquote><hr /><h1 id="auto类型说明符">auto类型说明符</h1><blockquote><p>编程时常常需要把表达式的值赋给变量，这就要求在声明变量的时候清楚地知道表达式的类型。c++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-comment">//由val1和val2相加的结果可以推断出item的类型</span><br>&gt;<span class="hljs-keyword">auto</span> item = val1 + val2; <span class="hljs-comment">// item初始化为val1和val2相加的结果</span><br></code></pre></td></tr></table></figure> 此处编译器将根据<code>val1</code>和<code>val2</code>相加的结果来推断<code>item</code>的类型。如果<code>val1</code>和<code>val2</code>是类<code>sales_item</code>的对象，则<code>item</code>的类型就是<code>sales_item</code>;如果这两个变量的类型是<code>double</code>，则<code>item</code>的类型就是<code>double</code>，以此类推。</p></blockquote><hr /><h2 id="复合类型常量和auto">复合类型，常量和auto</h2><blockquote><p>编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。</p><p>首先，正如我们所熟知的，使用引用其实是使用引用的对象，特别是当引用被用作初始值时,真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>,&amp;r = i;<br>&gt;<span class="hljs-keyword">auto</span> a = r;<br>&gt;<span class="hljs-comment">// a的类型为int(r是i的别名，而i是一个整数）</span><br></code></pre></td></tr></table></figure>其次，auto一般会忽略掉<code>顶层const</code>，同时<code>底层const</code>则会保留下来，比如当初始值是一个指向常量的指针时:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = i, &amp;cr = ci;<br>&gt;<span class="hljs-keyword">auto</span> b = ci;<span class="hljs-comment">// b的类型为int（ci的顶层const 特性被忽略掉了)</span><br>&gt;<span class="hljs-keyword">auto</span> c = cr;<span class="hljs-comment">// c的类型为int（ cr是ci的别名，ci本身是一个顶层const )</span><br>&gt;<span class="hljs-keyword">auto</span> d = &amp;i;<span class="hljs-comment">// d是一个整型指针(int *)</span><br>&gt;<span class="hljs-keyword">auto</span> e = &amp;ci;<span class="hljs-comment">// e是一个指向整数常量的指针（const int *）（对常量对象取完地址后，常量对象的顶层const在auto处转变为底层const)</span><br></code></pre></td></tr></table></figure>如果希望推断出的auto类型是一个<code>顶层const</code>，需要明确指出:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> f = ci;<span class="hljs-comment">// ci的推演类型是int，f是const int</span><br></code></pre></td></tr></table></figure> 还可以将引用的类型设为auto，此时原来的初始化规则仍然适用:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">auto</span> &amp;g = ci;<span class="hljs-comment">// g是一个整型常量引用，绑定到ci</span><br>&gt;<span class="hljs-keyword">auto</span> &amp;h = <span class="hljs-number">42</span>;<span class="hljs-comment">//错误:不能为非常量引用绑定字面值(42的类型为int，左值引用不能绑定到右值)</span><br>&gt;<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;j=<span class="hljs-number">42</span>;<span class="hljs-comment">//正确:可以为常量引用绑定字面值（42发生临时物化，产生一个xvalue的临时对象让常量引用绑定）</span><br></code></pre></td></tr></table></figure>设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留。和往常一样，如果我们给初始值绑定一个引用(<code>auto &amp;g = ci;</code>)，则此时的const就不是<code>顶层const</code>了（g的类型为<code>const int &amp;</code>，此处的const为<code>底层const</code>）。要在一条语句中定义多个变量，切记，符号<code>&amp;</code>和<code>*</code>只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">auto</span> k = ci, &amp;l = i;<span class="hljs-comment">// k是int，l是int&amp;</span><br>&gt;<span class="hljs-keyword">auto</span> &amp;m = ci,*p = &amp;ci;<span class="hljs-comment">// m是对整型常量的引用（const int &amp;），p是指向整型常量的指针（const int *）。</span><br>&gt;<span class="hljs-keyword">auto</span> &amp;n= i, *p2 = &amp;ci;<span class="hljs-comment">//错误:i的基本数据类型是int而&amp;ci的基本数据类型是const int</span><br></code></pre></td></tr></table></figure>以上部分为auto类型说明符的基础部分，大部分例子为《c++primer》p61页的，我在其基础上添加了注释以及对其进行部分修改，以便读者能快速领悟其含义。其他基础部分若有不懂请自行补充，不再赘述。</p></blockquote><hr /><h2 id="进一步探讨auto类型说明符">进一步探讨auto类型说明符</h2><blockquote><p>auto类型说明符可用于许多地方（主要是namespace作用域和local作用域），以从其初始化器推导变量的类型。在这种情况下，auto被称为占位符类型（<ahref="https://en.cppreference.com/w/cpp/language/auto">a placeholdertype</a>）(另一种占位符类型<code>deltype(auto)</code>，文章后面将会描述)。例如，您可以使用：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container&gt; <br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useContainer</span><span class="hljs-params">(Container <span class="hljs-type">const</span>&amp; container)</span> </span><br><span class="hljs-function">&gt;</span>&#123; <br><span class="hljs-keyword">auto</span> pos = container.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">//auto示例一</span><br><span class="hljs-keyword">while</span> (pos != &gt;container.<span class="hljs-built_in">end</span>()) <br>&#123; <br><span class="hljs-keyword">auto</span>&amp; element = *pos++; <span class="hljs-comment">//auto示例二</span><br>… <span class="hljs-comment">// operate on the element </span><br>&#125; <br>&gt;&#125;<br></code></pre></td></tr></table></figure>上面示例中auto的两种使用消除了编写两种长且可能复杂的类型，即容器的迭代器类型和迭代器的值类型：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">typename</span> Container::const_iterator pos = container.<span class="hljs-built_in">begin</span>();<br>…<br><span class="hljs-keyword">typename</span> std::iterator_traits&lt;<span class="hljs-keyword">typename</span> Container::iterator&gt;::reference element = *pos++;<br></code></pre></td></tr></table></figure>自动推导使用与模板参数推导相同的机制。auto类型说明符可以被一个虚构的模板类型参数<code>T</code>取代，然后推导继续进行，就好像该变量是一个函数形参，它的初始化器相当于函数实参。对于第一个auto示例，它对应于以下情况：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deducePos</span><span class="hljs-params">(T pos)</span></span>; <br>&gt;<span class="hljs-built_in">deducePos</span>(container.<span class="hljs-built_in">begin</span>());<br></code></pre></td></tr></table></figure>这里<code>T</code>看作<code>auto</code>，是要被推导出的类型。这样做的直接后果之一是，auto类型的变量永远不会是引用类型。在第二个auto示例中使用<code>auto&amp;</code>说明了如何生成一个引用类型的推导。其推导相当于以下函数模板和调用：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-title">deduceElement</span><span class="hljs-params">(T&amp; element)</span></span>;<br>&gt;<span class="hljs-built_in">deduceElement</span>(*pos++);<br></code></pre></td></tr></table></figure>在这里，<code>element</code>总是引用类型，并且它的初始化器不能生成一个临时对象。</p></blockquote><hr /><h3 id="auto与右值引用">auto与右值引用</h3><blockquote><p>也可以将auto与右值引用组合起来，但这样做使其行为像一个转发的引用（aforwarding reference），例如： auto&amp;&amp; fr = …;我们还是基于函数模板来看待它： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; fr)</span></span>;<span class="hljs-comment">// auto replaced by template parameter T</span><br></code></pre></td></tr></table></figure> 解释如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-type">int</span> x; <br>&gt;<span class="hljs-keyword">auto</span>&amp;&amp; rr = <span class="hljs-number">42</span>; <span class="hljs-comment">// OK: rvalue reference binds to an rvalue </span><br>&gt;个(<span class="hljs-keyword">auto</span> = <span class="hljs-type">int</span>)<br>&gt;<span class="hljs-keyword">auto</span>&amp;&amp; lr = x; <span class="hljs-comment">// Also OK:reference collapsing makes. lr an lvalue reference</span><br>&gt;个(<span class="hljs-keyword">auto</span> = <span class="hljs-type">int</span>&amp;)<br></code></pre></td></tr></table></figure>这种技术经常用于代码中绑定函数或操作符调用的结果对象，且不知道结果对象的值类别(lvaluevs.rvarue)，进而不必复制该结果对象。例如，它通常是在基于范围的循环中声明迭代值的首选方法： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container&gt; <br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(Container c)</span></span><br><span class="hljs-function">&gt;</span>&#123; <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;&amp; x: c) &#123; … &#125; <br>&gt;&#125;<br></code></pre></td></tr></table></figure>这里我们不知道容器迭代接口的签名( the signatures of the container’siterationinterfaces)，但是通过使用<code>auto&amp;&amp;</code>，我们可以确信我们正在遍历的值没有产生额外的副本。如果需要完美转发绑定值，则可以像往常一样在变量上调用<code>std::forward&lt;T&gt;()</code>。这使得一种“延迟”的完美转发成为可能。有关示例，请参见《c++template 2nd》p167。除了引用之外，还可以组合auto说明符来创建const对象、指针、成员指针等等，但auto必须声明成“main”类型说明符（基本数据类型）。它不能嵌套在模板参数中或跟在基本数据类型后面的声明部分中（part of the declarator that follows the typespecifier）。具体请看下面的示例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> &#123; T <span class="hljs-type">const</span> m; &#125;; <br>&gt;<span class="hljs-keyword">auto</span> <span class="hljs-type">const</span> N = <span class="hljs-number">400u</span>; <span class="hljs-comment">// OK: constant of type </span><br><br>&gt;<span class="hljs-keyword">auto</span>* gp = (<span class="hljs-type">void</span>*)<span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// OK: gp has type void* </span><br><br>&gt;X&lt;<span class="hljs-keyword">auto</span>&gt; xa = <span class="hljs-built_in">X</span>&lt;<span class="hljs-type">int</span>&gt;(); <span class="hljs-comment">// ERROR: auto in template </span><br><br>&gt;<span class="hljs-type">int</span> <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>::*pm2 = &amp;X&lt;<span class="hljs-type">int</span>&gt;::m; <span class="hljs-comment">// ERROR: auto is &gt;part of the “declarator”</span><br></code></pre></td></tr></table></figure>最后两个例子不让通过的原因在于C++委员会认为，额外的实施成本和滥用潜力超过了好处☹️。</p></blockquote><hr /><h3 id="推导返回类型-c14">推导返回类型 c++14</h3><blockquote><p>C++14增加了另一种情况，其中可推导auto占位符类型可以出现在函数返回类型中。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;<br></code></pre></td></tr></table></figure>定义一个返回类型为int(42)的函数。这也可以使用后置返回类型的语法来表示：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> -&gt; <span class="hljs-keyword">auto</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;<br></code></pre></td></tr></table></figure>在后一种情况下，第一个auto宣告有尾置返回类型，而第二个auto是要推导出的占位符类型。但是直接这么写会显得很冗长。默认情况下，<code>lambda</code>也存在相同的机制：如果没有明确指定返回类型，则lambda的返回类型会像auto一样被推导出来：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">auto</span> lm = [] (<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(x); &#125;; <br><span class="hljs-comment">// same as:auto lm = [] (int x) -&gt; auto &#123; return f(x); &#125;;</span><br></code></pre></td></tr></table></figure> 函数可以单独声明。对于返回类型是被推导出来的函数也一样：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// forward declaration </span><br>&gt;<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;<br></code></pre></td></tr></table></figure> 但是，在这样的情况下，forwarddeclaration的用途非常有限，因为该定义必须在使用该函数的任何地方都可见。也许令人惊讶的是，提供带有“resolved”返回类型的forwarddeclaration是无效的。例如： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">known</span><span class="hljs-params">()</span></span>; <br>&gt;<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">known</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125; <span class="hljs-comment">//ERROR: incompatible return type</span><br></code></pre></td></tr></table></figure>大多数情况下，提前声明一个具有推导返回类型的函数，只有在能够将成员函数定义移动到类定义之外时才有用：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span> &#123; <br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// the definition will follow the class definition </span><br>&gt;&#125;;<br>&gt;<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">S::f</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;<br></code></pre></td></tr></table></figure></p></blockquote><hr /><h3id="可推导的非类型参数deducible-nontype-parameteruntil-c17">可推导的非类型参数（DeducibleNontype Parameter）until c++17</h3><blockquote><p>在C++17之前，非类型模板参数必须用特定的类型来声明。但是，该类型可以是一个模板参数类型。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, T V&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span>; <br>&gt;S&lt;<span class="hljs-type">int</span>, <span class="hljs-number">42</span>&gt;* ps;<br></code></pre></td></tr></table></figure>在本例中，必须指定非类型模板参数的类型，即在42之外指定int，可能非常繁琐。因此，C++17增加了声明非类型模板参数的能力，这些参数的实际类型是从相应的模板参数推导出来的。它们声明如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span> V&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span>;<br>&gt;S&lt;<span class="hljs-number">42</span>&gt;* ps;<span class="hljs-comment">//这样的话就简洁多了</span><br></code></pre></td></tr></table></figure>这里<code>S&lt;42&gt;</code>的V类型被推断为int，因为<code>42</code>的类型为<code>int</code>。如果我们写的是<code>S&lt;42u&gt;</code>，<code>V</code>的类型就会被推导为<code>无符号int</code>（《c++template 2nd》p294）。请注意，对非类型模板参数的类型的一般约束仍然有效。例如： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;S&lt;<span class="hljs-number">3.14</span>&gt;* pd;<span class="hljs-comment">// ERROR: floating-point nontype argument</span><br></code></pre></td></tr></table></figure>最后auto只在c++17中被允许用在模板参数中，c++20开始被移除，原因是弊大于利，滥用它会让程序变得更难读懂。</p></blockquote><hr /><h1id="用decltype表示表达式的类型expressing-the-type-of-an-expression-with-decltype">用decltype表示表达式的类型（Expressingthe Type of an Expression with decltype）</h1><blockquote><p>虽然auto避免了写出变量的类型的需要，但它不容易允许人们使用该变量的类型(不能确定为某一指定类型)。deltype关键字解决了这个问题：它允许程序员表达表达式或声明的精确类型。但是，程序员应该小心decltype类型产生的<code>细微差别</code>，这取决于传递的参数是一个声明定义出的实体（eg：<code>int a;</code>//这里a属于被定义出的实体）还是一个表达式（eg：<code>1+1;</code>//这里1+1这个整体是一个表达式）：-如果<code>e</code>是实体的名称（如变量、函数签名、枚举器或数据成员）或类成员访问过程，则<code>delltype(e)</code>生成该实体的声明类型或表示类成员的类型。因此，decltype类型可以用来检查变量的类型。当希望精确匹配现有声明的类型时，这一点很有用。例如，请考虑以下变量<code>y1</code>和<code>y2</code>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> x = …; <br><span class="hljs-keyword">auto</span> y1 = x + <span class="hljs-number">1</span>; <br><span class="hljs-keyword">decltype</span>(x) y2 = x + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>根据<code>x</code>的初始化器，<code>y1</code>可能具有也可能不具有与<code>x</code>相同的类型：它取决于<code>+</code>的行为。如果<code>x</code>被推导出为<code>int</code>，<code>y1</code>也会是<code>int</code>。如果<code>x</code>被推导为<code>char</code>，那么<code>y1</code>将是<code>int</code>，因为<code>char</code>与<code>1</code>的和是<code>int</code>。在<code>y2</code>类型中使用<code>deltype(x)</code>确保它始终具有与<code>x</code>相同的类型。## prvalue,xvalue和lvalue与decltype的关系： -如果<code>e</code>是任何其他表达式，则<code>deltype(e)</code>将生成一个反映该表达式的类型(type)和值类别(valuecategory)，如下所示： 一 If e is an lvalue of type <code>T</code>,decltype(e) produces <code>T&amp;</code>. 一 If e is an xvalue of type<code>T</code>, decltype(e) produces <code>T&amp;&amp;</code>. 一 If eis a prvalue of type <code>T</code>, decltype(e) produces<code>T</code>. 参考《c++ template 2nd》的附录B可以了解更多valuecategory的知识。</p></blockquote><hr /><blockquote><p>这种细微差别可以通过以下例子来证明： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span> <span class="hljs-params">(std::string&amp;&amp; s)</span></span><br><span class="hljs-function">&gt;</span>&#123;<br><span class="hljs-comment">// check the type of s:</span><br>std::is_lvalue_reference&lt;<span class="hljs-keyword">decltype</span>(s)&gt;::value; <span class="hljs-comment">// false</span><br>std::is_rvalue_reference&lt;<span class="hljs-keyword">decltype</span>(s)&gt;::value; <span class="hljs-comment">// true (s as declared)</span><br>std::is_same&lt;<span class="hljs-keyword">decltype</span>(s),std::string&amp;&gt;::value; <span class="hljs-comment">// false</span><br>std::is_same&lt;<span class="hljs-keyword">decltype</span>(s),std::string&amp;&amp;&gt;::value; <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// check the value category of s used as expression:</span><br>std::is_lvalue_reference&lt;<span class="hljs-keyword">decltype</span>((s))&gt;::value; <span class="hljs-comment">// true (s is an lvalue)</span><br>std::is_rvalue_reference&lt;<span class="hljs-keyword">decltype</span>((s))&gt;::value; <span class="hljs-comment">// false</span><br>std::is_same&lt;<span class="hljs-keyword">decltype</span>((s)),std::string&amp;&gt;::value; <span class="hljs-comment">// true (T&amp; signals an lvalue)</span><br>std::is_same&lt;<span class="hljs-keyword">decltype</span>((s)),std::string&amp;&amp;&gt;::value; <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>在前四个表达式中，为变量<code>s</code>调用delctype： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">decltype</span>(s) <span class="hljs-comment">//declared type of entity e designated by s</span><br></code></pre></td></tr></table></figure>这意味着deltype产生了<code>s</code>的声明类型<code>std::sting&amp;&amp;</code>。在最后四个表达式中，decltype类型构造的操作数不仅仅是一个名称，因为在每种情况下，该表达式都是<code>(s)</code>，它是一个用括号表示的名称。在这种情况下，该类型将反映<code>(s)</code>的值类别：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">decltype</span>((s)) <span class="hljs-comment">//check the value category of (s)</span><br></code></pre></td></tr></table></figure>我们的表达式指的是一个变量，因此是一个<code>lvalue</code>：根据上面的规则，这意味着<code>decltype((s))</code>是对<code>std::string</code>的普通引用(lvaluereference)。这是C++中为数不多的用括号表示表达式会改变程序含义的地方之一，而不是影响操作符的关联性。decltype类型计算任意表达式e的类型，这一事实在不同的地方都有帮助。具体来说，<code>deltype(e)</code>保留了关于表达式的足够信息，可以使它描述返回表达式<code>e</code>本身的函数的返回类型：deltype计算该表达式的类型，但它也将表达式的值类别传播给函数的调用者。例如，考虑一个简单的转发函数g()，它返回调用f()的结果：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;??? <span class="hljs-built_in">f</span>(); <br>&gt;<span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">f</span>()) <span class="hljs-built_in">g</span>() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(); <br>&#125;<br></code></pre></td></tr></table></figure><code>g()</code>的返回类型取决于<code>f()</code>的返回类型。如果<code>f()</code>返回<code>int&amp;</code>，那么计算<code>g()</code>的返回类型将首先确定表达式<code>f()</code>具有类型<code>int</code>。这个表达式是一个<code>lvalue</code>，因为<code>f()</code>返回一个左值引用，因此声明的返回类型变为<code>int&amp;</code>。类似地，如果<code>f()</code>的返回类型是右值引用类型，则调用<code>f()</code>将是<code>xvalue</code>，decltype将生成与<code>f()</code>返回的类型完全匹配的右值引用类型。本质上，这种形式的decltype类型采用了任意表达式的主要特征——它的类型和值类别——并以一种能够完美转发返回值的方式在类型系统中对它们进行编码。当 value-producing<code>auto</code>的推导不足时，decltype也可能很有用。例如，假设我们有一个未知迭代器类型的变量<code>pos</code>，并且我们希望创建一个变量元素来引用<code>pos</code>存储的元素。我们可以使用：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">auto</span> element = *pos;<span class="hljs-comment">//这将始终有元素的副本产生。</span><br>&gt;<span class="hljs-keyword">auto</span>&amp; element = *pos;<span class="hljs-comment">//引用pos存储的元素！</span><br></code></pre></td></tr></table></figure> 我们将总是会收到一个对元素的引用，但是如果迭代器的操作符<code>*</code>返回一个值，那么程序将会失败。为了解决这个问题，我们可以使用decltype类型，以保持迭代器的运算符<code>*</code>的值或引用性：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">decltype</span>(*pos) element = *pos;<br></code></pre></td></tr></table></figure>是使用内置类型解引用<code>pos</code>时<code>使用引用</code>（*pos表达式的结果为左值，则decltype推断出来的类型为左值引用！），是迭代器的操作符<code>*</code>返回一个值时<code>复制值</code>。它的主要缺陷是它需要将初始化器表达式写入两次：一次在decltype中（不计算它），另一次在实际的初始化器中。C++14引入了<code>decltype(auto)</code>来解决这个问题，我们接下来将讨论这个问题。</p></blockquote><hr /><h1 id="decltypeauto-c14">decltype(auto) c++14</h1><blockquote><p>C++14增加了一个功能，它是auto和decltype的组合：<code>decltype(auto)</code>。与auto类型说明符一样，它是一个<code>占位符类型</code>，并且变量、返回类型或模板参数的类型是由相关表达式的类型(initializer,return value, or templateargument)确定的。但是，与仅使用auto不同，它使用模板参数推断的规则来确定感兴趣的类型，实际的类型是通过将decltype直接应用于表达式来确定的。举例说明了这一点：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-type">int</span> i = <span class="hljs-number">42</span>; <span class="hljs-comment">// i has type int</span><br>&gt;<span class="hljs-type">int</span> <span class="hljs-type">const</span>&amp; ref = i; <span class="hljs-comment">// ref has type int const&amp; and refers to i</span><br>&gt;<span class="hljs-keyword">auto</span> x = ref; <span class="hljs-comment">// x has type int and is a new independent object</span><br>&gt;<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) y = ref; <span class="hljs-comment">// y has type int const&amp; and also refers to i</span><br></code></pre></td></tr></table></figure><code>y</code>的类型是通过将decltype应用到初始化器表达式中得到的，这里是<code>ref</code>，它是<code>int const&amp;</code>。相比之下，auto类型推导的规则产生的则是类型<code>int</code>。另一个示例显示了索引<code>std::vector</code>(索引出来的是一个lvalue《c++primer》p121)时的差异：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123; <span class="hljs-number">42</span> &#125;;<br>&gt;<span class="hljs-keyword">auto</span> x = v[<span class="hljs-number">0</span>]; <span class="hljs-comment">// x denotes a new object of type int</span><br>&gt;<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) y = v[<span class="hljs-number">0</span>]; <span class="hljs-comment">// y is a reference (type int&amp;)（Because [ ] operator produces an lvalue）</span><br></code></pre></td></tr></table></figure> 这很好地解决了前面示例中的冗余写法： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">decltype</span>(*pos) element = *pos;<span class="hljs-comment">//Redundant writing</span><br>&gt;<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) element = *pos;<span class="hljs-comment">//which can now be rewritten as</span><br></code></pre></td></tr></table></figure>它通常用在返回类型上。参考以下示例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapt</span><br>&gt;&#123;<br>C container;<br>…<br><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-keyword">operator</span>[] (std::<span class="hljs-type">size_t</span> idx) &#123;<br><span class="hljs-keyword">return</span> container[idx];<br>&#125;<br>&gt;&#125;;<br></code></pre></td></tr></table></figure>如果<code>container[idx]</code>生成一个<code>lvalue</code>，我们希望将该左值传递给调用者（他可能希望获取其地址或修改它）：这需要一个左值引用类型，这正是<code>decltype(auto)</code>解析到的类型。如果生成出来的是<code>prvalue</code>(内置下表运算符只可能产生<code>lvalue</code>和<code>xvalue</code>，这里说的是如果，原因在《<ahref="https://blog.csdn.net/Howl_1/article/details/122625409">C++prvalue，xvalue和lvalue的相关知识</a>》中已阐述)，则引用类型将导致悬空引用(danglingreferences)，但幸运的是，<code>deltype(auto)</code>将生成这种情况下的对象类型（而不是引用类型）。</p><hr /><h2id="在递归模板中延迟返回类型推断delaying-return-type-deduction-in-recursive-templates">在递归模板中延迟返回类型推断（<ahref="https://stackoverflow.com/questions/24109737/what-are-some-uses-of-decltypeauto#Delaying-return-type-deduction-in-recursive-templates">Delayingreturn type deduction in recursive templates</a>）</h2><p>当模板的返回类型被指定为<code>decltype(iter(Int&lt;i-1&gt;&#123;&#125;))</code>而不是<code>decltype(auto)</code>时，在模板实例化过程中会遇到无限递归。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> i&gt; <br>&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Int</span> &#123;&#125;;<br><br>&gt;<span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">iter</span><span class="hljs-params">(Int&lt;<span class="hljs-number">0</span>&gt;)</span> -&gt; Int&lt;0&gt;</span>;<span class="hljs-comment">//递归模板结束地方的声明</span><br><br>&gt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> i&gt;<span class="hljs-comment">//非类型参数（Nontype Parameter）《c++primer》p580</span><br>&gt;<span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">iter</span><span class="hljs-params">(Int&lt;i&gt;)</span> -&gt; <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">iter</span>(Int&lt;i<span class="hljs-number">-1</span>&gt;&#123;&#125;);<br>&gt;&#125;<br>&gt;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">iter</span>(Int&lt;<span class="hljs-number">10</span>&gt;&#123;&#125;)) a;<br>&gt;&#125;<br></code></pre></td></tr></table></figure>这里使用<code>decltype(auto)</code>来延迟返回类型模板实例化的推断,从而解决返回类型实例化过早引发无限递归的问题。</p><hr /><p>与auto不同，<code>delltype(auto)</code>不允许修改其类型的说明符或声明符操作符。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>)* p = (<span class="hljs-type">void</span>*)<span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// invalid</span><br>&gt;<span class="hljs-type">int</span> <span class="hljs-type">const</span> N = <span class="hljs-number">100</span>;<br>&gt;<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-type">const</span> NN = N*N; <span class="hljs-comment">// invalid</span><br></code></pre></td></tr></table></figure> 还要注意，初始化器中的圆括号可能很重要: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-type">int</span> x;<br>&gt;<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) z = x; <span class="hljs-comment">// object of type int</span><br>&gt;<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) r = (x); <span class="hljs-comment">// reference of type int&amp;</span><br></code></pre></td></tr></table></figure>这尤其意味着括号可能会严重影响<code>return statements</code>的有效性：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>;<br>&gt;…<br>&gt;<span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> r = <span class="hljs-built_in">g</span>();<br><span class="hljs-keyword">return</span> (r); <span class="hljs-comment">// run-time ERROR: returns reference to temporary</span><br>&gt;&#125;<br></code></pre></td></tr></table></figure> untilC++17，<code>decltype(auto)</code>也可以用于可推导的<code>非类型参数</code>，由于后面c++20将其剔除，所以这里就不继续深入探讨了，原因是一样，弊大于利，滥用将导致程序难以理解。</p></blockquote><hr /><blockquote><p>最后问大家一个小问题，auto会不会计算出表达式结果的值？，decltype会不会计算出表达式结果的值？，decltype(auto)呢？相信大家看完本篇文章后，这些问题就会不攻自破了🙂 。如果本篇文章帮您解决了理论上难以理解的问题，记得点个赞哦！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>用反汇编分析c++RVO开启和关闭时的底层原理以及C++prvalue，xvalue和lvalue的相关知识</title>
    <link href="/2022/01/28/00004.%20%E7%94%A8%E5%8F%8D%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90c++RVO%E5%BC%80%E5%90%AF%E5%92%8C%E5%85%B3%E9%97%AD%E6%97%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8AC++prvalue%EF%BC%8Cxvalue%E5%92%8Clvalue%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/01/28/00004.%20%E7%94%A8%E5%8F%8D%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90c++RVO%E5%BC%80%E5%90%AF%E5%92%8C%E5%85%B3%E9%97%AD%E6%97%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8AC++prvalue%EF%BC%8Cxvalue%E5%92%8Clvalue%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><blockquote><p><strong>本篇文章为笔者的读书笔记，未经允许请勿转载。</strong><br />本篇文章主要讲述C++prvalue，xvalue和lvalue的相关知识，会用到部分intel式和ATT式汇编的知识。我会在文章末尾给出测试代码的反汇编代码以及右值引用（Rvaluereferences）官方文档 😃。--------------------------------------------------------</p></blockquote><h1 id="三五法则">三五法则</h1><blockquote><p>三五法则：有析构就应该有拷贝构造函数和拷贝赋值运算法（3）。c++11下，一个类还可以有移动构造函数和移动赋值运算符（3+2）。三五法则时候一般情况，如果不想某个函数被普通或者友元使用可以将其定义为=delete或者在private里面声明但不定义，具体参考C++primer p449。移动函数的出现提高了类内存转让的效率，而支承这一技术的基础就是prvalue,xvalue,lvalue.(xvalue和prvalue统称为rvalue，lvalue和xvalue统称为glvalue。只需要记住上面说的三种就可以，这两个统称可以不用记)。这三种值的出现场合和特点在后文详细说明。--------------------------------------------------------</p></blockquote><h1id="未开启rvo优化与xvalue和prvalue的关系">未开启RVO优化与xvalue和prvalue的关系</h1><blockquote><p>关闭RVO的方法:eg:<code>clang++ -g -fno-elide-constructors /home/dengye/test/test.cpp -o /home/dengye/test/test</code>先设计一个三五法则的类，再分析关闭和开启RVO时程序的堆栈分布图。废话不多说开整！</p></blockquote><p>## 测试代码 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> val=<span class="hljs-number">0</span>):<span class="hljs-built_in">bVal</span>(val)&#123;&#125;<br>    <span class="hljs-comment">// B(const B&amp; tmp):bVal(tmp.bVal)&#123;&#125;</span><br>    ~<span class="hljs-built_in">B</span>()&#123;&#125;<br>    <span class="hljs-type">int</span> bVal;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>):<span class="hljs-built_in">ptrb</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>(tmp))<br>    &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;构造函数&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-type">const</span> Foo&amp; src):<span class="hljs-built_in">ptrb</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>(*(src.ptrb)))<span class="hljs-comment">//会继续调用B的拷贝构造函数</span><br>    &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;拷贝构造函数&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br>    Foo&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Foo&amp; src)<br>    &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;拷贝赋值函数&quot;</span>&lt;&lt;std::endl;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;src)<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//防止自己给自己赋值。</span><br>        <span class="hljs-keyword">delete</span> ptrb;<span class="hljs-comment">//先把自己的这块内存干掉</span><br>        ptrb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>(*(src.ptrb));<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    <br>    &#125;<br>    <span class="hljs-built_in">Foo</span>(Foo&amp;&amp; src) <span class="hljs-keyword">noexcept</span> :<span class="hljs-built_in">ptrb</span>(src.ptrb)<span class="hljs-comment">//noexcept:通知标准库我们这个移动构造函数不抛出任何异常（如果编译器确认函数不会抛出异常，它就能执行某些特殊的优化操作，而这些操作不适合用于可能出错的代码），例如我们希望在vector重新分配内存这类情况下对我们自定义类型的对象进行移动而不是拷贝，就必须显式地告诉标准库我们的移动构造函数可以安全使用。《c++primer》p474，690。</span><br>    &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;移动构造函数&quot;</span>&lt;&lt;std::endl;        <br>        src.ptrb = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//记得将原来指向堆内存的指针置空.</span><br>    &#125;<br>    Foo&amp; <span class="hljs-keyword">operator</span>=(Foo&amp;&amp; src) <span class="hljs-keyword">noexcept</span><br>    &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;移动赋值函数&quot;</span>&lt;&lt;std::endl;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;src)<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">delete</span> ptrb;<br>        ptrb = src.ptrb;<span class="hljs-comment">//这里不需要在new，直接从src那里拿来</span><br>        src.ptrb = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//记得置空</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">Foo</span>()<br>    &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;析构函数&quot;</span>&lt;&lt;std::endl;<br>        <span class="hljs-keyword">delete</span> ptrb;<span class="hljs-comment">//删一个空指针没任何反应</span><br>    &#125;<br>    B *ptrb;<br>&#125;;<br><span class="hljs-function">Foo <span class="hljs-title">RVO_test</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Foo <span class="hljs-title">foo</span><span class="hljs-params">(val)</span></span>;<br>    <span class="hljs-keyword">return</span> foo;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Foo fooRvo = <span class="hljs-built_in">RVO_test</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>&gt;在分析之前我先把该程序的内存分布图画出来帮大家理解，见下图：</p><p><img src="/img/00004/1.png" alt="在这里插入图片描述" />&gt;像这种randomoffset的出现，就是为了避免溢出攻击。画这张图要用到<code>nm</code>命令（寻找代码段，bss段和data段的起始地址），gdb的<code>vmmap</code>命令（寻找堆栈的起始和结束地址）。灰色部分表示这些范围在进程虚拟地址空间中不可用，也就是说，没有为这些区域创建页表（pagetable）。 --------------------------------------------------------</p><h2 id="反汇编配合堆栈图分析流程">反汇编配合堆栈图分析流程</h2><p><strong>友情提醒：请配合附件中的反汇编代码进行分析。</strong> <imgsrc="/img/00004/2.png" alt="在这里插入图片描述" /> <imgsrc="/img/00004/3.png" alt="在这里插入图片描述" /></p><blockquote><p>到达这一步以前发生的事情有：main函数开辟出了0x20字节的空间，将rbp-0x18的地址（临时对象prvalue）给了rdi，然后将0x64给了esi，接着调用了RVO_test(int)函数，还没pushrbp。</p></blockquote><hr /><figure><img src="/img/00004/4.png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><figure><img src="/img/00004/5.png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h2id="到达这一步以前发生的事情有rvo_testint函数开辟了0x30字节的空间rdi寄存器存着临时对象prvalue的地址然后将其赋给了rbp-0x8rbp-0x20rbp-0x28又将0x64赋给了rbp-0xc形参val最后在临时对象foo的地址上进行了构造">&gt;到达这一步以前发生的事情有：RVO_test(int)函数开辟了0x30字节的空间，rdi寄存器存着临时对象prvalue的地址，然后将其赋给了rbp-0x8，rbp-0x20，rbp-0x28，又将0x64赋给了rbp-0xc（形参val），最后在临时对象foo的地址上进行了构造。</h2><figure><img src="/img/00004/6.png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><figure><img src="/img/00004/7.png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><blockquote><p>到达这一步以前发生的事情有：编译器将rbp-0x18（局部对象foo）的内容移动到了临时对象的里面。此时局部对象的指针数据成员指向空，在RVO_test(int)函数返回时，会析构这个局部对象，而delete一个空指针没任何反应。最后RVO_test(int)函数将rbp-0x28地址上的内容赋给rax作为返回值。</p></blockquote><hr /><figure><img src="/img/00004/8.png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><figure><img src="/img/00004/9.png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h2id="到达这一步以前发生的事情有rvo_testint函数回收了0x30字节的空间pop-rbp时会将保存的main函数的rbp地址取出来放到rbp栈基址寄存器里面同时rsp会8指向要跳转的代码段最后一步没执行不难看出ret是让rip指令寄存器指向rsp的内容即跳转到main29">&gt;到达这一步以前发生的事情有：RVO_test(int)函数回收了0x30字节的空间，poprbp时会将保存的main函数的rbp地址取出来放到rbp栈基址寄存器里面，同时rsp会+8，指向要跳转的代码段。最后一步没执行，不难看出ret是让rip指令寄存器指向rsp的内容，即跳转到&lt;main+29&gt;。</h2><figure><img src="/img/00004/10.png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><figure><img src="/img/00004/11.png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><blockquote><p>到达这一步以前发生的事情有：临时对象的内容被移动赋值函数转移到了main函数的局部对象fooRvo。然后临时对象就被析构了，接着main函数将返回值0赋给rbp-0x4所指的空间，最后fooRvo对象也被析构。程序随之结束。</p></blockquote><hr /><h2 id="小结">小结</h2><blockquote><p>无RVO返回优化，编译器会生成一个prvalue或者xvalue的<ahref="https://en.cppreference.com/w/cpp/language/implicit_conversion">临时对象（Temporarymaterialization）</a>（《深度探索c++对象模型》p267），取决于prvalue是否出现在丢弃值表达式（<ahref="https://en.cppreference.com/w/cpp/language/expressions#Discarded-value_expressions">Discarded-valueexpressions</a>）里。像这样写<code>Foo fooRvo = RVO_test(100);</code>RVO_test(100)产生的临时对象就是prvalue，这种prvalue被称为"有一个结果对象"（<ahref="https://en.cppreference.com/w/cpp/language/value_category">suchprvalue is said to have a resultobject</a>）。而这样写<code>Foo fooRvo;fooRvo = RVO_test(100);</code>RVO_test(100)产生的临时对象就是xvalue，原因就是prvalue出现在了丢弃值表达式里。这种表达式包括了任何完整表达式语句（<ahref="https://en.cppreference.com/w/cpp/language/expressions#Discarded-value_expressions">Suchexpressions include the full expression of any expressionstatement</a>）。然后临时对象的地址会被传入到RVO_test(int)函数中，该函数中的局部对象foo在返回时触发移动构造函数将foo的内存转让给临时对象。为什么会触发移动构造函数呢？归功于return语句，一个拷贝操作发生在return语句时，会被忽略或者被对待成rvalue，目的在于选择一个重载后的构造函数（Note:Acopy operation associated with a return statement may be elided orconsidered as an rvalue for the purpose of overload resolution inselecting a constructor (12.8). —end note,本句子出自<ahref="https://en.cppreference.com/w/cpp/compiler_support/11">c++标准手册文档-N2118的6.6.3- The returnstatement</a>）。由于右值引用可以接受一个rvalue，这个被return转化后的rvalue选择了移动构造函数。至此临时对象被构造出来，RVO_test(int)函数的局部对象foo被析构。而临时对象prvalue，由于赋值运算符的存在，会去调用移动构造函数，（细心的小伙伴肯定要问为啥不是调用重载后的移动赋值函数，很简单！赋值运算符在定义处表现出来的形式为构造而不是拷贝）。待main函数中的fooRvo对象被构造出来后，临时对象也被析构。最后fooRvo对象被析构。. 这是clang编译器下运行完代码的结果:<br /><img src="/img/00004/12.png" alt="这是运行完代码的结果" /></p><p>注意：MSVC编译有接住这个民间概念，也就说<code>Foo fooRvo = RVO_test(100);</code>这条语句中，RVO_test产生的临时对象会被fooRvo对象接住，从而不执行对临时对象的析构。或者说fooRvo的空间和临时对象的空间合二为一了。我平时写代码都是用的clang编译器，以前刚开始学c++是在MSVC所以这里就稍微提及一下MSVC的不同之处。. 这是MSVC编译器下运行完代码的结果：<br /><img src="/img/00004/13.png" alt="在这里插入图片描述" />--------------------------------------------------------</p></blockquote><h1 id="开启rvo优化">开启RVO优化</h1><blockquote><p>代码还是用上面的代码</p><p><img src="/img/00004/14.png" alt="在这里插入图片描述" /> <imgsrc="/img/00004/15.png" alt="在这里插入图片描述" /></p></blockquote><blockquote><p>上面已经带着大家分析过一遍了，这里就直接跳到最后看结果。对比关闭RVO来说，RVO_test(int)函数的局部对象就是直接构造到fooRvo对象里面去了，中间一个移动构造都没有。通过分析反汇编代码不难发现，它为了优化返回局部对象，直接让fooRvo对象的内存接管了局部对象foo的，可以说是合二为一了。但是有一个问题，局部对象foo一定要执行析构函数呀！别急，它这里妙手回春一手，将一字节的标志位放在了RVO_test(int)函数的栈帧中，然后通过判断标志位跳过对局部对象foo的析构函数执行。这玩意儿有点像加了if的goto😃。 . 这是clang编译器下运行完代码的结果:<br /><img src="/img/00004/16.png" alt="在这里插入图片描述" /><br />有关临时对象的认识可以参考《深度探索c++对象模型》p267</p></blockquote><hr /><h1 id="xvalueprvalue和lvalue">xvalue,prvalue和lvalue</h1><blockquote><p>这里笔者就帮大家把坑填上，相信大家对上面测试代码分析过后会对prvalue和xvalue有个初步的印象，即函数返回时可能会涉及到它们。对于这三种值的概述：每一个c++的表达式（作用在运算对象上的重载操作符，字面常量，一个变量名，"a= b"（an assignmentexpression），etc.）都会有两个独立的属性：一种类型，一个值的类别。每个表达式都有一些非引用类型，并且每个表达式都恰好属于三个主要值类别中的一个:prvalue、xvalue和lvalue。这三种值没有一个确切的定义，或者说你要废很大功夫去定义它们，亦或者描述个大概即可。下面我们来看这三种值类型的概要定义以及特性（完整请参考<ahref="https://en.cppreference.com/w/cpp/language/value_category">Valuecategories</a>）：（补充一句，检测表达式的值类别的相关代码，我放在了附录中，感兴趣的读者可以自行验证感到疑惑的地方）- lvaluelvalue：所谓左值，从历史的角度来考虑，它可以出现在一个赋值表达式的左边。资源可以被重用（resourcescan be reused）。有空间地址但不能被移动 - 一般有名字，除了 unamedlvalue（<code>*ptr</code>是一个没有名字的lvalue，一个返回值为lvaluereference的函数调用表达式也是没名字的lvalue），如果有单独的一个identifier 来表示它，它一定是 lvalue - 可以用 &amp;符号取其地址，除了bit field（<ahref="https://en.cppreference.com/w/cpp/language/bit_field">The type ofa bit field can only be integral or enumeration type.</a>） -一个函数或者重载操作符的返回值为lvalue reference 例如<code>std::getline(std::cin, str) or std::cout &lt;&lt; 1 or str1 = str2 or ++iter</code>- 其生命周期为其所在的 scope - 一些内置操作符表达式内置前自增自减，解引用，内置下标表达式（<code>a[n]</code>是一个lvalue的情况下），类类型的内置成员访问表达式（除了访问枚举数据成员和非静态成员函数，还有一些特例请参考<ahref="https://en.cppreference.com/w/cpp/language/value_category">Primarycategories</a>），逗号表达式（最右边的操作数为lvalue的情况下），三元条件表达式（第二个和第三个操作数为lvalue的情况下）- 将表达式强制转换为左值引用类型和右值引用函数署名类型（<ahref="https://en.cppreference.com/book/intro/functions">The signature ofa function</a>） 例如 <code>static_cast&lt;int&amp;&gt;(x)</code> 例如<code>static_cast&lt;void (&amp;&amp;)(int)&gt;(x)</code> - 在所有literal 中，只有 string literal 是lvalue：<code>cout &lt;&lt; &amp;"dy" &lt;&lt; endl</code>;（其他literal 是 rvalue：<code>cout &lt;&lt; &amp;'d' &lt;&lt; endl</code>;非法） ## lvalue的特性： -可以通过取址运算符获取其地址，<code>&amp;++i[1]</code> and<code>&amp;std::endl</code>像这样的表达式都是合法的 -可修改的左值可用作内置赋值和<ahref="https://en.cppreference.com/w/cpp/language/operator_assignment#Builtin_compound_assignment">内置复合赋值运算</a>符的左操作数- 可以用来初始化左值引用，这个左值引用将是lvalue的别名。 -lvalue可以被隐式地转换为prvalue就像lvalue-to-rvalue, array-to-pointer,orfunction-to-pointer的隐式转换。（<code>int ival1 = 1;int ival2 = -ival1;</code>，这里减号可以lvalue隐式转换成prvalue）- 可以是多态的（<ahref="https://en.cppreference.com/w/cpp/language/object#Polymorphic_objects">Polymorphic</a>），它所对应的<ahref="https://en.cppreference.com/w/cpp/language/type#Dynamic_type">动态类型</a>和静态类型可以不一样，例如：一个指向子类的父类指针- 可以是<ahref="https://en.cppreference.com/w/cpp/language/type#Incomplete_type">不完整类型</a>，只要表达式允许。例如：由前置声明但未定义的类类型- xvaluexvalue：一个将要到期的值（生命周期被延长），资源可以被重用的对象。有空间地址可以被移动。- 一个函数调用或者重载操作符函数表达式的返回值为rvalue reference 例如<code>std::move(x)</code>； - 将表达式的类型强制转换为右值引用类型。例如<code>(int&amp;&amp;)a</code>，<code>static_cast&lt;int&amp;&amp;&gt;(a)</code>。- 内置下标表达式（<code>a[n]</code>为一个xvalue的情况下）。 -类类型的内置成员访问表达式。 例如<code>a.m</code>是一个xvalue，a是xvalue，m是非引用类型的非静态数据成员。 以及<code>a.*mp</code>是一个 xvalue。a是xvalue，mp 叫做 pointer to datamember（《c++primer》p739）。 -三元条件表达式（第二个和第三个操作数为xvalue的情况下） -指定临时对象的任何表达式（除了prvalue initializes anobject的情况）(since C++17) ## xvalue的特性： -可以被绑定到右值引用和const左值引用，同时生命周期被延长到这个引用的作用域结束- xvalue可以具有多态性（<ahref="https://en.cppreference.com/w/cpp/language/object#Polymorphic_objects">Polymorphic</a>）- 非类类型的xvalue可以被const和volatile修饰（<ahref="https://en.cppreference.com/w/cpp/language/cv">cv typequalifiers</a>） - xvalue可以被隐式地转换为prvalue就像lvalue-to-rvalue,array-to-pointer, or function-to-pointer的隐式转换（<code>int ival = 1;if((int&amp;&amp;)ival)&#123;putchar('Y');&#125;</code>xvalue被隐式转换成了prvalue）- 可以是不完整类型 - 不能被取地址（通过内置取地址运算符） -不能是内置赋值和<ahref="https://en.cppreference.com/w/cpp/language/operator_assignment#Builtin_compound_assignment">内置复合赋值运算</a>符的左操作数-当作用在函数参数时，有两个函数重载都可用，一个是右值引用参数，另一个是const左值引用参数，一个xrvalue会绑定到参数为右值引用的重载函数上（因此，拷贝和移动构造函数都存在时，一个xrvalue会去调用移动构造而不是拷贝构造，同理作用于拷贝和移动赋值运算符）- prvalueprvalue：一个将要消亡的值（生命周期马上结束），资源不可以被重用（想要被重用必须转化成xvalue）的对象。一部分有空间地址但马上就会被回收（空间地址可以被后面的新数据覆盖），一部分没有空间地址。可以被移动。- 所有 literals：bool literal (例如<code>true</code>)，integer literal(例如 <code>42</code>) 等等（无空间地址）。 -实质上的函数调用：(<strong>return non-reference</strong>)（有空间地址）<code>f()</code>function call <img src="/img/00004/17.png"alt="在这里插入图片描述" /></p><p><code>a.f()</code>static or non-static member function<code>A()</code> 包括各种构造函数 <code>str1 + str2</code> 重载 operator也相当于函数调用 <code>functor()</code> (对应 operator() 重载)<code>[]&#123;&#125;()</code>lambda (对应 operator() 重载) -一些内置操作符产生的运算结果（无空间地址）： <code>a++</code> 自增自减<code>a+b</code> 加减乘除 <code>a&amp;b</code> 位运算<code>a&amp;&amp;b</code> 逻辑运算 <code>a&lt;b</code> 关系运算<code>&amp;a</code> 取地址 <code>a, b</code> comma expression (如果b 是rvalue) <code>(int)a</code> 或 static_cast&lt; int&gt;(a) 强制类型转换<code>a ? b : c</code>（第二个和第三个操作数为rvalue的情况下） -enumerator 枚举值（无空间地址）： <code>enum &#123; yes, no &#125;;</code> 中的yes, no <code>a.m</code> 或 <code>p-&gt;m</code>，其中 m 是 memberenumerator - 普通成员函数本身（<ahref="https://en.cppreference.com/book/intro/functions">The signature ofa function</a>）（无空间地址） <code>a.m</code> 或 <code>p-&gt;m</code>或 <code>a.*pm</code> 或 <code>p-&gt;*pm</code>，其中 m 和 pm都对应普通成员函数(non-static) - this 指针（有空间地址）被当做参数传进去放在栈帧上。 ## prvalue的特性： - 不会是多态的 -非类非数组的prvalue不能被cv-qualified修饰，除非它为了被绑定到一个cv-qualified的引用类型上而转换化成xvalue(since C++17)， 例如：<code>const int&amp; i = 1；</code>(注意：一个函数调用或者强制类型转换表达式会导致生成一个非类cv-qualified类型，但是cv-qualifier通常会立即被剥离。)- prvalue不能有不完整的类型（使用decltype指示符时也不能有，除了void） -prvalue不能有抽象类类型或者an arraythereof（不太懂官方要表达的意思，所以就以英文方式放在这里供大家参考）☹️- 不能被取地址（通过内置取地址运算符） - 不能是内置赋值和<ahref="https://en.cppreference.com/w/cpp/language/operator_assignment#Builtin_compound_assignment">内置复合赋值运算</a>符的左操作数-当作用在函数参数时，有两个函数重载都可用，一个是右值引用参数，另一个是const左值引用参数，一个prvalue会绑定到参数为右值引用的重载函数上（因此，拷贝和移动构造函数都存在时，一个prvalue会去调用移动构造而不是拷贝构造，同理作用于拷贝和移动赋值运算符）</p></blockquote><hr /><h1 id="temporary-materialization">Temporary materialization</h1><blockquote><p>经过对xvalue,prvalue和lvalue对认识后，咱们来聊聊临时对象，除了xvalue可以被称为临时对象，prvalue在某些情况下也可以被称为临时对象。从一个任何完整类型T的prvalue转换为相同类型T的xvalue的过程被称为临时物化（Temporarymaterialization）。该转换将prvalue作为其结果对象求值，从而将prvalue初始化为T类型的临时对象，并生成一个表示临时对象的xvalue(sinceC++17)。如果T是一个类或者类类型的数组，它必须具有可访问且未删除的析构函数。Temporary materialization 会发生在下列情况中：<strong>(sinceC++17)</strong> - 绑定作用于prvalue时<code>int&amp;&amp; c = 1;const int&amp; c = 1;</code>c绑定的是一个xvalue- 在一个prvalue类上使用成员访问运算符时 <code>A().m;</code>pvalue A()自动变成一个 xvlaue <code>A().*mp;</code> pvalue A() 自动变成一个 xvlaue- prvalue数组转变成一个指针或被绑定时，或者用下标访问一个prvalue数组1.prvalue数组被绑定时<code>int (&amp;&amp; a)[2] = (int[])&#123;1, 2&#125;;</code>2.prvalue数组转变成一个指针时<code>[](int* iptr)&#123;std::cout&lt;&lt;*iptr;&#125;((int[])&#123;1,2&#125;);</code>对于一个对象或者一个表达式，如果可以对其使用调用运算符，则称它为可调用对象(《c++primer》p345)3.用下标访问一个prvalue数组时 <code>((int[])&#123;1, 2&#125;)[0];</code> -当从带括号的列表初始化初始化std::initializer_list<T>类型的对象时;《c++primer》p197 - typid作用于一个prvalue时 《c++primer》p732 -sizeof作用于一个prvalue时 - 当一个prvalue出现在丢弃值表达式（<ahref="https://en.cppreference.com/w/cpp/language/expressions#Discarded-value_expressions">Discarded-valueexpressions</a>） 上文研究开启RVO时讲过。 -注意：当从相同类型的prvalue初始化一个对象时(通过直接初始化或复制初始化)不会发生临时物化:这样的对象是直接从初始化器初始化的。这确保了“拷贝副本的省略(RVO的工作机制)”。（上文研究开启RVO时讲过，prvalue可以用来初始化一个对象，这种prvalue被称为"有一个结果对象"（<ahref="https://en.cppreference.com/w/cpp/language/value_category">suchprvalue is said to have a result object</a>）） <imgsrc="/img/00004/18.png" alt="在这里插入图片描述" /></p><p>重要的事情说三遍！从一个任何完整类型T的prvalue转换为相同类型T的xvalue的过程被称为临时物化从一个任何完整类型T的prvalue转换为相同类型T的xvalue的过程被称为临时物化从一个任何完整类型T的prvalue转换为相同类型T的xvalue的过程被称为临时物化</p></blockquote><hr /><h1 id="引用折叠万能引用引用塌缩">引用折叠（万能引用，引用塌缩）</h1><blockquote><p>上面说过移动操作的出现提高了类内存转让的效率，而支承这一技术的基础就是prvalue,xvalue,lvalue。但右值引用才是移动操作能实现的根本原因。这里咱们好好讲一讲右值引用的相关知识引用折叠（关于右值引用的基础知识请参看《c++primer》p471这里不多赘述）。引用折叠的两个规则被称为C++语言在正常绑定规则之外定义的两个例外规则，允许这种绑定。而这两个例外规则是move这种标准模板库设施正确工作的基础。先介绍一下它的两个规则： -.规则一：对于一个给定类型<code>T</code>，当我们将一个左值传给模板函数的右值引用参数时，编译器推断模板类型参数T为左值引用类型（T&amp;），例如对于<code>int</code>类型的左值时，推断<code>T</code>为<code>int&amp;</code>；当我们将一个右值传进去时，<code>T</code>被推断出来的类型为<code>T</code>，例如对于<code>int</code>类型的右值时，推断<code>T</code>为<code>int</code>。-例外规则二：如果我们间接创建了一个引用的引用，则这些引用形成了引用折叠。正常情况下，不能直接创建引用的引用，但是可以间接创建（如类型别名和模板参数）。大部分情况下，引用的引用会折叠为普通的左值引用（T&amp;&amp;、T&amp; &amp;&amp;、 T&amp;&amp;&amp;都会折叠成类型T&amp;），右值引用和右值引用，则折叠成右值引用（T&amp;&amp;&amp;&amp;折叠成T&amp;&amp;）。《c++primer》p608</p></blockquote><hr /><h2id="对上面两个规则熟练后我们来分析一下标准库move函数">对上面两个规则熟练后，我们来分析一下标准库move函数:</h2><blockquote><p>虽然不能直接将一个右值引用绑定到一个左值上，但可以用move获得一个绑定到左值上的xvalue。由于move本质上可以接受任何类型的实参，因此我们不会惊讶于他一个函数模板。- std::move是如何定义的 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>&gt;<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp;<br>&gt;<span class="hljs-built_in">move</span>(T&amp;&amp; t) <span class="hljs-keyword">noexcept</span><br>&gt;&#123; <br>&gt;<span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t); <br>&gt;&#125;<br></code></pre></td></tr></table></figure>在返回类型和类型转换中也要用到<code>typename</code>（《c++primer》p593）。<code>std::remove_reference&lt;T&gt;::type</code>的用处就是去除类型的引用（《c++primer》p605）。<code>static_cast</code>静态类型转换（《c++primer》p145）。- std::move是如何工作的</p><p>这段代码很短，但其中有些微妙之处。首先，move的函数参数<code>T&amp;&amp;</code>是一个指向模板类型参数的右值引用。通过引用折叠，此参数可以与任何类型的实参匹配。特别是，我们既可以传递给move一个左值，也可以传递给它一个右值:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-function">string <span class="hljs-title">s1</span> <span class="hljs-params">( <span class="hljs-string">&quot;hi! &quot;</span>)</span>,s2</span>;<br>&gt;s2 = std::<span class="hljs-built_in">move</span> (<span class="hljs-built_in">string</span> ( <span class="hljs-string">&quot;bye!&quot;</span>) );<span class="hljs-comment">//正确:从一个右值移动数据</span><br>&gt;s2 = std::<span class="hljs-built_in">move</span>(s1);<span class="hljs-comment">//正确:但在赋值之后，s1的值是不确定的(内容被移动赋值运算符移动过)。</span><br></code></pre></td></tr></table></figure>在第一个赋值中，传递给move的实参是string的构造函数的右值结果。在<code>std::move(string("bye!"))</code>中:1. 推断出的T的类型为string。 2. 因此remove_reference用string进行实例化。3. remove_reference<string>的type成员是string。 4.move的返回类型是string&amp;&amp;。 5.move的函数参数t的类型为string&amp;&amp;。</p><p>因此，这个调用实例化move<string>，即函数<code>string&amp;&amp; move(string &amp;&amp;t)</code></p><p>函数体返回<code>static_cast&lt;string&amp;&amp;&gt;(t)</code>。<code>t</code>的类型已经是<code>string&amp;&amp;</code>,于是类型转换什么都不做。因此，此调用的结果就是它所接受的右值引用（返回值为右值引用类型有临时对象产生）。..现在考虑第二个赋值，它调用了<code>std::move ()</code>。在此调用中，传递给move的实参是一个左值。这样:1. 推断出的T的类型为string&amp; (string 的引用，而非普通string)。 2.因此，remove reference用string&amp;进行实例化。 3. removereference&lt;string&amp;&gt;的type成员是string。 4.move的返回类型仍是string&amp;&amp; 。 5.move的函数参数t实例化为string&amp; &amp;&amp;，会折叠为string&amp;。</p><p>因此，这个调用实例化<code>move&lt;string&amp;&gt;</code>，即<code>string&amp;&amp;  move(string &amp;t)</code>这正是我们所寻求的—我们希望将一个右值引用绑定到一个左值。这个实例的函数体返回<code>static_cast&lt;string&amp;&amp;&gt;(t)</code>。在此情况下，<code>t</code>的类型为<code>string&amp;</code>，cast将其转换为<code>string&amp;&amp;</code>(强转伴随临时对象xvalue的产生其空间地址与<code>std::move()</code>函数产生的临时对象xvalue的空间地址相同)。<img src="/img/00004/19.png" alt="在这里插入图片描述" />将右值引用绑定到一个被强转成xvalue的左值，这一特性被称为截断。（《c++primer》p612）### std::move()函数总结说白了<code>std::move()</code>函数就是将一个prvalue或者lvalue转变成xvalue的过程，这样不管是prvalue还是lvalue都可以被右值引用接受。</p></blockquote><hr /><h2id="接下来咱们来分析标准库forward函数">接下来咱们来分析标准库forward函数:</h2><blockquote><p>在分析forward源码之前，咱们先来看看forward完成了一个什么样的功能。我们知道某些函数需要将其一个或多个实参连同类型不变地转发给其他函数。在此情况下，我们需要保持被转发实参的所有性质,包括实参类型是否是<code>const</code>的以及实参是左值还是右值。作为一个例子，我们将编写一个函数，它接受一个可调用表达式和两个额外实参。我们的函数将调用给定的可调用对象，将两个额外参数逆序传递给它。下面是我们的翻转函数的模样:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//接受一个可调用对象和另外两个参数的模板</span><br><span class="hljs-comment">//对“翻转”的参数调用给定的可调用对象</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span> T1,<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flip2</span><span class="hljs-params">(F f,T1 &amp;&amp;t1,T2 &amp;&amp;t2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">f</span> (t2,t1);<br>)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> v1,<span class="hljs-type">int</span> &amp;v2)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; v1 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ++v2 &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>通过将一个函数参数定义为一个指向模板类型参数的右值引用，我们可以保持其对应实参的所有类型信息。而使用引用参数(无论是左值还是右值)使得我们可以保持<code>const</code>属性，因为在引用类型中的<code>const</code>是底层的。如果我们将函数参数定义为<code>T1&amp;&amp;</code>和<code>T2&amp;&amp;</code>,通过引用折叠，就可以保持翻转后实参的左值/右值属性（对应实参的<code>const</code>属性和左值/右值属性将得到保持）:例如，如果我们调用<code>flip2(f，j，42)</code>，将传递给参数<code>t1</code>一个左值<code>j</code>。但是，在<code>flip2</code>中，推断出的<code>T1</code>的类型为<code>int&amp;</code>，这意味着<code>t1</code>的类型会折叠为<code>int&amp;</code>。由于是引用类型，<code>t1</code>被绑定到<code>j</code>上。当<code>flip2</code>调用<code>f</code>时，<code>f</code>中的引用参数<code>v2</code>被绑定到<code>t1</code>，也就是被绑定到<code>j</code>。当<code>f</code>递增<code>v2</code>时，它也同时改变了<code>j</code>的值。. 现在，咱们不用可调用对象<code>f</code>，用<code>g</code>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//接受一个可调用对象和另外两个参数的模板</span><br><span class="hljs-comment">//对“翻转”的参数调用给定的可调用对象</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span> T1,<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flip2</span><span class="hljs-params">(F f,T1 &amp;&amp;t1,T2 &amp;&amp;t2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">g</span>(t2,t1);<br>)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;&amp;i, <span class="hljs-type">int</span>&amp; j)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>如果我们试图通过<code>flip2</code>调用<code>g</code>，则参数<code>t2</code>将被传递给<code>g</code>的右值引用参数。即使我们传递一个右值给<code>flip2</code>:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">flip2</span>(g, i，<span class="hljs-number">42</span>);<span class="hljs-comment">//错误:不能从一个左值实例化int&amp;&amp;</span><br></code></pre></td></tr></table></figure>传递给<code>g</code>的将是<code>flip2</code>中名为<code>t2</code>的参数。函数参数与其他任何变量一样，都是左值表达式。因此，<code>flip2</code>中对<code>g</code>的调用将传递给<code>g</code>的右值引用参数一个左值。 .在调用中使用<code>std::forward</code>保持类型信息 .我们可以使用一个名为forward的新标准库设施来传递<code>flip2</code>的参数,它能保持原始实参的类型。类似move,forward定义在头文件utility中。与move不同,forward必须通过显式模板实参来调用。forward返回该显式实参类型的右值引用。即，<code>forward&lt;T&gt;</code>的返回类型是<code>T&amp;&amp;</code>。通常情况下，我们使用forward传递那些定义为模板类型参数的右值引用的函数参数。通过其返回类型上的引用折叠，forward可以保持给定实参的左值/右值属性(forward可以保持实参类型的所有细节)。使用forward，我们可以再次重写翻转函数: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> F,<span class="hljs-keyword">typename</span> T1,<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flip</span><span class="hljs-params">(F f,T1 &amp;&amp;t1,T2 &amp;&amp;t2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">g</span>(std::forward&lt;T2&gt;(t2),std::forward&lt;T1&gt;(t1)) ;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;&amp;i, <span class="hljs-type">int</span>&amp; j)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>如果我们调用<code>flip(g, i，42)</code>，<code>i</code>将以<code>int&amp;</code>类型传递给<code>g</code>，<code>42</code>将以<code>int&amp;&amp;</code>类型的<code>xvalue</code>传递给<code>g</code>。（primer没说清楚，单纯因为42是int&amp;&amp;类型是无法传给可调用对象g。lvalue可以是int&amp;&amp;类型，xvalue也可以是int&amp;&amp;类型，但是lvalue不能传给右值引用，而xvalue可以。）</p></blockquote><hr /><blockquote><p>现在咱们知道forward是干什么的了。废话不多说直接分析它的源码，看看它如何保持实参类型的所有细节。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> _Tp&amp;&amp;</span><br><span class="hljs-function"><span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="hljs-type">_t</span>)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123; <br><span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="hljs-type">_t</span>); <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> _Tp&amp;&amp;</span><br><span class="hljs-function"><span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="hljs-type">_t</span>)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">static_assert</span>(!std::is_lvalue_reference&lt;_Tp&gt;::value, <span class="hljs-string">&quot;template argument&quot;</span><br>    <span class="hljs-string">&quot; substituting _Tp is an lvalue reference type&quot;</span>);    <br><span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="hljs-type">_t</span>);<br>&#125;<br></code></pre></td></tr></table></figure><code>std::forward</code>有两个版本的重载，一个用于左值一个用于右值。不过咱们一般用的是第一个版本，因为用在形参上，形参不管怎么样都是个左值。那我们就只分析第一个版本的情况：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> F,<span class="hljs-keyword">typename</span> T1,<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flip</span><span class="hljs-params">(F f,T1 &amp;&amp;t1,T2 &amp;&amp;t2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">g</span>(std::forward&lt;T2&gt;(t2),std::forward&lt;T1&gt;(t1)) ;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;&amp;i, <span class="hljs-type">int</span>&amp; j)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>就拿上面这个例子来说，如果我们调用<code>flip(g, i，42)</code>。<code>T2</code>将被推导成<code>int</code>，<code>t2</code>的类型为<code>int&amp;&amp;</code>。调用<code>std::forward&lt;T2&gt;(t2)</code>时，forward函数将被实例化成：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span>&amp;&amp;</span><br><span class="hljs-function"><span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; <span class="hljs-type">_t</span>)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123; <br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&amp;&amp;&gt;(<span class="hljs-type">_t</span>); <br>&#125;<br></code></pre></td></tr></table></figure><code>_t</code>的类型为<code>int&amp;</code>，return时<code>_t</code>被强制转换成<code>int&amp;&amp;</code>，此时强转产生的<code>xvalue</code>和forward函数由返回类型<code>int&amp;&amp;</code>而产生的<code>xvalue</code>在同一空间地址。<code>xvalue</code>可以被函数<code>g</code>的形参<code>i</code>所接受，完成<code>flip</code>实参<code>42</code>的类型保持。</p><p><code>T1</code>将被推导成<code>int&amp;</code>，<code>t1</code>的类型被折叠成<code>int&amp;</code>。调用<code>std::forward&lt;T1&gt;(t1)</code>时，forward函数将被实例化成：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span>&amp;</span><br><span class="hljs-function"><span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; <span class="hljs-type">_t</span>)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123; <br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&amp;&gt;(<span class="hljs-type">_t</span>); <br>&#125;<br></code></pre></td></tr></table></figure>返回类型折叠成<code>int&amp;</code>。<code>t1</code>传入<code>flip</code>中是左值引用传入，被forward转换后也是左值引用。完成类型保持。</p></blockquote><hr /><h3 id="stdforward总结">std::forward总结</h3><blockquote><p>不难看出forward函数跟move函数的工作原理都一样，用的引用折叠技术。 -forward将g函数的右值引用类型实参从左值转换成右值，保持rvalue能被int&amp;&amp;接收的性质（可调用对象的形参类型为int&amp;&amp;，接受实参值的类型为rvalue）。-而g函数的左值引用类型实参，进入forward是左值引用进入，函数返回也是左值引用传出，没变化。-最后g函数的形参为int类型时，接受实参值的类型为lvalue或rvalue。forward不管怎么转换，它都可以接受。</p><p>这就是所谓的类型保持（可能叙述的不是特别详细，毕竟过程有点复杂，只是起一个抛砖引玉的作用，大家可以下去自己捣鼓捣鼓）。.</p></blockquote><hr /><h2id="最后咱们来看下move和forword的不同之处">最后咱们来看下move和forword的不同之处。</h2><blockquote><p>std::move函数的源码： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>&gt;<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp;<br>&gt;<span class="hljs-built_in">move</span>(T&amp;&amp; t) <span class="hljs-keyword">noexcept</span><br>&gt;&#123; <br><span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t); <br>&gt;&#125;<br></code></pre></td></tr></table></figure> std::forward函数的源码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>&gt;<span class="hljs-keyword">constexpr</span> _Tp&amp;&amp;<br>&gt;forward(<span class="hljs-keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="hljs-type">_t</span>) <span class="hljs-keyword">noexcept</span><br>&gt;&#123; <br><span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="hljs-type">_t</span>); <br>&gt;&#125;<br></code></pre></td></tr></table></figure>不难发现，move函数的<code>std::remove_reference&lt;T&gt;::type</code>，放在返回类型和<code>static_cast&lt;&gt;</code>中，而且后面都是直接接上两个<code>&amp;&amp;</code>。他这样写的目的在于，不管<code>t</code>接受的是一个右值还是一个左值，返回出来值的类型永远都是右值。永远能被<code>int&amp;&amp;</code>接受。而forward函数的<code>std::remove_reference&lt;T&gt;::type</code>，放在形参<code>_t</code>上，而且返回类型和<code>static_cast&lt;&gt;</code>都用了引用折叠技术，值得注意的一点是move函数不需要显示指定模板的类型，而forward函数需要显示指定实参类型。forward函数的形参一定是引用传入，而且返回类型和<code>static_cast&lt;&gt;</code>可以根据实参类型动态改变。forward函数的实参类型为<code>int&amp;&amp;</code>，则返回类型为<code>int&amp;&amp;</code>，返回出去的就是一个<code>xvalue</code>。forward函数的实参类型为<code>int&amp;</code>，则返回类型也为<code>int&amp;</code>，返回出去的和传入进来的都是实参的引用。--------------------------------------------------------</p></blockquote><h1 id="附件">附件</h1><blockquote><p>注意：下面的文件下载都是免费的，0积分下载，别被VIP字样吓到了蛤 🤗 <ahref="https://download.csdn.net/download/Howl_1/77241824">右值引用相关文档</a><ahref="https://download.csdn.net/download/Howl_1/77242257">测试代码的反汇编代码</a></p></blockquote><h1 id="附录">附录</h1><blockquote><p>摘取自《c++ template 2nd》附录中的内容，可以用来检查表达式的值类别（value category of the expression：prvalue，xvalue或lvalue）。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ISXVALUE(x) \</span><br><span class="hljs-meta">std::is_rvalue_reference<span class="hljs-string">&lt;decltype((x))&gt;</span>::value</span><br>&gt;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ISLVALUE(x)\</span><br><span class="hljs-meta">std::is_lvalue_reference<span class="hljs-string">&lt;decltype((x))&gt;</span>::value</span><br>&gt;<span class="hljs-meta">#<span class="hljs-keyword">define</span> CHEECK_VALUE_CATOGORIES(x) \</span><br><span class="hljs-meta"><span class="hljs-keyword">if</span>(ISXVALUE(x)) printf(<span class="hljs-string">&quot;%s is a xvalue\n&quot;</span>,#x);\</span><br><span class="hljs-meta"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ISLVALUE(x)) printf(<span class="hljs-string">&quot;%s is a lvalue\n&quot;</span>,#x);\</span><br><span class="hljs-meta"><span class="hljs-keyword">else</span> printf(<span class="hljs-string">&quot;%s is a prvalue\n&quot;</span>,#x);</span><br></code></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用tcpdump观察TCP头部信息和三次握手四次挥手</title>
    <link href="/2021/07/25/00003.%20%E4%BD%BF%E7%94%A8tcpdump%E8%A7%82%E5%AF%9FTCP%E5%A4%B4%E9%83%A8%E4%BF%A1%E6%81%AF%EF%BC%88%E8%A1%A5%E5%85%85TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%EF%BC%89/"/>
    <url>/2021/07/25/00003.%20%E4%BD%BF%E7%94%A8tcpdump%E8%A7%82%E5%AF%9FTCP%E5%A4%B4%E9%83%A8%E4%BF%A1%E6%81%AF%EF%BC%88%E8%A1%A5%E5%85%85TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><blockquote><p><strong>本篇文章为笔者的读书笔记，未经允许请勿转载。</strong><br />本次实验是目的在于弄清tcp头部信息和三次握手四次挥手的细节，并且补充一些tcp协议的常用知识。读本文需要一些前置知识，具体请参照《linux高性能服务器编程》p32-p37。实验测试机是阿里云ECS服务器和本地虚拟机。不同于书本上，它的测试机是在同一局域网内。--------------------------------------------------------</p></blockquote><h1 id="实验开始">实验开始</h1><ul><li><p>　<font color='red'>在服务器上将echo服务打开，具体请看笔者写的tcpdump观察ARP通信过程，这里不多赘述。</font></p></li><li><p>　<font color='red'> 在本地虚拟机上开启两个终端 </font></p></li><li><p>　<font color='red'> 监听终端</font></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@ubuntu:/<span class="hljs-comment"># tcpdump -S -i ens33 -ntx &#x27;(src 192.168.1.7 and dst 120.79.72.214) or (src 120.79.72.214 and dst 192.168.1.7)&#x27;</span><br>tcpdump: verbose output suppressed, use -v or -vv <span class="hljs-keyword">for</span> full protocol decode<br>listening on ens33, link-type EN10MB (Ethernet), capture size 262144 bytes<br></code></pre></td></tr></table></figure><blockquote><p>-S序号和确认号以绝对值形式显示（如果是相对值显示，则从第三个报文开始，seq和ack相对ISN的偏移）,-i 监听指定网络接口ens33，-n指定将每个监听到数据包中的域名转换成IP地址后显示，-t在输出的每一行不打印时间戳, -x把协议头和包内容都原原本本的显示出来（tcpdump会以16进制和ASCII的形式显示）。后面src表示源ip，dst表示目的ip，这样写可以起到一个滤包的作用。</p></blockquote><ul><li>　<font color='red'> 测试终端</font></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@ubuntu:/home/marvel<span class="hljs-comment"># telnet 120.79.72.214 7</span><br>Trying 120.79.72.214...<br>Connected to 120.79.72.214.<br>Escape character is <span class="hljs-string">&#x27;^]&#x27;</span>.<br>1<br>1<br>^]<br>telnet&gt; q<br>Connection closed.<br>root@ubuntu:/home/marvel<span class="hljs-comment"># </span><br><br></code></pre></td></tr></table></figure><ul><li>　<font color='red'> 监听终端</font></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@ubuntu:/home/marvel<span class="hljs-comment"># tcpdump -S -i ens33 -ntx &#x27;(src 192.168.1.7 and dst 120.79.72.214) or (src 120.79.72.214 and dst 192.168.1.7)&#x27;</span><br>tcpdump: verbose output suppressed, use -v or -vv <span class="hljs-keyword">for</span> full protocol decode<br>listening on ens33, link-type EN10MB (Ethernet), capture size 262144 bytes<br>1）IP 192.168.1.7.39804 &gt; 120.79.72.214.7: Flags [S], <span class="hljs-built_in">seq</span> 3843050562, win 64240, options [mss 1460,sackOK,TS val 2363801315 ecr 0,nop,wscale 7], length 0<br>0x0000:  4510 003c 3496 4000 4006 8341 c0a8 0107<br>0x0010:  784f 48d6 9b7c 0007 e510 4c42 0000 0000<br>0x0020:  a002 faf0 8303 0000 0204 05b4 0402 080a<br>0x0030:  8ce4 bee3 0000 0000 0103 0307<span class="hljs-comment">#60字节（16位，两字节，一组，一共30组），同步报文</span><br>2）IP 120.79.72.214.7 &gt; 192.168.1.7.39804: Flags [S.], <span class="hljs-built_in">seq</span> 3051969109, ack 3843050563, win 65160, options [mss 1400,sackOK,TS val 743316774 ecr 2363801315,nop,wscale 7], length 0<br>0x0000:  4514 003c 0000 4000 3406 c3d3 784f 48d6<br>0x0010:  c0a8 0107 0007 9b7c b5e9 5a55 e510 4c43<br>0x0020:  a012 fe88 547b 0000 0204 0578 0402 080a<br>0x0030:  2c4e 1d26 8ce4 bee3 0103 0307<span class="hljs-comment">#60字节（16位，两字节，一组，一共30组），同步确认报文</span><br>3）IP 192.168.1.7.39804 &gt; 120.79.72.214.7: Flags [.], ack 3051969110, win 502, options [nop,nop,TS val 2363801340 ecr 743316774], length 0<br>0x0000:  4510 0034 3497 4000 4006 8348 c0a8 0107<br>0x0010:  784f 48d6 9b7c 0007 e510 4c43 b5e9 5a56<br>0x0020:  8010 01f6 82fb 0000 0101 080a 8ce4 befc<br>0x0030:  2c4e 1d26<span class="hljs-comment">#52字节（16位，两字节，一组，一共26组），确认报文</span><br>4）IP 192.168.1.7.39804 &gt; 120.79.72.214.7: Flags [P.], <span class="hljs-built_in">seq</span> 3843050563:3843050566, ack 3051969110, win 502, options [nop,nop,TS val 2363810557 ecr 743316774], length 3<br>0x0000:  4510 0037 3498 4000 4006 8344 c0a8 0107<br>0x0010:  784f 48d6 9b7c 0007 e510 4c43 b5e9 5a56<br>0x0020:  8018 01f6 82fe 0000 0101 080a 8ce4 e2fd<br>0x0030:  2c4e 1d26 310d 0a<span class="hljs-comment">#55字节，length（数据长度）=55-52，</span><br>5）IP 120.79.72.214.7 &gt; 192.168.1.7.39804: Flags [.], ack 3843050566, win 510, options [nop,nop,TS val 743326016 ecr 2363810557], length 0<br>0x0000:  4514 0034 d00d 4000 3406 f3cd 784f 48d6<br>0x0010:  c0a8 0107 0007 9b7c b5e9 5a56 e510 4c46<br>0x0020:  8010 01fe 375f 0000 0101 080a 2c4e 4140<br>0x0030:  8ce4 e2fd<span class="hljs-comment">#52字节，确认报文</span><br>6）IP 120.79.72.214.7 &gt; 192.168.1.7.39804: Flags [P.], <span class="hljs-built_in">seq</span> 3051969110:3051969113, ack 3843050566, win 510, options [nop,nop,TS val 743326016 ecr 2363810557], length 3<br>0x0000:  4514 0037 d00e 4000 3406 f3c9 784f 48d6<br>0x0010:  c0a8 0107 0007 9b7c b5e9 5a56 e510 4c46<br>0x0020:  8018 01fe fc46 0000 0101 080a 2c4e 4140<br>0x0030:  8ce4 e2fd 310d 0a<span class="hljs-comment">#55字节，length（数据长度）=55-52。</span><br>7）IP 192.168.1.7.39804 &gt; 120.79.72.214.7: Flags [.], ack 3051969113, win 502, options [nop,nop,TS val 2363810582 ecr 743326016], length 0<br>0x0000:  4510 0034 3499 4000 4006 8346 c0a8 0107<br>0x0010:  784f 48d6 9b7c 0007 e510 4c46 b5e9 5a59<br>0x0020:  8010 01f6 82fb 0000 0101 080a 8ce4 e316<br>0x0030:  2c4e 4140<span class="hljs-comment">#52字节</span><br>8）IP 192.168.1.7.39804 &gt; 120.79.72.214.7: Flags [F.], <span class="hljs-built_in">seq</span> 3843050566, ack 3051969113, win 502, options [nop,nop,TS val 2363813862 ecr 743326016], length 0<br>0x0000:  4510 0034 349a 4000 4006 8345 c0a8 0107<br>0x0010:  784f 48d6 9b7c 0007 e510 4c46 b5e9 5a59<br>0x0020:  8011 01f6 82fb 0000 0101 080a 8ce4 efe6<br>0x0030:  2c4e 4140<span class="hljs-comment">#52字节，</span><br>9）IP 120.79.72.214.7 &gt; 192.168.1.7.39804: Flags [F.], <span class="hljs-built_in">seq</span> 3051969113, ack 3843050567, win 510, options [nop,nop,TS val 743329323 ecr 2363813862], length 0<br>0x0000:  4514 0034 d00f 4000 3406 f3cb 784f 48d6<br>0x0010:  c0a8 0107 0007 9b7c b5e9 5a59 e510 4c47<br>0x0020:  8011 01fe 1d86 0000 0101 080a 2c4e 4e2b<br>0x0030:  8ce4 efe6<span class="hljs-comment">#52字节</span><br>10）IP 192.168.1.7.39804 &gt; 120.79.72.214.7: Flags [.], ack 3051969114, win 502, options [nop,nop,TS val 2363813889 ecr 743329323], length 0<br>0x0000:  4510 0034 349b 4000 4006 8344 c0a8 0107<br>0x0010:  784f 48d6 9b7c 0007 e510 4c47 b5e9 5a5a<br>0x0020:  8010 01f6 82fb 0000 0101 080a 8ce4 f001<br>0x0030:  2c4e 4e2b<span class="hljs-comment">#52字节</span><br>^C<br>10 packets captured<br>10 packets received by filter<br>0 packets dropped by kernel<br>root@ubuntu:/home/marvel<span class="hljs-comment"># </span><br><br></code></pre></td></tr></table></figure><figure><img src="/img/00003/tcp三次握手四次挥手.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><blockquote><p>这里面信息量巨大，待我们来慢慢分析里面的细节！ ## 1. 延迟确认1）-3）是3次握手，8）-10）是4次挥手，但是这里只有三段报文段。原因是，<strong>延迟确认</strong>，即服务器不会马上确认收到的数据，而是在一段延迟时间后查看本端是否有数据要发送，如果有，则和确认信息一起发出。延迟确认可以减少发送tcp报文段的数量。这里的四次挥手中服务器的确认报文和结束报文一次性发送给客户端了。（书上是在局域网内进行的，没有延迟确认）</p><h2 id="序号seq和确认号ack之间的关系">2.序号（seq）和确认号（ack）之间的关系</h2><p>序号的相对值是相对于自身发出第一个tcp报文段中的seq确认号的相对值是相对于对方发出第一个tcp报文段中的seq（以绝对值显示的就不用管啦）序号的值除了两次开头的同步报文是由系统初始化为某个随机ISN。<strong>其他序号为上一条对方发送报文段的确认号</strong>，由图中的红色线条为代表（一来一回）。如果是一方连续发送报文段（连续去没回），<strong>则序列号为ISN加上该报文段所携带数据的第一个字节在整个字节流中的偏移</strong>（这一点本文未涉及，读者在观察其他复杂通信过程中肯定会碰到）。确认号的值，如果是在三次握手1）-3）和四次挥手8）-10）中，则ack=对方发送报文段的seq+1；<strong>如果是在数据传输过程中4）-7）,ack=上一条对方发送报文段的seq+数据长度。例如本例中报文段5）的确认号（3843050566）=上一条对方发送报文段的seq（3843050563）+它的数据字节（3）</strong>,得到的也就是报文段4）seq3843050563:3843050566，冒号后面那个值。冒号后面的值是由tcpdump自行添加的，其值刚好为接收端ack的值。总结：<strong>序列号的相对值是对字节流的标识，根据序列号的差值可以确定两个数据报之间数据的大小</strong>。## 3.TS val和ecr的关系这两者的关系很少有人提及，咱们直接看维基百科的解释</p><p>There are two timestamp fields: <strong>TS val：a 4-byte sendertimestamp value (my timestamp)</strong> <strong>ecr：a 4-byte echo replytimestamp value (the most recent timestamp received from you).</strong><strong>TCP timestamps are used in an algorithm known as ProtectionAgainst Wrapped Sequence numbers, or PAWS (see RFC 1323 fordetails)</strong>. PAWS is used when the receive window crosses thesequence number wraparound boundary. In the case where a packet waspotentially retransmitted it answers the question: <strong>"Is thissequence number in the first 4 GB or the second?" And the timestamp isused to break the tie</strong>.TCP时间戳选项有助于在传输非常大的数据流时保护包装序列。TCP中的序列号字段只有32位，所以序列号大于2^32-1之后，序列号会绕回开始。另一个作用计算RTT值。 The Timestamp option can be used to measure theround-trip time (RTT) of every packet that is acknowledged. This is doneby including a Timestamp Value TSval in every segment that is sent.These TSval values are echoed by the opposite side of the connection inthe Timestamp Echo Reply TSecr field. So, when a segment is ACKed, thesender of that segment can simply subtract their current timestamp fromthe TSecr value to compute an accurate Round Trip Time (RTT)measurement. RTT = 当前时间 -数据包中Timestamp选项的回显时间（这个回显时间是该数据包发出去的时间） ##4. TCP状态转移（书上p41-p42原话） <imgsrc="/img/00003/tcp状态转移图.png" alt="在这里插入图片描述" /></p><p><strong>重点掌握ESTABLISHED,FIN_WAIT_2&lt;--&gt;CLOSE_WAIT,TIME_WAIT(2MSL)</strong>==首先==讨论服务器的典型状态转移过程(<strong>虚线路径</strong>)，此时说的连接状态都是指该连接的服务器端的状态。服务器通过listen系统调用<strong>进入LISTEN状态</strong>，被动等待客户端连接，因此执行的是所谓的被动打开。服务器一旦监听到某个连接请求（收到同步报文段），就将该连接放入内核等待队列中，并向客户端发送带SYN标志的确认报文段。此时该连接<strong>处于SYN_RCVD状态</strong>。如果服务器成功地接收到客户端发送回的确认报文段，则该连接转<strong>移到ESTABLISHED</strong>。ESTABLISHED状态是连接双方能够进行双向数据传输的状态。当客户端主动关闭连接时，服务器通过返回确认报文段使连接<strong>进入CLOSE_WAIT状态</strong>。这个状态的含义很明确：等待服务器应用程序关闭连接。通常，服务器检测到客户端关闭连接后，也会立即给客户端发送一个结束报文段来关闭连接。这将使连接<strong>转移到LAST_ACK状态</strong>，以等待客户端对结束报文段的最后一次确认。一旦确认完成，连接彻底关闭了。==其次==讨论客户端（<strong>粗黑线</strong>），客户端通过connect系统调用（见第5章）主动与服务器建立连接。connect系统调用首先给服务器发送一个同步报文段，使连接<strong>转移到SYN_SENT状态</strong>。connect调用失败将使连接立即返回到初始的CLOSED状态。如果客户端成功收到服务器的同步报文段和确认，则connect调用成功返回，连接<strong>转移至ESTABLISHED状态</strong>。当客户端执行主动关闭时，它将向服务器发送一个结束报文段，同时连接<strong>进入FIN_WAIT_1状态</strong>（到达这个状态时，会发送FIN告诉对方我要关闭连接）。若此时客户端收到服务器专门用于确认目的的确认报文段（比如图3-6中的TCP报文段5)，则连接<strong>转移至FIN_WAIT_2状态</strong>（这个状态也称为半关闭状态，即客户端将自己的写buffer关闭了，但是读buffer还在）。当客户端处于FIN_WAIT_2状态时，服务器处于CLOSE_WAIT状态，这一对状态是可能发生半关闭的状态。此时如果服务器也关闭连接（发送结束报文段)，则客户端将给予确认并<strong>进入TIME_WAIT状态</strong>，在这个状态客户端要等待2MSL（报文最大生存时间），才能完全关闭。## 5. FIN_WAIT_2状态(半关闭状态)</p><p>处于FIN_WAIT_2状态的客户端需要等待服务器发送结束报文段，才能转移至TIME_WAIT状态，否则它将一直停留在这个状态。<strong>如果不是为了在半关闭状态下继续接收数据，连接长时间地停留在FIN_WAIT_2状态并无益处</strong>。连接停留在FIN_WAIT_2状态的情况可能发生在:客户端执行半关闭后，未等服务器关闭连接就强行退出了。此时客户端连接由内核来接管，可称之为<strong>孤儿连接</strong>（和孤儿进程类似)。Linux为了防止孤儿连接长时间存留在内核中，定义了两个内核变量:l/proc/sys/net/ipv4/tcp_max_orphans和/proc/syslnet/ipv4/tcp_fin_timeout。前者指定内核能接管的孤儿连接数目，后者指定孤儿连接在内核中生存的时间。## 6. TIME_WAIT状态 TIME_WAIT状态存在的原因有两 一：可靠地终止TCP连接。<strong>TIME_WAIT状态为2MSL可以保证最糟糕情况也可以收到超时重传的FIN报文</strong>（确认报文半路嗝屁，最大存活时间MSL，重传的FIN报文到客户端花费的最大时间MSL，即收到重传的FIN报文小于等于2MSL）。二：保证让迟来的TCP报文段有足够的时间被识别并丢弃。我们反过来思考，如果没有TIME_WAIT状态，则应用程序能够立即创立一个和刚关闭的连接相似的连接（具有相同IP，和端口号）。这个新的，和原来相似的连接被称为原来连接的化身。<strong>新的化身可能接收到属于原来的连接的，携带应用程序数据的TCP报文段（迟到的报文段）</strong>，这显然不应该发生的。## 7. 细说4）TCP报文段的详细信息 <imgsrc="/img/00003/tcp报文段详细信息.png" alt="在这里插入图片描述" />1.该报文段是一个数据报文段. Flags[P.]:提示接收端应用程序应该立即从TCP接收缓冲区中读走数据，为后续数据腾出空间; seq是序列号，“:”后面的数值是下条接收方确认报文的确 认号; ack是确认号;win是窗大小，是TCP流量控制的-一个手段，如果是一个RWND (接收通告窗口)，它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样可以控制发送数据的速度; options后面再说;length是指数据长度，没包括头部长度，即整个报文长度减去头 部长度。2.十六进制数据具体分析。(16位一 组，一组两字节)</p><p><img src="/img/00003/ip头部.png" alt="在这里插入图片描述" /><imgsrc="/img/00003/ipv4头部结构.png" alt="在这里插入图片描述" />由于IP的选项很少用到，所以基本上都是20字节。</p><table><thead><tr class="header"><th>十六进制</th><th>十进制</th><th>二进制</th><th>IP头部信息</th></tr></thead><tbody><tr class="odd"><td>0x4</td><td>4</td><td></td><td>IP版本号</td></tr><tr class="even"><td>0x5</td><td>5</td><td></td><td>头部长度为5个32位（20字节）</td></tr><tr class="odd"><td>0x10</td><td>16</td><td>0001 0000</td><td>TOS选项中最小延时服务被开启</td></tr><tr class="even"><td>0x0037</td><td>55</td><td></td><td>数据报总长度，55字节</td></tr><tr class="odd"><td>0x3498</td><td></td><td></td><td>数据报标识</td></tr><tr class="even"><td>0x4</td><td>4</td><td>0100（前三位有用）</td><td>设置了禁止分片标志</td></tr><tr class="odd"><td>0x000</td><td>0</td><td></td><td>分片偏移</td></tr><tr class="even"><td>0x40</td><td>64</td><td></td><td>TTL被设为64</td></tr><tr class="odd"><td>0x06</td><td>6</td><td></td><td>协议字段为6，表示上层协议是TCP协议</td></tr><tr class="even"><td>0x8344</td><td></td><td></td><td>IP头部校验和</td></tr><tr class="odd"><td>0xc0a8 0107</td><td></td><td>11000000.10101000.00000001.00000111</td><td>32位源端IP地址 192.168.1.7</td></tr><tr class="even"><td>0x784f 48d6</td><td></td><td>01111000.01001111.01001000.11010110</td><td>32位目的端IP地址 120.79.72.214</td></tr></tbody></table></blockquote><p><img src="/img/00003/tcp头部.png" alt="在这里插入图片描述" /><imgsrc="/img/00003/tcp头部选项.png" alt="在这里插入图片描述" /></p><table><thead><tr class="header"><th>十六进制</th><th>十进制</th><th>二进制</th><th>TCP头部信息</th></tr></thead><tbody><tr class="odd"><td>0x9b7c</td><td>39804</td><td></td><td>源端口号</td></tr><tr class="even"><td>0x0007</td><td>7</td><td></td><td>目的端口号</td></tr><tr class="odd"><td>0xe510 4c43</td><td></td><td></td><td>序列号</td></tr><tr class="even"><td>0xb5e9 5a56</td><td></td><td></td><td>确认号</td></tr><tr class="odd"><td>0x8</td><td>8</td><td></td><td>TCP头部长度为8个32位（32字节）</td></tr><tr class="even"><td>0x018</td><td></td><td>00011000（后面6位有效）</td><td>ACK和PSH标志位开启</td></tr><tr class="odd"><td>0x01f6</td><td>502</td><td></td><td>窗口大小</td></tr><tr class="even"><td>0x82fe</td><td></td><td></td><td>16位校验和</td></tr><tr class="odd"><td>0x0000</td><td></td><td></td><td>没设置URG标志，紧急指针此处无意义</td></tr><tr class="even"><td>0x0101</td><td></td><td></td><td>两次kind的值均为1，两次nop操作，一般用于将TCP选项的总长度填充为4字节的整数倍</td></tr><tr class="odd"><td>0x080a</td><td></td><td></td><td>kind=8，length=10（10字节），时间戳选项，较为准确的计算通信双方之间的RTT（回路时间）</td></tr><tr class="even"><td>0x8ce4 e2fd</td><td>2363810557</td><td></td><td>时间戳</td></tr><tr class="odd"><td>0x2c4e 1d26</td><td>743316774</td><td></td><td>回显应答时间戳</td></tr></tbody></table><p><img src="/img/00003/数据段.png" alt="在这里插入图片描述" /> |十六进制| 十进制| 二进制| 数据段信息| |--|--|--|--| | 0x31| 49| |字符‘1’| | 0x0d| 13| | 回车符| | 0x0a| 10| | 换行符| &gt;一共三个字节。&gt;## 8.Flags[p.],Flags[F.],Flags[.]中的点的含义&gt;[.]这个点的含义通常是表示ACK(这个ACK和确认号不同，这是标志位)，还可以表示URG&gt;<strong>Flags[F.]、Flags[p.]和Flags[.]这里的点表示的就是ACK标志位开启</strong>。&gt;## 9.MSS(最大报文段长度)&gt;TCP模块通常将MSS设置为【MTU（最大传输单元）-40】字节，40字节是TCP和IP的头部总和。这样携带TCP报文段的IP数据报的长度就不会超过MTU（假设TCP和IP头部不包含选项字段），从而避免本机发生IP分片。以太网的MSS值是1460（1500-40）字节。# 复位报文段 &gt;携带RST标志的报文段，即复位报文段。&gt;产生复位报文段的四种情况 &gt;1.当客户端访问一个不存在的端口时。&gt;2.客户端程序向服务器的某个端口发起连接，而该端口仍被处于TIME_WAIT状态的连接所占用时。&gt;3.异常终止连接，TCP提供了异常终止一个连接的方法，即给对方发送一个复位报文段，一旦发送了复位报文段，发送端所有排队等待发送的数据都将被丢弃。&gt;4.服务器（或客户端）关闭或者异常终止了连接，而对方没接收到结束报文段（比如网络故障），此时，客户端（或服务器）还维持着原来的连接。这种状态称为半打开状态，处于这种状态的连接称为半打开连接。如果客户端（或服务器）往处于半打开状态的连接写入数据，则对方将回应一个复位报文段。# TCP超时重传&gt;TCP模块为每个TCP报文段都维护一个重传定时器，该定时器在TCP报文段第一次被发送时启动。如果超时时间内未收到接收方的应答，TCP模块将重传TCP报文段并重置定时器。至于下次重传的超时时间如何选择，以及最多执行多少次重传，就是TCP的重传策略。其实跟TCP超时重连的策略相似，在5次重传均失败的情况下，底层的IP和ARP开始接管，直到客户端放弃连接为止。</p>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++A星寻路的实现</title>
    <link href="/2021/02/07/00002.%20C++A%E6%98%9F%E5%AF%BB%E8%B7%AF%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/02/07/00002.%20C++A%E6%98%9F%E5%AF%BB%E8%B7%AF%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><blockquote><p><strong>本篇文章为笔者的读书笔记，未经允许请勿转载。</strong><br />本文主要讲的A星寻路的代码实现，对A星寻路有一定的了解后再来阅读本文是个不错的选择。本文还用到了图形库，编译器为vs2019。图形库没有的可以去官方网站下载，步骤很简单下载直接安装即可。A星寻路的流程 1.准备存储的路径和终点标志位。 2.将起点放入closeList3.将起点周围的格子放入openlist 4.寻找最小和值F和终点5.找到后将它存入closelist同时将它从openlist中剔除6.从终点标志位开始往父亲节点遍历，存入路径中。 7.输出路径。剩下的解释全在代码注释中。--------------------------------------------------------</p></blockquote><h1 id="main.cpp">main.cpp</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;easyx.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;AStart.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;Level.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;Draw.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LevelMap</span>:<span class="hljs-keyword">public</span> Level<br>&#123;<br><span class="hljs-keyword">public</span>:<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; level;<br><span class="hljs-comment">// 通过 Level 继承</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(Pos v)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> !((v.x&lt;<span class="hljs-number">0</span>||v.y&lt;<span class="hljs-number">0</span>)||<br>v.x&gt; level[v.x].<span class="hljs-built_in">size</span>()||v.y&gt; level.<span class="hljs-built_in">size</span>()||<br>level[v.y][v.x]==<span class="hljs-number">1</span>);<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector &lt; vector&lt;<span class="hljs-type">int</span>&gt;&gt; vec = &#123;<span class="hljs-comment">//15*15</span><br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,<span class="hljs-comment">//▶x </span><br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,<br><span class="hljs-comment">//▼y</span><br>&#125;;<br>LevelMap lm;<br>lm.level = vec;<br><span class="hljs-function">AStart <span class="hljs-title">a</span><span class="hljs-params">(lm)</span></span>;<br><span class="hljs-function">Draw <span class="hljs-title">draw</span><span class="hljs-params">(<span class="hljs-number">600</span>, vec)</span></span>;<br>draw.<span class="hljs-built_in">update</span>();<br>list&lt;Pos&gt; path;<br>Pos start&#123; <span class="hljs-number">-1</span>,<span class="hljs-number">-1</span> &#125;;<br>Pos end&#123; <span class="hljs-number">-1</span>,<span class="hljs-number">-1</span> &#125;;<br><span class="hljs-type">int</span> x;<span class="hljs-comment">//从鼠标的位置转换到</span><br><span class="hljs-type">int</span> y;<span class="hljs-comment">//贴图需要更改的位置</span><br><span class="hljs-type">bool</span> flag=<span class="hljs-literal">false</span>;<span class="hljs-comment">//起点和终点的标志位</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>&#123;<br>draw.level = lm.level;<br>draw.<span class="hljs-built_in">update</span>();<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>&#123;<br>MOUSEMSG msg = <span class="hljs-built_in">GetMouseMsg</span>();<br>x = msg.x / draw.<span class="hljs-built_in">getSize</span>();<br>y = msg.y / draw.<span class="hljs-built_in">getSize</span>();<br><span class="hljs-keyword">if</span> (msg.uMsg == WM_RBUTTONDOWN)<span class="hljs-comment">//右键按下，路变墙，墙变路。</span><br>&#123;<br>lm.level[y][x] = draw.level[y][x] =<br>draw.level[y][x] == Draw::road ? Draw::wall : Draw::road;<br>draw.<span class="hljs-built_in">update</span>();<br>&#125;<br><span class="hljs-keyword">if</span> (msg.uMsg == WM_LBUTTONDOWN)<span class="hljs-comment">//左键按下设置起点终点准备寻路。</span><br>&#123;<span class="hljs-comment">//这里不能将lm.level改变，需要还原用。</span><br><span class="hljs-keyword">if</span> (!flag &amp;&amp; draw.level[y][x] == Draw::road)<br>&#123;<br>start.x = x;<br>start.y = y;<br>draw.level[y][x] = Draw::visit;<br>flag = <span class="hljs-literal">true</span>;<br>draw.<span class="hljs-built_in">update</span>();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (draw.level[y][x] == Draw::road)<br>&#123;<br>end.x = x;<br>end.y = y;<br>draw.level[y][x] = Draw::end;<br>path = a.<span class="hljs-built_in">find</span>(start, end);<br>flag = <span class="hljs-literal">false</span>;<br>draw.<span class="hljs-built_in">update</span>();<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; e : path)<br>&#123;<br>draw.level[e.y][e.x] = Draw::visit;<br>draw.<span class="hljs-built_in">update</span>();<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="level.h">Level.h</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pos</span><br>&#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-type">int</span> y;<br><span class="hljs-built_in">Pos</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>):<span class="hljs-built_in">x</span>(x),<span class="hljs-built_in">y</span>(y)&#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Level</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//外部规则</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(Pos v)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h1 id="draw.h">Draw.h</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">//取别名</span><br><span class="hljs-keyword">using</span> Vec2r = std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;;<br><br><span class="hljs-comment">//绘制地图的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Draw</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">/*使用图形库的接口实现地图绘制</span><br><span class="hljs-comment">   *length  屏幕长度</span><br><span class="hljs-comment">    level   地图关卡</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-built_in">Draw</span>(<span class="hljs-type">int</span> length, Vec2r&amp; level);<br>  ~<span class="hljs-built_in">Draw</span>();<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  0 路</span><br><span class="hljs-comment">  1 墙</span><br><span class="hljs-comment">  2 走过的路径</span><br><span class="hljs-comment">  3 终点</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">enum</span> &#123;<br>road=<span class="hljs-number">0</span>,<br>wall,<br>visit,<br>end,<br>  &#125;; <br>  Vec2r level;   <span class="hljs-comment">//绘制的地图上</span><br><br>  <span class="hljs-comment">//地图更新函数</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-comment">//获取瓦片大小</span><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">protected</span>:<br><br>  <span class="hljs-type">int</span> length;    <span class="hljs-comment">//宽度和高度</span><br>  <span class="hljs-type">int</span> size;    <span class="hljs-comment">//每个瓦片的大小</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;              <span class="hljs-comment">//绘制地图</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">text</span><span class="hljs-params">()</span></span>;              <span class="hljs-comment">//绘制文本</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rect</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>;   <span class="hljs-comment">//绘制瓦片</span><br><br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="draw.cpp">Draw.cpp</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Draw.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;easyx.h&gt;</span><span class="hljs-comment">//图形库文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>Draw::<span class="hljs-built_in">Draw</span>(<span class="hljs-type">int</span> length, Vec2r&amp; level)<br>  :<span class="hljs-built_in">length</span>(length)<br>&#123;<br>  <span class="hljs-built_in">initgraph</span>(length, length, EW_SHOWCONSOLE);<span class="hljs-comment">//初始化图形库,EW_SHOWCONSOLE表示显示控制台</span><br>  size = length / level.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//动态计算小方块的宽度</span><br>  <span class="hljs-keyword">this</span>-&gt;level=level;<span class="hljs-comment">//从外部传入地图</span><br>&#125;<br><br>Draw::~<span class="hljs-built_in">Draw</span>()<br>&#123;<br>  <span class="hljs-built_in">closegraph</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Draw::update</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">draw</span>();<br>  <span class="hljs-built_in">text</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Draw::getSize</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> size;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Draw::draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">BeginBatchDraw</span>();<span class="hljs-comment">//开始批量画图</span><br>  <span class="hljs-built_in">cleardevice</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; level.<span class="hljs-built_in">size</span>(); i++)<span class="hljs-comment">//level.size()等于7，</span><br>  &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; level[i].<span class="hljs-built_in">size</span>(); j++)<span class="hljs-comment">//level[i].size()等于7,这里不懂是因为二维vector没理解透。</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (level[i][j] == road)<span class="hljs-comment">//路</span><br>  &#123;<br><span class="hljs-built_in">setfillcolor</span>(<span class="hljs-built_in">RGB</span>(<span class="hljs-number">0xdd</span>, <span class="hljs-number">0xdd</span>, <span class="hljs-number">0xdd</span>)); <span class="hljs-comment">//设置路的颜色</span><br>  &#125;<br>  <span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span> (level[i][j] == wall)&#123;  <span class="hljs-comment">//墙</span><br><span class="hljs-built_in">setfillcolor</span>(<span class="hljs-built_in">RGB</span>(<span class="hljs-number">0x33</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0xcc</span>));<br>  &#125;<br>  <span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span> (level[i][j] == visit) &#123;  <span class="hljs-comment">//走过的路</span><br><span class="hljs-built_in">setfillcolor</span>(<span class="hljs-built_in">RGB</span>(<span class="hljs-number">0x33</span>, <span class="hljs-number">0xcc</span>, <span class="hljs-number">0x33</span>));<br>  &#125;<br>  <span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span> (level[i][j] == end) &#123;  <span class="hljs-comment">//终点</span><br><span class="hljs-built_in">setfillcolor</span>(<span class="hljs-built_in">RGB</span>(<span class="hljs-number">0xff</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0x33</span>));<br>  &#125;<br>  <span class="hljs-built_in">rect</span>(j, i);<span class="hljs-comment">//绘制瓦片，j代表x  i代表y.</span><br>&#125;<br>  &#125;<br>  <span class="hljs-built_in">EndBatchDraw</span>();<span class="hljs-comment">//结束批量画图</span><br>&#125;<br><span class="hljs-comment">//绘制瓦片</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Draw::rect</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">fillrectangle</span>(x * size, y * size, (x + <span class="hljs-number">1</span>) * size, (y + <span class="hljs-number">1</span>) * size);<br><span class="hljs-comment">/*void fillrectangle(</span><br><span class="hljs-comment">int left,</span><br><span class="hljs-comment">int top,</span><br><span class="hljs-comment">int right,</span><br><span class="hljs-comment">int bottom</span><br><span class="hljs-comment">);*/</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Draw::text</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  string m;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; level.<span class="hljs-built_in">size</span>(); i++)<br>  &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; level[i].<span class="hljs-built_in">size</span>(); j++)<br>&#123;<br>  <span class="hljs-keyword">if</span> (level[i][j] == road)<span class="hljs-comment">//路</span><br>  &#123;<br>m += <span class="hljs-string">&quot;  &quot;</span>; <span class="hljs-comment">//设置路的颜色</span><br>  &#125; <br>  <span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span> (level[i][j] == wall) <br>  &#123;  <span class="hljs-comment">//墙</span><br>m += <span class="hljs-string">&quot;+ &quot;</span>;<br>  &#125; <br>  <span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span> (level[i][j] == visit) <br>  &#123;  <span class="hljs-comment">//走过的路</span><br>m += <span class="hljs-string">&quot;. &quot;</span>;<br>  &#125; <br>  <span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span> (level[i][j] == end) <br>  &#123;  <span class="hljs-comment">//终点</span><br>m += <span class="hljs-string">&quot;= &quot;</span>;<br>  &#125;<br>&#125;<br>m += <span class="hljs-string">&quot;\n&quot;</span>;<br>  &#125;<br>  <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;cls&quot;</span>);  <span class="hljs-comment">//调用命令清屏</span><br>  cout &lt;&lt; m &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="astart.h">Astart.h</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Level.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>Pos v;<span class="hljs-comment">//节点坐标</span><br><span class="hljs-type">int</span> G;<span class="hljs-comment">//从起点到当前位置的代价；</span><br><span class="hljs-type">int</span> H;<span class="hljs-comment">//从当前位置到终点的预估代价；</span><br>Node* pre;<span class="hljs-comment">//树的父亲节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getF</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> G + H; &#125;<span class="hljs-comment">//代价和值</span><br><span class="hljs-built_in">Node</span>(Pos v, <span class="hljs-type">int</span> G, <span class="hljs-type">int</span> H, Node* pre = <span class="hljs-literal">nullptr</span>) :<span class="hljs-built_in">v</span>(v), <span class="hljs-built_in">G</span>(G), <span class="hljs-built_in">H</span>(H), <span class="hljs-built_in">pre</span>(pre) &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AStart</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">AStart</span>(Level&amp; level) :<span class="hljs-built_in">level</span>(level) &#123;&#125;<span class="hljs-comment">//多态不能用基类实例化对象这里的引用不能掉</span><br><span class="hljs-function">std::list&lt;Pos&gt; <span class="hljs-title">find</span><span class="hljs-params">(Pos start, Pos end)</span></span>;<br><span class="hljs-keyword">private</span>:<br>Level&amp; level;<span class="hljs-comment">//多态</span><br>Pos end;<span class="hljs-comment">//保存终点坐标</span><br>std::list&lt;Node*&gt; openLsit;<span class="hljs-comment">//准备要走的路但是没有走；</span><br>std::list&lt;Node*&gt; closeList;<span class="hljs-comment">//走过的路，正在走的路；</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addRound</span><span class="hljs-params">(Node* now)</span></span>;<span class="hljs-comment">//将节点周围的节点加入openlist</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getH</span><span class="hljs-params">(Pos now)</span></span>;<span class="hljs-comment">//获取节点位置与终点的预估距离</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(Pos v)</span></span>;<span class="hljs-comment">//检查该坐标能不能加入openlist</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findList</span><span class="hljs-params">(Pos v)</span></span>;<span class="hljs-comment">//检查该坐标是否在openlist或者closelist中</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//释放内存。</span><br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="astart.cpp">Astart.cpp</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;AStart.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-function">std::list&lt;Pos&gt; <span class="hljs-title">AStart::find</span><span class="hljs-params">(Pos start, Pos end)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;end = end;<br>    std::list&lt;Pos&gt; path;<br>    closeList.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(start, <span class="hljs-number">0</span>, <span class="hljs-built_in">getH</span>(start)));<br>    Node* endNode = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//终点到达标志位,同时为遍历父亲节点做准备</span><br>    <br>    <span class="hljs-type">size_t</span> length = <span class="hljs-number">0</span>;<span class="hljs-comment">//做循环的判断条件用的</span><br>    <span class="hljs-keyword">while</span> (length &lt; closeList.<span class="hljs-built_in">size</span>()&amp;&amp;!endNode)<br>    &#123;<br>        length = closeList.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">addRound</span>(closeList.<span class="hljs-built_in">back</span>());<br>        <br>        <span class="hljs-comment">//找到openList里面和值最小的node</span><br>        <span class="hljs-keyword">auto</span> it = openLsit.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">//默认最小的是openList的第一个元素，如果找到了就将其替换。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = openLsit.<span class="hljs-built_in">begin</span>(); i != openLsit.<span class="hljs-built_in">end</span>(); i++)<br>        &#123;<br>            <span class="hljs-comment">//判断是否到达终点</span><br>            <span class="hljs-keyword">if</span> ((*i)-&gt;v.x == end.x &amp;&amp; (*i)-&gt;v.y == end.y)<br>            &#123;<br>                endNode=*i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">//找到最小的和值F</span><br>            <span class="hljs-keyword">if</span> ((*it)-&gt;<span class="hljs-built_in">getF</span>() &gt; (*i)-&gt;<span class="hljs-built_in">getF</span>())<br>            &#123;<br>                it = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//将找到的最小和值F的节点放入closeList中,同时需要将此节点从openlist中剔除；</span><br>        <span class="hljs-keyword">if</span> (it != openLsit.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            closeList.<span class="hljs-built_in">push_back</span>((*it));<br>            openLsit.<span class="hljs-built_in">erase</span>(it);<br>        &#125;<br>        <span class="hljs-comment">//break后将路径从终点往父亲节点遍历，逐个插入到path的头部，实现正序输出。</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (endNode)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (endNode)<br>        &#123;<br>            path.<span class="hljs-built_in">push_front</span>(endNode-&gt;v);<br>            endNode = endNode-&gt;pre;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//最后内存的清理</span><br>    <span class="hljs-built_in">destory</span>();<br>    <span class="hljs-keyword">return</span> path;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">AStart::getH</span><span class="hljs-params">(Pos now)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">abs</span>(now.x-end.x)+std::<span class="hljs-built_in">abs</span>(now.y-end.y);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">AStart::check</span><span class="hljs-params">(Pos v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (level.<span class="hljs-built_in">isValid</span>(v) &amp;&amp; !<span class="hljs-built_in">findList</span>(v))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">AStart::findList</span><span class="hljs-params">(Pos v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; e : openLsit)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (e-&gt;v.x == v.x &amp;&amp; e-&gt;v.y == v.y)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; e : closeList)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (e-&gt;v.x == v.x &amp;&amp; e-&gt;v.y == v.y)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AStart::destory</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : openLsit)<br>        <span class="hljs-keyword">delete</span> e;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : closeList)<br>        <span class="hljs-keyword">delete</span> e;<br>    openLsit.<span class="hljs-built_in">clear</span>();<br>    closeList.<span class="hljs-built_in">clear</span>();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AStart::addRound</span><span class="hljs-params">(Node* now)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> Pos dir[]<span class="hljs-comment">//使用花括号直接初始化不能有强转否则会报错</span><br>    &#123;<br>        &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<span class="hljs-comment">//下</span><br>        &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,<span class="hljs-comment">//右</span><br>        &#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,<span class="hljs-comment">//上</span><br>        &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;<span class="hljs-comment">//左</span><br>    &#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : dir)<br>    &#123;<br>        e = &#123; now-&gt;v.x + e.x,now-&gt;v.y + e.y &#125;;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(e))<br>        &#123;<br>            openLsit.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(e, now-&gt;G + <span class="hljs-number">1</span>, <span class="hljs-built_in">getH</span>(e), now));<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><h1 id="测试结果">测试结果</h1><p><img src="/img/00002/Astar.gif" alt="在这里插入图片描述" /> #最近有小伙伴需要这整个工程，来满足一下大家。 <ahref="https://download.csdn.net/download/Howl_1/86893463">A星寻路工程，vs2019，0积分下载</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++深度优先和广度优先的实现</title>
    <link href="/2021/01/27/00001.%20C++%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/01/27/00001.%20C++%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><blockquote><p><strong>本篇文章为笔者的读书笔记，未经允许请勿转载。</strong><br />本文主要讲的深度优先算法和广度优先算法的区别，其中深度优先有两种实现方式，一种是递归法，另一种是非递归（栈实现），而广度优先就是队列的实现；后面还会以图形表述栈实现和队列实现；且用到了图形库easyx；--------------------------------------------------------</p></blockquote><h1 id="源码如下">源码如下：</h1><h4 id="main.cpp">main.cpp</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;Draw.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;DFS.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;BFS.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;Search.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; map =<br>&#123;<br>    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>    &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>    &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,<br>    &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>    &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,<br>    &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>&#125;;<br><span class="hljs-comment">//检查数据的合法性</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//所走的路径不能越界，也不能走到地图为1的地方。</span><br>    <span class="hljs-keyword">if</span> ((y &lt; <span class="hljs-number">0</span> ||  x&lt;<span class="hljs-number">0</span>) || y &gt;= map.<span class="hljs-built_in">size</span>() ||x&gt;=map[y].<span class="hljs-built_in">size</span>() || map[y][x] == <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//测试图形库是否能正常运行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Draw <span class="hljs-title">draw</span><span class="hljs-params">(<span class="hljs-number">600</span>, map)</span></span>;<br>    draw.<span class="hljs-built_in">updata</span>();<br>&#125;<br><span class="hljs-comment">//深度优先算法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">DFS <span class="hljs-title">dfs</span><span class="hljs-params">(check)</span></span>;<br>    <span class="hljs-function">Draw <span class="hljs-title">draw</span><span class="hljs-params">(<span class="hljs-number">600</span>, map)</span></span>;<br>    Pos start&#123; <span class="hljs-number">0</span>,<span class="hljs-number">0</span> &#125;;<br>    Pos end&#123; <span class="hljs-number">1</span>,<span class="hljs-number">6</span> &#125;;<br>    draw.level[end.y][end.x] = Draw::end;<span class="hljs-comment">//设置终点位置</span><br>    draw.<span class="hljs-built_in">updata</span>();<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; path = dfs.<span class="hljs-built_in">recursive</span>(start,end);<span class="hljs-comment">//开始寻路，路径找完后用vector保存了</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; e : path)<br>    &#123;<br>        draw.level[e.y][e.x] = Draw::visit;<span class="hljs-comment">//路径设置为visit。注意x，y不要写反了</span><br>        draw.<span class="hljs-built_in">updata</span>();<br>        <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">500</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//广度优先算法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">BFS <span class="hljs-title">bfs</span><span class="hljs-params">(check)</span></span>;<br>    <span class="hljs-function">Draw <span class="hljs-title">draw</span><span class="hljs-params">(<span class="hljs-number">600</span>, map)</span></span>;<br>    Pos start&#123; <span class="hljs-number">1</span>,<span class="hljs-number">1</span> &#125;;<br>    Pos end&#123; <span class="hljs-number">3</span>,<span class="hljs-number">0</span> &#125;;<br>    draw.level[end.y][end.x] = Draw::end;<br>    draw.<span class="hljs-built_in">updata</span>();<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; path = bfs.<span class="hljs-built_in">queue</span>(start, end);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; e : path)<br>    &#123;<br>        draw.level[e.y][e.x] = Draw::visit;<br>        draw.<span class="hljs-built_in">updata</span>();<br>        <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">500</span>);<br>    &#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//test();</span><br>    <span class="hljs-comment">//test1();</span><br>    <span class="hljs-comment">//test2();</span><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="draw.h">Draw.h</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;easyx.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">//区别名</span><br><span class="hljs-keyword">using</span> vec2 = std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;;<br><span class="hljs-comment">//绘制地图的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Draw</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Draw</span>(<span class="hljs-type">int</span>&amp;&amp; length, vec2&amp; map) :<span class="hljs-built_in">length</span>(length)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;level = map;<br><span class="hljs-keyword">this</span>-&gt;size = length / level.<span class="hljs-built_in">size</span>();<br><span class="hljs-built_in">initgraph</span>(length, length, EW_SHOWCONSOLE);<br>&#125;<br>~<span class="hljs-built_in">Draw</span>()<br>&#123;<br><span class="hljs-built_in">closegraph</span>();<br>&#125;<br><span class="hljs-keyword">enum</span> &#123;<br>road=<span class="hljs-number">0</span>,<span class="hljs-comment">//空地</span><br>wall,<span class="hljs-comment">//墙</span><br>visit,<span class="hljs-comment">//走过的路</span><br>end,<span class="hljs-comment">//终点</span><br>&#125;;<br><span class="hljs-comment">//绘制的地图。</span><br>vec2 level;<br><span class="hljs-comment">//游戏更新</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updata</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">draw</span>();<br><span class="hljs-built_in">test</span>();<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> length;<span class="hljs-comment">//宽度和高度</span><br><span class="hljs-type">int</span> size;<span class="hljs-comment">//每个瓦片的大小</span><br><span class="hljs-comment">//绘制地图</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">BeginBatchDraw</span>();<span class="hljs-comment">//开始批量画图</span><br><span class="hljs-built_in">cleardevice</span>();<span class="hljs-comment">//把之前的先清除</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; level.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; level[i].<span class="hljs-built_in">size</span>(); j++)<br>&#123;<br><span class="hljs-keyword">if</span> (level[i][j] == road)<br>&#123;<br><span class="hljs-built_in">setfillcolor</span>(<span class="hljs-built_in">RGB</span>(<span class="hljs-number">0xdd</span>, <span class="hljs-number">0xdd</span>, <span class="hljs-number">0xdd</span>));<span class="hljs-comment">//设置路的颜色</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (level[i][j] == wall)<br>&#123;<br><span class="hljs-built_in">setfillcolor</span>(<span class="hljs-built_in">RGB</span>(<span class="hljs-number">0x33</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0xcc</span>));<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (level[i][j] == visit)<br>&#123;<br><span class="hljs-built_in">setfillcolor</span>(<span class="hljs-built_in">RGB</span>(<span class="hljs-number">0x33</span>, <span class="hljs-number">0xcc</span>, <span class="hljs-number">0x33</span>));<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (level[i][j] == end)<br>&#123;<br><span class="hljs-built_in">setfillcolor</span>(<span class="hljs-built_in">RGB</span>(<span class="hljs-number">0xff</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0x33</span>));<br>&#125;<br><span class="hljs-built_in">rect</span>(j, i);<span class="hljs-comment">//绘制瓦片，j代表x，i代表y。</span><br><span class="hljs-comment">/*（0，0）----------▷ x的正方向</span><br><span class="hljs-comment">      |</span><br><span class="hljs-comment">  |</span><br><span class="hljs-comment">  |</span><br><span class="hljs-comment">  |</span><br><span class="hljs-comment"> ▽ y的正方向</span><br><span class="hljs-comment">图形库窗口的坐标*/</span><br>&#125;  <br>&#125;<br><span class="hljs-built_in">EndBatchDraw</span>();<br>&#125; <br><span class="hljs-comment">//绘制文本</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;cls&quot;</span>);<span class="hljs-comment">//清屏</span><br>std::string str=<span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; level.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; level[i].<span class="hljs-built_in">size</span>(); j++)<br>&#123;<br><span class="hljs-keyword">if</span> (level[i][j] == road)<br>&#123;<br>str += <span class="hljs-string">&quot;  &quot;</span>;<span class="hljs-comment">//设置路的标识符</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (level[i][j] == wall)<br>&#123;<br>str += <span class="hljs-string">&quot;+ &quot;</span>;<span class="hljs-comment">//墙</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (level[i][j] == visit)<br>&#123;<br>str += <span class="hljs-string">&quot;. &quot;</span>;<span class="hljs-comment">//走过的路</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (level[i][j] == end)<br>&#123;<br>str += <span class="hljs-string">&quot;= &quot;</span>;<span class="hljs-comment">//终点</span><br>&#125;<br>&#125;<br>str += <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br>std::cout &lt;&lt; str &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-comment">//绘制瓦片</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rect</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">fillrectangle</span>(x * size, y * size, (x + <span class="hljs-number">1</span>) * size, (y + <span class="hljs-number">1</span>) * size);<br><span class="hljs-comment">/* void fillrectangle(</span><br><span class="hljs-comment">int left,</span><br><span class="hljs-comment">int top,</span><br><span class="hljs-comment">int right,</span><br><span class="hljs-comment">int bottom</span><br><span class="hljs-comment">); */</span><br><br>&#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="search.h">Search.h</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pos</span><br>&#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-type">int</span> y;<br><span class="hljs-built_in">Pos</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>, <span class="hljs-type">int</span> y=<span class="hljs-number">0</span>) :<span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Search</span><br>&#123;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-keyword">using</span> Function = std::function&lt;<span class="hljs-built_in">bool</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt;;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Search</span>(Function fn) :<span class="hljs-built_in">fn</span>(fn) &#123;&#125;<br><span class="hljs-keyword">protected</span>:<br><br><span class="hljs-comment">//通过函数适配器调用外部规则，对数据进行判断；</span><br>Function fn;<br><span class="hljs-comment">//创建一个vector保存路径</span><br>std::vector&lt;Pos&gt; path;<br><span class="hljs-comment">//判断这条路是否走过</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isVisited</span><span class="hljs-params">(Pos pos)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; e : path)<br>&#123;<br><span class="hljs-keyword">if</span> (pos.x == e.x &amp;&amp; pos.y == e.y)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">//判断下次移动是否合法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(Pos pos)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">fn</span>(pos.x, pos.y) &amp;&amp; !<span class="hljs-built_in">isVisited</span>(pos);<span class="hljs-comment">//fn调用外部规则check</span><br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="dfs.h">DFS.h</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Search.h&quot;</span></span><br><span class="hljs-comment">//深度优先算法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DFS</span> : <span class="hljs-keyword">public</span> Search<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">DFS</span>(std::function&lt;<span class="hljs-built_in">bool</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; fn):<span class="hljs-built_in">Search</span>(fn)<span class="hljs-comment">//构造子类的时候，需要初始化父类。</span><br>&#123;<br>    <br>&#125;<br><span class="hljs-comment">/*start 起点坐标</span><br><span class="hljs-comment">  end   终点坐标*/</span><br><span class="hljs-comment">//递归法</span><br><span class="hljs-function">std::vector&lt;Pos&gt; <span class="hljs-title">recursive</span><span class="hljs-params">(Pos start, Pos end)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;end = end;<br>    path.<span class="hljs-built_in">push_back</span>(start);<br>    _recursive(start);<br>    <span class="hljs-keyword">return</span> path;<br>&#125;<br><span class="hljs-comment">//非递归法（栈实现）</span><br><span class="hljs-function">std::vector&lt;Pos&gt; <span class="hljs-title">stack</span><span class="hljs-params">(Pos start, Pos end)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> Pos dir[<span class="hljs-number">4</span>] = &#123;<br>        &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<span class="hljs-comment">//y+1向下</span><br>        &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,<span class="hljs-comment">//x+1向右</span><br>        &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,<span class="hljs-comment">//x-1向左</span><br>        &#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,<span class="hljs-comment">//y-1向上</span><br>    &#125;;<br>    std::stack&lt;Pos&gt; st;<br>    st.<span class="hljs-built_in">push</span>(start);<br>    <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> now = st.<span class="hljs-built_in">top</span>();<br>        st.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        &#123;<br>            <span class="hljs-comment">//准备移动的路径</span><br>            <span class="hljs-function">Pos <span class="hljs-title">move</span><span class="hljs-params">(now.x + dir[i].x, now.y + dir[i].y)</span></span>;<br>            <span class="hljs-comment">//判断是否能移动</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(move))<br>            &#123;<br>                st.<span class="hljs-built_in">push</span>(move);<br>                path.<span class="hljs-built_in">push_back</span>(move);<br>                <span class="hljs-comment">//判断是否到达终点</span><br>                <span class="hljs-keyword">if</span> (move.x == end.x &amp;&amp; move.y == end.y)<br>                &#123;<br>                    <span class="hljs-keyword">return</span> path;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> path;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">bool</span> is_end=<span class="hljs-literal">false</span>;<span class="hljs-comment">//递归需要的标志位，默认位false</span><br>Pos end;  <span class="hljs-comment">//保存终点坐标</span><br><span class="hljs-type">void</span> _recursive(Pos now)<br>&#123;<br>    <span class="hljs-type">static</span> Pos dir[<span class="hljs-number">4</span>] = &#123;<br>        &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<span class="hljs-comment">//y+1向下</span><br>        &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,<span class="hljs-comment">//x+1向右</span><br>        &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,<span class="hljs-comment">//x-1向左</span><br>        &#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,<span class="hljs-comment">//y-1向上</span><br>    &#125;;<br>    <span class="hljs-comment">//判断是否到达终点</span><br>    <span class="hljs-keyword">if</span> (now.x == end.x &amp;&amp; now.y == end.y)<br>    &#123;<br>        is_end = <span class="hljs-literal">true</span>;<span class="hljs-comment">//找到终点标志位置1</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//循环遍历下右左上4个方向</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>    &#123;<br>        <span class="hljs-comment">//准备移动的路径</span><br>        <span class="hljs-function">Pos <span class="hljs-title">move</span><span class="hljs-params">(now.x + dir[i].x, now.y + dir[i].y)</span></span>;<br>        <span class="hljs-comment">//判断能否移动</span><br>            <span class="hljs-keyword">if</span> (!is_end &amp;&amp; <span class="hljs-built_in">isValid</span>(move))<br>            &#123;<br>                path.<span class="hljs-built_in">push_back</span>(move);<span class="hljs-comment">//保存走过的路径</span><br>                _recursive(move);<br>            &#125;<br>    &#125;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="bfs.h">BFS.h</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Search.h&quot;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BFS</span> :<span class="hljs-keyword">public</span> Search<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">BFS</span>(Function fn):<span class="hljs-built_in">Search</span>(fn)<br>&#123;<br>&#125;<br><span class="hljs-function">std::vector&lt;Pos&gt; <span class="hljs-title">queue</span><span class="hljs-params">(Pos start, Pos end)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> Pos dir[<span class="hljs-number">4</span>] = &#123;<br>       &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<span class="hljs-comment">//y+1向下</span><br>       &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,<span class="hljs-comment">//x+1向右</span><br>       &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,<span class="hljs-comment">//x-1向左</span><br>       &#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,<span class="hljs-comment">//y-1向上</span><br>    &#125;;<br>    std::queue&lt;Pos&gt; qu;<br>    qu.<span class="hljs-built_in">push</span>(start);<br>    <span class="hljs-keyword">while</span> (!qu.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> now = qu.<span class="hljs-built_in">front</span>();<br>        qu.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        &#123;<br>            <span class="hljs-function">Pos <span class="hljs-title">move</span><span class="hljs-params">(now.x + dir[i].x, now.y + dir[i].y)</span></span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(move))<br>            &#123;<br>                qu.<span class="hljs-built_in">push</span>(move);<br>                path.<span class="hljs-built_in">push_back</span>(move);<br>                <span class="hljs-keyword">if</span> (move.x == end.x &amp;&amp; move.y == end.y)<br>                &#123;<br>                    <span class="hljs-keyword">return</span> path;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> path;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="测试结果">测试结果</h1><blockquote><p><strong>递归实现：</strong> <img src="/img/00001/dfs.gif"alt="在这里插入图片描述" /></p></blockquote><blockquote><p><strong>深度优先（栈实现）：</strong> <imgsrc="/img/00001/bfs-stack.gif" alt="在这里插入图片描述" /></p></blockquote><blockquote><p><strong>广度优先（队列实现）</strong> <imgsrc="/img/00001/bfs-queue.gif" alt="在这里插入图片描述" /> #深度优先（栈实现）和广度优先（队列实现）图解 <strong>深度优先：</strong><img src="/img/00001/dfs.png" alt="在这里插入图片描述" /><strong>广度优先：</strong> <img src="/img/00001/bfs.png"alt="在这里插入图片描述" /></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
