<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Games202 Hw5</title>
    <link href="/2023/07/21/00020.%20Games202%20Hw5/"/>
    <url>/2023/07/21/00020.%20Games202%20Hw5/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Games202</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>c++对象模型之虚表，虚表指针，thunk，多态，多重继承this指针偏移，多重继承virtual析构函数，多重虚继承下的访问虚基类成员变量时虚表的工作原理</title>
    <link href="/2022/02/19/00006.%20c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B9%8B%E8%99%9A%E8%A1%A8%EF%BC%8C%E8%99%9A%E8%A1%A8%E6%8C%87%E9%92%88%E7%AD%89/"/>
    <url>/2022/02/19/00006.%20c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B9%8B%E8%99%9A%E8%A1%A8%EF%BC%8C%E8%99%9A%E8%A1%A8%E6%8C%87%E9%92%88%E7%AD%89/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p><strong>本篇文章为笔者的读书笔记，未经允许请勿转载。</strong><br>上两篇文章将c++的核心部件（<a href="https://en.cppreference.com/w/cpp/language/value_category">Value categories</a>）讲清楚了，这篇文章将会带大家分析c++对象模型的底层原理。笔者这里用的编译器是<code>clang version 10.0.0-4ubuntu1</code>，不同编译器对数据布局的处理可能会不同（《深度探索c++对象模型》中已阐述原因，感兴趣的读者可以自行阅读）。<br>友情提示：本文章涉及<code>ATT式</code>和<code>intel式</code>汇编代码的相关知识。</p></blockquote><hr><h1 id="虚表和虚表指针（vtbl-vptr）"><a href="#虚表和虚表指针（vtbl-vptr）" class="headerlink" title="虚表和虚表指针（vtbl &amp; vptr）"></a>虚表和虚表指针（vtbl &amp; vptr）</h1><blockquote><ul><li>每个class产生出一堆指向virtual function的指针，放在表格之中，这个表格被称为virtual table（vtbl）。</li><li>每一个class object被安插一个指针，指向相关的virtual table。通常这个指针被称为vptr。vptr的设定（setting）和重置（resetting）都由每一个class的constructor、destructor和copy assignment运算符自动完成。每一个class所关联的type_info object（用以支持runtime type identification，RTTI）也经由virtual table被指出来，通常放在表格的第一个slot（clang++不是放在第一个slot，文章后面会讲到）。</li></ul></blockquote><hr><blockquote><p>接下来笔者写两个测试用例来帮大家分析clang++编译器下的vtbl &amp; vptr。</p><h2 id="首先咱们来看下vptr放在对象的什么位置："><a href="#首先咱们来看下vptr放在对象的什么位置：" class="headerlink" title="首先咱们来看下vptr放在对象的什么位置："></a>首先咱们来看下vptr放在对象的什么位置：</h2></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">testfunc</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//虚函数表指针位置分析</span><br>    <span class="hljs-comment">//类：有虚函数，这个类会产生一个虚函数表。</span><br>    <span class="hljs-comment">//类对象，有一个指针，指针（vptr）会指向这个虚函数表的开始地址。</span><br>    A obj;<br>    <span class="hljs-type">int</span> objLen = <span class="hljs-built_in">sizeof</span>(obj);<br>    std::cout&lt;&lt; objLen &lt;&lt; std::endl; <span class="hljs-comment">//x86-64 16字节</span><br><br>    <span class="hljs-comment">/*p1获取对象首地址，p2获取对象数据成员i的地址，两者都以低层次char *去解释，以便用旁观者角度去比较*/</span><br>    <span class="hljs-type">char</span> *p1 = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span> *&gt;(&amp;obj);<span class="hljs-comment">//reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。</span><br>    <span class="hljs-type">char</span> *p2 = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span> *&gt;(&amp;(obj.i));<br>    <span class="hljs-keyword">if</span>(p1 == p2)<span class="hljs-comment">//说明obj.i和obj的位置相同，说明i在对象obj内存布局的上边。虚函数表指针vptr在下边</span><br>    &#123;<br>        std::cout&lt;&lt; <span class="hljs-string">&quot;虚函数表指针位于对象内存的 末尾 &quot;</span> &lt;&lt;std::endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        std::cout&lt;&lt; <span class="hljs-string">&quot;虚函数表指针位于对象内存的 开头 &quot;</span> &lt;&lt;std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>运行结果如下：<br><img src="/img%5C00006%5C1.png" alt="请添加图片描述"><br>可以看到 <code>obj </code>对象的大小是16字节，<code>vptr</code>位于对象的开头。</p></blockquote><hr><blockquote><h2 id="接下里咱们不走virtual机制，直接从虚表中获取虚函数并且运行对应虚函数。"><a href="#接下里咱们不走virtual机制，直接从虚表中获取虚函数并且运行对应虚函数。" class="headerlink" title="接下里咱们不走virtual机制，直接从虚表中获取虚函数并且运行对应虚函数。"></a>接下里咱们不走virtual机制，直接从虚表中获取虚函数并且运行对应虚函数。</h2></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Base::f()&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Base::g()&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Base::h()&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Derive::g()&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Derive* pd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<span class="hljs-comment">//派生类指针。</span><br>    <span class="hljs-type">long</span>* pd_cast = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span>*&gt;(pd);<span class="hljs-comment">//获取较低层次上的重新解释。</span><br>    <span class="hljs-type">long</span>* vptr_pd = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span>*&gt;(*pd_cast);<br>    <span class="hljs-comment">/*解引用派生类指针得到虚表指针，而不是得到派生类，因为做了位模式的低层次转换。</span><br><span class="hljs-comment">    得到虚表指针后，将虚表指针的类型从long重新解释为long*。</span><br><span class="hljs-comment">    使用long过渡，是因为long在32位编译器和64位编译器所占用的空间大小和指针是一样的*/</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;vptr_pd[%d] 的内容为： %p\n&quot;</span>,i,vptr_pd[i]);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*Func)</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<span class="hljs-comment">//定义一个函数指针类型</span><br>    Func f_pd = (Func)vptr_pd[<span class="hljs-number">0</span>];<br>    Func g_pd = (Func)vptr_pd[<span class="hljs-number">1</span>];<br>    Func h_pd = (Func)vptr_pd[<span class="hljs-number">2</span>];<br><br>    <span class="hljs-built_in">f_pd</span>();<br>    <span class="hljs-built_in">g_pd</span>();<br>    <span class="hljs-built_in">h_pd</span>();<br><br>    Base* pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Base</span>();<span class="hljs-comment">//派生类指针。</span><br>    <span class="hljs-type">long</span>* pb_cast = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span>*&gt;(pb);<br>    <span class="hljs-type">long</span>* vptr_pb = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span>*&gt;(*pb_cast);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;vptr_pb[%d] 的内容为： %p\n&quot;</span>,i,vptr_pb[i]);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*Func)</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<span class="hljs-comment">//定义一个函数指针类型</span><br>    Func f_pb = (Func)vptr_pb[<span class="hljs-number">0</span>];<br>    Func g_pb = (Func)vptr_pb[<span class="hljs-number">1</span>];<br>    Func h_pb = (Func)vptr_pb[<span class="hljs-number">2</span>];<br><br>    <span class="hljs-built_in">f_pb</span>();<br>    <span class="hljs-built_in">g_pb</span>();<br>    <span class="hljs-built_in">h_pb</span>();<br><br>    <span class="hljs-keyword">delete</span> pd;<br>    <span class="hljs-keyword">delete</span> pb;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>运行结果为：<br><img src="/img%5C00006%5C2.png" alt="请添加图片描述"><br>或者用GDB命令打印出vtbl的样子：<br><code>gef➤  info vtbl pd</code><br><img src="/img%5C00006%5C3.png" alt="请添加图片描述"><br>和上面代码运行的结果一致！值得关注的一点是，<code>vtbl</code>是存在于只读数据段，而<code>vptr</code>在堆中（<code>vptr</code>也可以在栈中）。<br>下面用一张图来描述上述代码的行为：<br><img src="/img%5C00006%5C4.png" alt="请添加图片描述"></p></blockquote><hr><blockquote><h2 id="vptr-vtbl的创建时机以及vptr初始化问题"><a href="#vptr-vtbl的创建时机以及vptr初始化问题" class="headerlink" title="vptr &amp; vtbl的创建时机以及vptr初始化问题"></a>vptr &amp; vtbl的创建时机以及vptr初始化问题</h2><p>引用《深度探索C++对象模型》p45中的一段话：<br>下面两个扩张行动会在编译期间发生：</p><ul><li>一个virtual function table会被编译器产生出来，内放class的virtual functions地址</li><li>在每一个class object中，一个额外的pointer member会被编译器合成出来，内含相关的class vtbl的地址</li></ul><p>在c++中，virtual functions可以在编译时期获知。此外，这一组地址是固定不变的，执行期不可能新增或替换它。由于程序执行时，表格的大小和内容都不会改变，所以其构建和存取皆可以由编译器完全掌握，不需要执行期的任何介入。<br>值得注意的是<code>vptr的初始化</code>问题：<br>这里笔者就不带大家画堆栈图，过程如下！<br>相关ATT式反汇编代码如下：</p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs apache">    <span class="hljs-attribute">Derive</span>* pd = new Derive();//派生类指针。<br>  <span class="hljs-attribute">401222</span>:bf <span class="hljs-number">08</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x8,%edi<br>  <span class="hljs-attribute">401227</span>:e8 <span class="hljs-number">64</span> fe ff ff       callq  <span class="hljs-number">401090</span> &lt;operator new(unsigned long)@plt&gt;<br>  <span class="hljs-attribute">40122c</span>:<span class="hljs-number">31</span> f6                xor    %esi,%esi<br>  <span class="hljs-attribute">40122e</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c1             mov    %rax,%rcx<br>  <span class="hljs-attribute">401231</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> cf             mov    %rcx,%rdi<br>  <span class="hljs-attribute">401234</span>:ba <span class="hljs-number">08</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x8,%edx<br>  <span class="hljs-attribute">401239</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">45</span> <span class="hljs-number">80</span>          mov    %rax,-<span class="hljs-number">0</span>x80(%rbp)<br>  <span class="hljs-attribute">40123d</span>:e8 <span class="hljs-number">0</span>e fe ff ff       callq  <span class="hljs-number">401050</span> &lt;memset@plt&gt;<br>  <span class="hljs-attribute">401242</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">7</span>d <span class="hljs-number">80</span>          mov    -<span class="hljs-number">0</span>x80(%rbp),%rdi<br>  <span class="hljs-attribute">401246</span>:e8 <span class="hljs-number">95</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">4013</span>e0 &lt;Derive::Derive()&gt;<br>  <span class="hljs-attribute">40124b</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> <span class="hljs-number">80</span>          mov    -<span class="hljs-number">0</span>x80(%rbp),%rax<br>  <span class="hljs-attribute">40124f</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">45</span> f0          mov    %rax,-<span class="hljs-number">0</span>x10(%rbp)<br>  <br>  <span class="hljs-attribute">00000000004013e0</span> &lt;Derive::Derive()&gt;:<br><span class="hljs-attribute">class</span> Derive : public Base<br>  <span class="hljs-attribute">4013e0</span>:<span class="hljs-number">55</span>                   push   %rbp<br>  <span class="hljs-attribute">4013e1</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> e5             mov    %rsp,%rbp<br>  <span class="hljs-attribute">4013e4</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">10</span>          sub    $<span class="hljs-number">0</span>x10,%rsp<br>  <span class="hljs-attribute">4013e8</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">7</span>d f8          mov    %rdi,-<span class="hljs-number">0</span>x8(%rbp)<br>  <span class="hljs-attribute">4013ec</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> f8          mov    -<span class="hljs-number">0</span>x8(%rbp),%rax<br>  <span class="hljs-attribute">4013f0</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c1             mov    %rax,%rcx<br>  <span class="hljs-attribute">4013f3</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> cf             mov    %rcx,%rdi<br>  <span class="hljs-attribute">4013f6</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">45</span> f0          mov    %rax,-<span class="hljs-number">0</span>x10(%rbp)<br>  <span class="hljs-attribute">4013fa</span>:e8 <span class="hljs-number">21</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">401420</span> &lt;Base::Base()&gt;<br>  <span class="hljs-attribute">4013ff</span>:<span class="hljs-number">48</span> b8 <span class="hljs-number">70</span> <span class="hljs-number">20</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> movabs $<span class="hljs-number">0</span>x402070,%rax<br>  <span class="hljs-attribute">401406</span>:<span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br>  <span class="hljs-attribute">401409</span>:<span class="hljs-number">48</span> <span class="hljs-number">05</span> <span class="hljs-number">10</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    add    $<span class="hljs-number">0</span>x10,%rax<br>  <span class="hljs-attribute">40140f</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">4</span>d f0          mov    -<span class="hljs-number">0</span>x10(%rbp),%rcx<br>  <span class="hljs-attribute">401413</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">01</span>             mov    %rax,(%rcx)<br>  <span class="hljs-attribute">401416</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">10</span>          add    $<span class="hljs-number">0</span>x10,%rsp<br>  <span class="hljs-attribute">40141a</span>:<span class="hljs-number">5</span>d                   pop    %rbp<br>  <span class="hljs-attribute">40141b</span>:c3                   retq   <br>  <span class="hljs-attribute">40141c</span>:<span class="hljs-number">0</span>f <span class="hljs-number">1</span>f <span class="hljs-number">40</span> <span class="hljs-number">00</span>          nopl   <span class="hljs-number">0</span>x0(%rax)<br><br><span class="hljs-attribute">0000000000401420</span> &lt;Base::Base()&gt;:<br><span class="hljs-attribute">class</span> Base<br>  <span class="hljs-attribute">401420</span>:<span class="hljs-number">55</span>                   push   %rbp<br>  <span class="hljs-attribute">401421</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> e5             mov    %rsp,%rbp<br>  <span class="hljs-attribute">401424</span>:<span class="hljs-number">48</span> b8 d0 <span class="hljs-number">20</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> movabs $<span class="hljs-number">0</span>x4020d0,%rax<br>  <span class="hljs-attribute">40142b</span>:<span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br>  <span class="hljs-attribute">40142e</span>:<span class="hljs-number">48</span> <span class="hljs-number">05</span> <span class="hljs-number">10</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    add    $<span class="hljs-number">0</span>x10,%rax<br>  <span class="hljs-attribute">401434</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">7</span>d f8          mov    %rdi,-<span class="hljs-number">0</span>x8(%rbp)<br>  <span class="hljs-attribute">401438</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">4</span>d f8          mov    -<span class="hljs-number">0</span>x8(%rbp),%rcx<br>  <span class="hljs-attribute">40143c</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">01</span>             mov    %rax,(%rcx)<br>  <span class="hljs-attribute">40143f</span>:<span class="hljs-number">5</span>d                   pop    %rbp<br>  <span class="hljs-attribute">401440</span>:c3                   retq   <br>  <span class="hljs-attribute">401441</span>:<span class="hljs-number">66</span> <span class="hljs-number">2</span>e <span class="hljs-number">0</span>f <span class="hljs-number">1</span>f <span class="hljs-number">84</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> nopw   %cs:<span class="hljs-number">0</span>x0(%rax,%rax,<span class="hljs-number">1</span>)<br>  <span class="hljs-attribute">401448</span>:<span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br>  <span class="hljs-attribute">40144b</span>:<span class="hljs-number">0</span>f <span class="hljs-number">1</span>f <span class="hljs-number">44</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       nopl   <span class="hljs-number">0</span>x0(%rax,%rax,<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><hr><blockquote><p><img src="/img%5C00006%5C5.png" alt="请添加图片描述"><br>该图对应<code>mov    %rax,-0x80(%rbp)</code>执行完。已经发生的事情有：new表达式通过<code>operator new(unsigned long)</code>这个动态函数申请了首地址为<code>0x0000000000416eb0</code>的堆内存，并将其赋给了栈空间为<code>rbp-0x80（0x00007fffffffe060）</code>的地址中，下一条反汇编代码将会为首地址为<code>0x0000000000416eb0</code>的堆内存进行内存初始化。<br>（延迟绑定:动态函数比静态函数绑定要晚静态函数在<code>a.out</code>生成的时候地址已经被绑定<br>动态函数需要动态库加载到内存中，然后用动态库里面的函数地址替换掉类似于反汇编出来的<code>@plt</code>，之后得到动态函数的地址进行调用。）</p></blockquote><hr><blockquote><p><img src="/img%5C00006%5C6.png" alt="请添加图片描述"><br>该图对应<code>0x40143c &lt;Base::Base()+28&gt; mov    QWORD PTR [rcx], rax</code>执行完。已经发生的事情有：调用了<code>Derive合成默认构造函数</code>，并且在其中又调用了<code>Base合成默认构造函数</code>，首地址为<code>0x0000000000416eb0</code>的堆内存指针赋给了第一参数寄存器<code>rdi</code>，<code>0x4020d0立即数</code>（Base虚表地址）赋给了临时寄存器<code>rax</code>，<code>rdi</code>寄存器又将堆内存指针赋给了Base合成默认构造函数的<code>rbp-0x8</code>地址上，最后由<code>rax</code>寄存器将Base虚表地址赋给了堆内存指针所指向的地址中。至此new出来的Derive类对象的<code>vptr</code>已经获取到Base类的虚表地址（注意现在还没有获取到Derive类的虚表地址）。</p></blockquote><hr><blockquote><p><img src="/img%5C00006%5C7.png" alt="请添加图片描述"><br>该图对应<code>0x401413 &lt;Derive::Derive()+51&gt; mov    QWORD PTR [rcx], rax</code>执行完。已经发生的事情有：<code>Base的合成默认构造函数</code>已<code>return</code>，接着<code>0x402070立即数</code>赋给了<code>rax</code>寄存器，<code>rax</code>将其值加上<code>0x10</code>后就得到了Derive类的虚表地址。然后<code>rax</code>将该地址赋给了堆内存指针所指向的地址中。至此伴随着<code>Derive合成默认构造函数</code>的结束，new出来的Derive类对象的<code>vptr</code>获得了自己的虚表地址。</p></blockquote><hr><h3 id="vptr初始化小结"><a href="#vptr初始化小结" class="headerlink" title="vptr初始化小结"></a>vptr初始化小结</h3><blockquote><p>可以发现，<code>vptr的初始化</code>并不是一开始就获得了自己的虚表地址，而是伴随父类合成默认构造函数的结束，先获得父类虚表地址，然后伴随自身合成默认构造函数的结束，再获得自身虚表地址。</p></blockquote><hr><h2 id="编译器会合成出nontrivial-default-constructor的4种情况（《深度探索c-对象模型》p40）"><a href="#编译器会合成出nontrivial-default-constructor的4种情况（《深度探索c-对象模型》p40）" class="headerlink" title="编译器会合成出nontrivial default constructor的4种情况（《深度探索c++对象模型》p40）"></a>编译器会合成出nontrivial default constructor的4种情况（《深度探索c++对象模型》p40）</h2><blockquote><ul><li>带有default constructor的member class object</li></ul><p>如果一个class没有任何constructor，但它内含一个member object，而后者有default constructor，那么这个class的implicit default constructor就是nontrivial，编译器需要为该class合成出一个default constructor。</p><ul><li>带有default constructor的base class</li></ul><p>如果一个没有任何constructor的class派生自一个带有default constructor的base class，那么这个derived class的default constructor会被视为nontrivial，并因此需要被合成出来。它将调用上一层base classes的default constructor（根据它们的声明顺序）。</p><ul><li>带有一个virtual function的class</li></ul><p>对于那些未声明任何constructor的classes，编译器会为它们合成一个default constructor，以便正确地初始化每一个class object的vptr。</p><ul><li>带有一个virtual base class的class</li></ul><p>Virtual base class 的实现方法在不同编译器之间有极大的差异。然而，每一种实现方法的共同点在于必须使virtual base class在其每一个derived class object中的位置，能够于执行期准备妥当。在未声明任何constructor的derived class object中，编译器必须为它合成一个default constructor，并安插那些“允许每一个virtual base class的执行期存取操作”的代码。</p></blockquote><hr><h1 id="多重继承下的virtual-function，thunk，以及编译期绑定和运行期绑定（动态绑定）"><a href="#多重继承下的virtual-function，thunk，以及编译期绑定和运行期绑定（动态绑定）" class="headerlink" title="多重继承下的virtual function，thunk，以及编译期绑定和运行期绑定（动态绑定）"></a>多重继承下的virtual function，thunk，以及编译期绑定和运行期绑定（动态绑定）</h1><blockquote><p>在多重继承中支持virtual function，其复杂度围绕在第二个以及后继的base classes身上，以及“必须在执行期调整this指针”这一点，以下面的class体系为例：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;base1::f()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;base1::g()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//基类2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;base2::h()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">i</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;base2::i()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>:<span class="hljs-keyword">public</span> Base1,<span class="hljs-keyword">public</span> Base2<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span><span class="hljs-comment">//覆盖父类1的虚函数</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;derived::f()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">i</span><span class="hljs-params">()</span><span class="hljs-comment">//覆盖父类2的虚函数</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;derived::i()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">//我们自己的虚函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">myFunc1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;derived::myFunc1()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-comment">//非虚函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunc2</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;derived::myFunc2()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Base1) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Base2) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Derived) &lt;&lt; std::endl;<br><br>    Derived ins;<br>    Base1&amp; b1 = ins;<span class="hljs-comment">//为了支持多态《深度探索c++对象模型p25》</span><br>    Base2&amp; b2 = ins;<br>    Derived&amp; d = ins;<br><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*Func)</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br>    <span class="hljs-comment">/*获得Base1类的第虚表指针*/</span><br>    Base1 temp1;<br>    <span class="hljs-type">long</span>* base1_cast = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span>*&gt;(&amp;temp1);<span class="hljs-comment">//重新解释类对象,获得虚表指针的地址。</span><br>    <span class="hljs-type">long</span>* base1_vptr = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span>*&gt;(*base1_cast);<span class="hljs-comment">//虚表指针的类型从long重新解释为long*。让它体现出指针的性质而不是long数值</span><br>    <span class="hljs-comment">//打印虚函数地址</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;base1_vptr[%d] 的内容为： %p\n&quot;</span>,i,base1_vptr[i]);<br>        ((Func)base1_vptr[i])();<br>    &#125;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;----------------------------&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">/*获得Base2类的第虚表指针*/</span><br>    Base2 temp2;<br>    <span class="hljs-type">long</span>* base2_cast = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span>*&gt;(&amp;temp2);<span class="hljs-comment">//重新解释类对象,获得第虚表指针的地址。</span><br>    <span class="hljs-type">long</span>* base2_vptr = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span>*&gt;(*base2_cast);<span class="hljs-comment">//虚表指针的类型从long重新解释为long*。让它体现出指针的性质而不是long数值</span><br>    <span class="hljs-comment">//打印虚函数地址</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;base2_vptr[%d] 的内容为： %p\n&quot;</span>,i,base2_vptr[i]);<br>        ((Func)base2_vptr[i])();<br>    &#125;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;----------------------------&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">/*获得derived类的第一个虚表指针*/</span><br>    <span class="hljs-type">long</span>* ins_cast1 = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span>*&gt;(&amp;ins);<span class="hljs-comment">//重新解释类对象,获得第一个虚表指针的地址。</span><br>    <span class="hljs-type">long</span>* vptr1 = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span>*&gt;(*ins_cast1);<span class="hljs-comment">//虚表指针的类型从long重新解释为long*。让它体现出指针的性质而不是long数值</span><br>    <span class="hljs-comment">//打印虚函数地址</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;vptr1[%d] 的内容为： %p\n&quot;</span>,i,vptr1[i]);<br>        ((Func)vptr1[i])();<br>    &#125;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;----------------------------&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">/*获得derived类的第二个虚表指针*/</span><br>    <span class="hljs-type">long</span>* ins_cast2 = ins_cast1 + <span class="hljs-number">1</span>;<span class="hljs-comment">//偏移到第二个虚表指针的地址上</span><br>    <span class="hljs-type">long</span>* vptr2 = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span>*&gt;(*ins_cast2);<span class="hljs-comment">//虚表指针的类型从long重新解释为long*。让它体现出指针的性质而不是long数值</span><br>    <span class="hljs-comment">//打印虚函数地址</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;vptr2[%d] 的内容为： %p\n&quot;</span>,i,vptr2[i]);<br>        ((Func)vptr2[i])();<br>    &#125;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;----------------------------&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">//动态绑定</span><br>    b1.<span class="hljs-built_in">f</span>();<br>    b2.<span class="hljs-built_in">i</span>();<br>    d.<span class="hljs-built_in">f</span>();<br>    d.<span class="hljs-built_in">i</span>();<br>    d.<span class="hljs-built_in">g</span>();<br>    d.<span class="hljs-built_in">myFunc1</span>();<br>    <span class="hljs-comment">//编译期绑定</span><br>    d.<span class="hljs-built_in">myFunc2</span>();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在这个例子中，我们的子类会有两个虚指针，两张虚表，第一张虚表是重写父类虚函数、自身虚函数以及base1虚函数共享的虚表，第二张则是针对base2的。下面来看下运行结果：<br><img src="/img%5C00006%5C8.png" alt="请添加图片描述"><br>重写的父类虚函数：<code>f()</code>，<code>i()</code>、自身虚函数：<code>myFunc1()</code>、base1虚函数：<code>g()</code>都在第一张虚表。而第二张虚表中，<code>h()</code>的出现很正常，但是这个被重写的父类虚函数<code>i()</code>，为什么会再次出现呢？，不应该只在表一出现吗？<br>这里表二中被重写的父类虚函数<code>i()</code>，其真名叫<code>nonvirtual thunk</code>函数。<br>咱们用指令来更清晰的观察Derived类对象ins的两张虚表：<br>（注意： 必须在支持多态的情况下观察Derived类对象ins，具体原因请参考《深度探索c++对象模型》p13）<br><img src="/img%5C00006%5C9.png" alt="请添加图片描述"><br>上文说过“必须在执行期调整this指针”，而thunk函数的真正目的为：</p><ul><li>以适当的offset值调整this指针</li><li>跳到virtual function去</li></ul><p>其实thunk函数就是一段assembly代码，下面我会带大家一起揭开thunk函数的真正面纱！<br>首先要想知道thunk函数干了什么，就要想个办法去调用它，然后跟踪进去。我们上面的示例代码中有一行代码：<code>b2.i();</code>会调用thunk函数。原因是<code>Base2&amp; b2 = ins;</code>中，b2的this指针指向的ins对象的第二个虚表指针，在调用ins对象的被重写父类虚函数<code>i()</code>时，需要调整this指针。<br>具体分析过程如下：</p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs apache">    <span class="hljs-attribute">b2</span>.i();<br>  <span class="hljs-attribute">401553</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> d8          mov    -<span class="hljs-number">0</span>x28(%rbp),%rax//rbp-<span class="hljs-number">0</span>x28里面存着b2的this指针，指向ins对象的第二个虚表指针<br>  <span class="hljs-attribute">401557</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">08</span>             mov    (%rax),%rcx//将ins虚表二的第一个虚函数指针赋给了rcx寄存器<br>  <span class="hljs-attribute">40155a</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi//将b2的this指针存到rdi寄存器作为thunk函数的第一参数<br>  <span class="hljs-attribute">40155d</span>:ff <span class="hljs-number">51</span> <span class="hljs-number">08</span>             callq  *<span class="hljs-number">0</span>x8(%rcx)//偏移<span class="hljs-number">0</span>x8字节后调用thunk函数，*<span class="hljs-number">0</span>x8(%rcx)的值为<span class="hljs-number">0</span>x4017f0<br><br><span class="hljs-attribute">00000000004017f0</span> &lt;non-virtual thunk to Derived::i()&gt;:<br>  <span class="hljs-attribute">4017f0</span>:<span class="hljs-number">55</span>                   push   %rbp<br>  <span class="hljs-attribute">4017f1</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> e5             mov    %rsp,%rbp<br>  <span class="hljs-attribute">4017f4</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">7</span>d f8          mov    %rdi,-<span class="hljs-number">0</span>x8(%rbp)//将b2的this指针存放到该thunk函数rbp-<span class="hljs-number">0</span>x8的地址中<br>  <span class="hljs-attribute">4017f8</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> f8          mov    -<span class="hljs-number">0</span>x8(%rbp),%rax//将b2的this指针存放到rax临时寄存器中<br>  <span class="hljs-attribute">4017fc</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c0 f8          add    $<span class="hljs-number">0</span>xfffffffffffffff8,%rax//this指针的值（<span class="hljs-number">0</span>x00007fffffffe120）加上<span class="hljs-number">0</span>xfffffffffffffff8，因为溢出，相当于<span class="hljs-number">0</span>x00007fffffffe120-<span class="hljs-number">0</span>x8，结果为<span class="hljs-number">0</span>x00007fffffffe118即ins对象的首地址<br>  <span class="hljs-attribute">401800</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi//将偏移后的this指针存到rdi第一参数寄存器中，作为&lt;Derived::i()&gt;的参数<br>  <span class="hljs-attribute">401803</span>:<span class="hljs-number">5</span>d                   pop    %rbp<br>  <span class="hljs-attribute">401804</span>:e9 <span class="hljs-number">27</span> ff ff ff       jmpq   <span class="hljs-number">401730</span> &lt;Derived::i()&gt;<br>  <span class="hljs-attribute">401809</span>:<span class="hljs-number">0</span>f <span class="hljs-number">1</span>f <span class="hljs-number">80</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> nopl   <span class="hljs-number">0</span>x0(%rax)<br></code></pre></td></tr></table></figure><blockquote><p>后面就是调用虚函数<code>&lt;Derived::i()&gt;</code>后的过程，不再赘述。经过分析，可以发现thunk函数就做了两件事，以适当的<code>offset</code>值调整this指针，跳到virtual function去。和上面说的两点完全一致。</p></blockquote><hr><h2 id="编译期绑定和运行期绑定（动态绑定）"><a href="#编译期绑定和运行期绑定（动态绑定）" class="headerlink" title="编译期绑定和运行期绑定（动态绑定）"></a>编译期绑定和运行期绑定（动态绑定）</h2><blockquote><p>还是用上面的示例，可以看到子类中有定义一个非虚函数。咱们就来看下什么是运行期绑定和动态绑定的区别是什么。<br>在此之前，先看下绑定的概念：调用代码跟函数地址什么时候关联到一起。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//编译期绑定</span><br>d.<span class="hljs-built_in">myFunc2</span>();<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">d</span>.myFunc2();<br><span class="hljs-attribute">401596</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">7</span>d d0          mov    -<span class="hljs-number">0</span>x30(%rbp),%rdi<br><span class="hljs-attribute">40159a</span>:e8 d1 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">401670</span> &lt;Derived::myFunc2()&gt;<br></code></pre></td></tr></table></figure><blockquote><p><code>编译期绑定</code>：调用代码跟函数在编译期就关联到一起。可以看到函数调用是直接调用指定地址的函数，而且机器码会出现E8的字样，表示直接调用，俗称<code>E8CALL</code>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//动态绑定</span><br>b1.<span class="hljs-built_in">f</span>();<br>b2.<span class="hljs-built_in">i</span>();<br>d.<span class="hljs-built_in">f</span>();<br>d.<span class="hljs-built_in">i</span>();<br>d.<span class="hljs-built_in">g</span>();<br>d.<span class="hljs-built_in">myFunc1</span>();<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs apache"> <span class="hljs-attribute">b1</span>.f();<br><span class="hljs-attribute">401540</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">4</span>d e0          mov    -<span class="hljs-number">0</span>x20(%rbp),%rcx<br><span class="hljs-attribute">401544</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">11</span>             mov    (%rcx),%rdx<br><span class="hljs-attribute">401547</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> cf             mov    %rcx,%rdi<br><span class="hljs-attribute">40154a</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">85</span> <span class="hljs-number">20</span> ff ff ff mov    %rax,-<span class="hljs-number">0</span>xe0(%rbp)<br><span class="hljs-attribute">401551</span>:ff <span class="hljs-number">12</span>                callq  *(%rdx)<br>  <span class="hljs-attribute">b2</span>.i();<br><span class="hljs-attribute">401553</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> d8          mov    -<span class="hljs-number">0</span>x28(%rbp),%rax<br><span class="hljs-attribute">401557</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">08</span>             mov    (%rax),%rcx<br><span class="hljs-attribute">40155a</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br><span class="hljs-attribute">40155d</span>:ff <span class="hljs-number">51</span> <span class="hljs-number">08</span>             callq  *<span class="hljs-number">0</span>x8(%rcx)<br>  <span class="hljs-attribute">d</span>.f();<br><span class="hljs-attribute">401560</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> d0          mov    -<span class="hljs-number">0</span>x30(%rbp),%rax<br><span class="hljs-attribute">401564</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">08</span>             mov    (%rax),%rcx<br><span class="hljs-attribute">401567</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br><span class="hljs-attribute">40156a</span>:ff <span class="hljs-number">11</span>                callq  *(%rcx)<br>  <span class="hljs-attribute">d</span>.i();<br><span class="hljs-attribute">40156c</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> d0          mov    -<span class="hljs-number">0</span>x30(%rbp),%rax<br><span class="hljs-attribute">401570</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">08</span>             mov    (%rax),%rcx<br><span class="hljs-attribute">401573</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br><span class="hljs-attribute">401576</span>:ff <span class="hljs-number">51</span> <span class="hljs-number">10</span>             callq  *<span class="hljs-number">0</span>x10(%rcx)<br>  <span class="hljs-attribute">d</span>.g();<br><span class="hljs-attribute">401579</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> d0          mov    -<span class="hljs-number">0</span>x30(%rbp),%rax<br><span class="hljs-attribute">40157d</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c1             mov    %rax,%rcx<br><span class="hljs-attribute">401580</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">00</span>             mov    (%rax),%rax<br><span class="hljs-attribute">401583</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> cf             mov    %rcx,%rdi<br><span class="hljs-attribute">401586</span>:ff <span class="hljs-number">50</span> <span class="hljs-number">08</span>             callq  *<span class="hljs-number">0</span>x8(%rax)<br>  <span class="hljs-attribute">d</span>.myFunc1();<br><span class="hljs-attribute">401589</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> d0          mov    -<span class="hljs-number">0</span>x30(%rbp),%rax<br><span class="hljs-attribute">40158d</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">08</span>             mov    (%rax),%rcx<br><span class="hljs-attribute">401590</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br><span class="hljs-attribute">401593</span>:ff <span class="hljs-number">51</span> <span class="hljs-number">18</span>             callq  *<span class="hljs-number">0</span>x18(%rcx)<br></code></pre></td></tr></table></figure><blockquote><p><code>动态绑定</code>：调用代码跟函数在运行期才能关联到一起。通过上面的反汇编代码可以发现，函数的调用地址是基于某个寄存器的偏移值而确定的，无法在编译期确定。而且在函数调用机器码中会出现ff的字样，表示间接调用，俗称<code>FFCALL</code>。动态绑定还有一个别名叫<code>多态</code>，只有虚函数才能是动态绑定。</p></blockquote><hr><h1 id="多重继承下的成员布局以及this指针偏移"><a href="#多重继承下的成员布局以及this指针偏移" class="headerlink" title="多重继承下的成员布局以及this指针偏移"></a>多重继承下的成员布局以及this指针偏移</h1><blockquote><p>经过上文的分析，我们已经熟知多重继承下虚机制是如何工作的。这一小节，我将带大家分析父类含成员变量时多重继承的成员布局。在父类指针支持多态时会发生this指针偏移，delete this指针偏移后的父类指针会导致异常。说的有点繁琐，不要紧，咱们看下文：<br>代码示例：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//基类1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base1</span>():<span class="hljs-built_in">b1</span>(<span class="hljs-number">1</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;base1::f()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-type">int</span> b1;<br>&#125;;<br><span class="hljs-comment">//基类2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base2</span>():<span class="hljs-built_in">b2</span>(<span class="hljs-number">2</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;base2::h()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-type">int</span> b2;<br>&#125;;<br><span class="hljs-comment">//子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>:<span class="hljs-keyword">public</span> Base1,<span class="hljs-keyword">public</span> Base2<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>():<span class="hljs-built_in">m</span>(<span class="hljs-number">3</span>),<span class="hljs-built_in">n</span>(<span class="hljs-number">4</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span><span class="hljs-comment">//覆盖父类1的虚函数</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;derived::f()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;derived::h()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> n;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Derived类的大小%d\n&quot;</span>,<span class="hljs-built_in">sizeof</span>(Derived));<br>    <span class="hljs-comment">//打印成员变量的偏移值</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Derived::b1 = %d\n&quot;</span>,&amp;Derived::b1);<span class="hljs-comment">//b1是基于Base1的偏移</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Derived::b2 = %d\n&quot;</span>,&amp;Derived::b2);<span class="hljs-comment">//b2是基于Base2的偏移</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Derived::m = %d\n&quot;</span>,&amp;Derived::m);<span class="hljs-comment">//m基于Derived的偏移</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Derived::n = %d\n&quot;</span>,&amp;Derived::n);<span class="hljs-comment">//n基于Derived的偏移</span><br><br>    Derived obj;<br>    Base1 *pbase1 = &amp;obj;<span class="hljs-comment">//this指针没有调整。</span><br>    Base2 *pbase2 = &amp;obj;<span class="hljs-comment">//this指针向下调整0x10字节。</span><br><br>    <span class="hljs-comment">//现在我们知道Base2在支持多态时会调整this指针。如果我们的obj是new出来的，当我们用delete去删除pbase2时会发生什么？</span><br>    Base2 *new_pbase2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    <span class="hljs-comment">//delete new_pbase2;异常</span><br>    <span class="hljs-built_in">delete</span> (Derived*)new_pbase2;<span class="hljs-comment">//让编译器重新调整this指针，再delete掉。</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>运行结果如下：<br><img src="/img%5C00006%5C10.png" alt="请添加图片描述"><br>根据数据成员的偏移值，我们可以得出该类的成员布局：<br><img src="/img%5C00006%5C11.png" alt="请添加图片描述"><br>用GDB打印出空间布局，以及虚表内的虚函数：<br><img src="/img%5C00006%5C12.png" alt="请添加图片描述"><br>和上述说明一致！<br>值得关注的一个问题是，Base2在支持多态时会调整this指针。如果我们的obj是new出来的，当我们用delete去删除pbase2时会报异常，其原因在于直接delete调整后的this指针无法将new出来的derived类对象完整删除。除非我们将该this指针继续调整到derived类对象的开头，或者在父类和基类中添加virtual析构函数。<br>下一小节咱们继续深入探讨多重继承下virtual析构函数的工作原理以及虚表对应的变化！</p></blockquote><hr><h1 id="多重继承下virtual析构函数的工作原理以及虚表的变化"><a href="#多重继承下virtual析构函数的工作原理以及虚表的变化" class="headerlink" title="多重继承下virtual析构函数的工作原理以及虚表的变化"></a>多重继承下virtual析构函数的工作原理以及虚表的变化</h1><blockquote><p>继上一小节，我们已经知道多重继承下数据成员的分布，为了更好的解决delete this指针偏移后的父类指针，我们必须在父类和基类中添加virtual析构函数。这样编译器就会为虚表多加几个槽，目的在于帮助this指针偏移后的父类指针回调到derived类对象的开头，进而完成delete。<br>示例代码和上一小节差不多，如下：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//基类1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base1</span>():<span class="hljs-built_in">b1</span>(<span class="hljs-number">1</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;base1::f()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base1</span>() &#123;&#125;<br>    <span class="hljs-type">int</span> b1;<br>&#125;;<br><span class="hljs-comment">//基类2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base2</span>():<span class="hljs-built_in">b2</span>(<span class="hljs-number">2</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;base2::h()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base2</span>() &#123;&#125;<br>    <span class="hljs-type">int</span> b2;<br>&#125;;<br><span class="hljs-comment">//子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>:<span class="hljs-keyword">public</span> Base1,<span class="hljs-keyword">public</span> Base2<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>():<span class="hljs-built_in">m</span>(<span class="hljs-number">3</span>),<span class="hljs-built_in">n</span>(<span class="hljs-number">4</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span><span class="hljs-comment">//覆盖父类1的虚函数</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;derived::f()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;derived::h()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Derived</span>() &#123;&#125;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> n;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Derived *new_pderived = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    <span class="hljs-comment">//打印第一张虚表</span><br>    <span class="hljs-type">long</span>* pderived_cast1 = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span>*&gt;(new_pderived);<span class="hljs-comment">//重新解释类对象,获得虚表指针的地址。</span><br>    <span class="hljs-type">long</span>* pderived_vptr1 = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span>*&gt;(*pderived_cast1);<span class="hljs-comment">//虚表指针的类型从long重新解释为long*。让它体现出指针的性质而不是long数值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pderived_vptr1[%d] 的内容为： %p\n&quot;</span>,i,pderived_vptr1[i]);<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;----------------------------&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-comment">//打印第二张虚表</span><br>    <span class="hljs-type">long</span>* pderived_cast2 = pderived_cast1 + <span class="hljs-number">2</span>;<span class="hljs-comment">//偏移到第二个虚表指针的地址上</span><br>    <span class="hljs-type">long</span>* pderived_vptr2 = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span>*&gt;(*pderived_cast2);<span class="hljs-comment">//虚表指针的类型从long重新解释为long*。让它体现出指针的性质而不是long数值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pderived_vptr2[%d] 的内容为： %p\n&quot;</span>,i,pderived_vptr2[i]);<br>    &#125;<br>    <span class="hljs-keyword">delete</span> new_pderived;<br><br>    Base2 *new_pbase2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    <span class="hljs-keyword">delete</span> new_pbase2;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>其对应的反汇编代码如下(我将有用的部分贴在下面)：</p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs apache">    <span class="hljs-attribute">Base2</span> *new_pbase2 = new Derived();<br>  <span class="hljs-attribute">40136e</span>:e8 <span class="hljs-number">0</span>d fd ff ff       callq  <span class="hljs-number">401080</span> &lt;operator new(unsigned long)@plt&gt;<br>  <span class="hljs-attribute">401373</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c1             mov    %rax,%rcx<br>  <span class="hljs-attribute">401376</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c2             mov    %rax,%rdx<br>  <span class="hljs-attribute">401379</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br>  <span class="hljs-attribute">40137c</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">4</span>d <span class="hljs-number">88</span>          mov    %rcx,-<span class="hljs-number">0</span>x78(%rbp)<br>  <span class="hljs-attribute">401380</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">55</span> <span class="hljs-number">80</span>          mov    %rdx,-<span class="hljs-number">0</span>x80(%rbp)<br>  <span class="hljs-attribute">401384</span>:e8 <span class="hljs-number">87</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">401410</span> &lt;Derived::Derived()&gt;<br>  <span class="hljs-attribute">401389</span>:e9 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       jmpq   <span class="hljs-number">40138</span>e &lt;main+<span class="hljs-number">0</span>x16e&gt;<br>  <span class="hljs-attribute">40138e</span>:<span class="hljs-number">31</span> c0                xor    %eax,%eax<br>  <span class="hljs-attribute">401390</span>:<span class="hljs-number">89</span> c1                mov    %eax,%ecx<br>  <span class="hljs-attribute">401392</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">55</span> <span class="hljs-number">80</span>          mov    -<span class="hljs-number">0</span>x80(%rbp),%rdx<br>  <span class="hljs-attribute">401396</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> fa <span class="hljs-number">00</span>          cmp    $<span class="hljs-number">0</span>x0,%rdx<br>  <span class="hljs-attribute">40139a</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">8</span>d <span class="hljs-number">78</span> ff ff ff mov    %rcx,-<span class="hljs-number">0</span>x88(%rbp)<br>  <span class="hljs-attribute">4013a1</span>:<span class="hljs-number">0</span>f <span class="hljs-number">84</span> <span class="hljs-number">11</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    je     <span class="hljs-number">4013</span>b8 &lt;main+<span class="hljs-number">0</span>x198&gt;<br>  <span class="hljs-attribute">4013a7</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> <span class="hljs-number">80</span>          mov    -<span class="hljs-number">0</span>x80(%rbp),%rax<br>  <span class="hljs-attribute">4013ab</span>:<span class="hljs-number">48</span> <span class="hljs-number">05</span> <span class="hljs-number">10</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    add    $<span class="hljs-number">0</span>x10,%rax<br>  <span class="hljs-attribute">4013b1</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">85</span> <span class="hljs-number">78</span> ff ff ff mov    %rax,-<span class="hljs-number">0</span>x88(%rbp)<br>  <span class="hljs-attribute">4013b8</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">85</span> <span class="hljs-number">78</span> ff ff ff mov    -<span class="hljs-number">0</span>x88(%rbp),%rax<br>  <span class="hljs-attribute">4013bf</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">45</span> a8          mov    %rax,-<span class="hljs-number">0</span>x58(%rbp)<br>    <span class="hljs-attribute">delete</span> new_pbase2;<br>  <span class="hljs-attribute">4013c3</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> a8          mov    -<span class="hljs-number">0</span>x58(%rbp),%rax<br>  <span class="hljs-attribute">4013c7</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> f8 <span class="hljs-number">00</span>          cmp    $<span class="hljs-number">0</span>x0,%rax<br>  <span class="hljs-attribute">4013cb</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">85</span> <span class="hljs-number">70</span> ff ff ff mov    %rax,-<span class="hljs-number">0</span>x90(%rbp)<br>  <span class="hljs-attribute">4013d2</span>:<span class="hljs-number">0</span>f <span class="hljs-number">84</span> <span class="hljs-number">10</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    je     <span class="hljs-number">4013</span>e8 &lt;main+<span class="hljs-number">0</span>x1c8&gt;<br>  <span class="hljs-attribute">4013d8</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">85</span> <span class="hljs-number">70</span> ff ff ff mov    -<span class="hljs-number">0</span>x90(%rbp),%rax<br>  <span class="hljs-attribute">4013df</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">08</span>             mov    (%rax),%rcx<br>  <span class="hljs-attribute">4013e2</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br>  <span class="hljs-attribute">4013e5</span>:ff <span class="hljs-number">51</span> <span class="hljs-number">10</span>             callq  *<span class="hljs-number">0</span>x10(%rcx)<br>  <span class="hljs-attribute">4013e8</span>:<span class="hljs-number">8</span>b <span class="hljs-number">45</span> fc             mov    -<span class="hljs-number">0</span>x4(%rbp),%eax<br>  <span class="hljs-attribute">4013eb</span>:<span class="hljs-number">48</span> <span class="hljs-number">81</span> c4 <span class="hljs-number">90</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> add    $<span class="hljs-number">0</span>x90,%rsp<br>  <span class="hljs-attribute">4013f2</span>:<span class="hljs-number">5</span>d                   pop    %rbp<br>  <span class="hljs-attribute">4013f3</span>:c3                   retq  <br><br><span class="hljs-attribute">0000000000401540</span> &lt;Derived::~Derived()&gt;:<br>    <span class="hljs-attribute">virtual</span> ~Derived() &#123;&#125;<br>  <span class="hljs-attribute">401540</span>:<span class="hljs-number">55</span>                   push   %rbp<br>  <span class="hljs-attribute">401541</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> e5             mov    %rsp,%rbp<br>  <span class="hljs-attribute">401544</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">10</span>          sub    $<span class="hljs-number">0</span>x10,%rsp<br>  <span class="hljs-attribute">401548</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">7</span>d f8          mov    %rdi,-<span class="hljs-number">0</span>x8(%rbp)<br>  <span class="hljs-attribute">40154c</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> f8          mov    -<span class="hljs-number">0</span>x8(%rbp),%rax<br>  <span class="hljs-attribute">401550</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c1             mov    %rax,%rcx<br>  <span class="hljs-attribute">401553</span>:<span class="hljs-number">48</span> <span class="hljs-number">81</span> c1 <span class="hljs-number">10</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> add    $<span class="hljs-number">0</span>x10,%rcx<br>  <span class="hljs-attribute">40155a</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> cf             mov    %rcx,%rdi<br>  <span class="hljs-attribute">40155d</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">45</span> f0          mov    %rax,-<span class="hljs-number">0</span>x10(%rbp)<br>  <span class="hljs-attribute">401561</span>:e8 aa <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">401710</span> &lt;Base2::~Base2()&gt;<br>  <span class="hljs-attribute">401566</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> f0          mov    -<span class="hljs-number">0</span>x10(%rbp),%rax<br>  <span class="hljs-attribute">40156a</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br>  <span class="hljs-attribute">40156d</span>:e8 <span class="hljs-number">1</span>e <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">401690</span> &lt;Base1::~Base1()&gt;<br>  <span class="hljs-attribute">401572</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">10</span>          add    $<span class="hljs-number">0</span>x10,%rsp<br>  <span class="hljs-attribute">401576</span>:<span class="hljs-number">5</span>d                   pop    %rbp<br>  <span class="hljs-attribute">401577</span>:c3                   retq   <br>  <span class="hljs-attribute">401578</span>:<span class="hljs-number">0</span>f <span class="hljs-number">1</span>f <span class="hljs-number">84</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> nopl   <span class="hljs-number">0</span>x0(%rax,%rax,<span class="hljs-number">1</span>)<br>  <span class="hljs-attribute">40157f</span>:<span class="hljs-number">00</span> <br><br><span class="hljs-attribute">0000000000401580</span> &lt;Derived::~Derived()&gt;:<br>  <span class="hljs-attribute">401580</span>:<span class="hljs-number">55</span>                   push   %rbp<br>  <span class="hljs-attribute">401581</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> e5             mov    %rsp,%rbp<br>  <span class="hljs-attribute">401584</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">10</span>          sub    $<span class="hljs-number">0</span>x10,%rsp<br>  <span class="hljs-attribute">401588</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">7</span>d f8          mov    %rdi,-<span class="hljs-number">0</span>x8(%rbp)<br>  <span class="hljs-attribute">40158c</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> f8          mov    -<span class="hljs-number">0</span>x8(%rbp),%rax<br>  <span class="hljs-attribute">401590</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br>  <span class="hljs-attribute">401593</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">45</span> f0          mov    %rax,-<span class="hljs-number">0</span>x10(%rbp)<br>  <span class="hljs-attribute">401597</span>:e8 a4 ff ff ff       callq  <span class="hljs-number">401540</span> &lt;Derived::~Derived()&gt;<br>  <span class="hljs-attribute">40159c</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> f0          mov    -<span class="hljs-number">0</span>x10(%rbp),%rax<br>  <span class="hljs-attribute">4015a0</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br>  <span class="hljs-attribute">4015a3</span>:e8 b8 fa ff ff       callq  <span class="hljs-number">401060</span> &lt;operator delete(void*)@plt&gt;<br>  <span class="hljs-attribute">4015a8</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">10</span>          add    $<span class="hljs-number">0</span>x10,%rsp<br>  <span class="hljs-attribute">4015ac</span>:<span class="hljs-number">5</span>d                   pop    %rbp<br>  <span class="hljs-attribute">4015ad</span>:c3                   retq   <br>  <span class="hljs-attribute">4015ae</span>:<span class="hljs-number">66</span> <span class="hljs-number">90</span>                xchg   %ax,%ax<br><br><span class="hljs-attribute">0000000000401610</span> &lt;non-virtual thunk to Derived::~Derived()&gt;:<br>  <span class="hljs-attribute">401610</span>:<span class="hljs-number">55</span>                   push   %rbp<br>  <span class="hljs-attribute">401611</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> e5             mov    %rsp,%rbp<br>  <span class="hljs-attribute">401614</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">7</span>d f8          mov    %rdi,-<span class="hljs-number">0</span>x8(%rbp)<br>  <span class="hljs-attribute">401618</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> f8          mov    -<span class="hljs-number">0</span>x8(%rbp),%rax<br>  <span class="hljs-attribute">40161c</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c0 f0          add    $<span class="hljs-number">0</span>xfffffffffffffff0,%rax<br>  <span class="hljs-attribute">401620</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br>  <span class="hljs-attribute">401623</span>:<span class="hljs-number">5</span>d                   pop    %rbp<br>  <span class="hljs-attribute">401624</span>:e9 <span class="hljs-number">17</span> ff ff ff       jmpq   <span class="hljs-number">401540</span> &lt;Derived::~Derived()&gt;<br>  <span class="hljs-attribute">401629</span>:<span class="hljs-number">0</span>f <span class="hljs-number">1</span>f <span class="hljs-number">80</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> nopl   <span class="hljs-number">0</span>x0(%rax)<br><br><span class="hljs-attribute">0000000000401630</span> &lt;non-virtual thunk to Derived::~Derived()&gt;:<br>  <span class="hljs-attribute">401630</span>:<span class="hljs-number">55</span>                   push   %rbp<br>  <span class="hljs-attribute">401631</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> e5             mov    %rsp,%rbp<br>  <span class="hljs-attribute">401634</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">7</span>d f8          mov    %rdi,-<span class="hljs-number">0</span>x8(%rbp)<br>  <span class="hljs-attribute">401638</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> f8          mov    -<span class="hljs-number">0</span>x8(%rbp),%rax<br>  <span class="hljs-attribute">40163c</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c0 f0          add    $<span class="hljs-number">0</span>xfffffffffffffff0,%rax<br>  <span class="hljs-attribute">401640</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br>  <span class="hljs-attribute">401643</span>:<span class="hljs-number">5</span>d                   pop    %rbp<br>  <span class="hljs-attribute">401644</span>:e9 <span class="hljs-number">37</span> ff ff ff       jmpq   <span class="hljs-number">401580</span> &lt;Derived::~Derived()&gt;<br>  <span class="hljs-attribute">401649</span>:<span class="hljs-number">0</span>f <span class="hljs-number">1</span>f <span class="hljs-number">80</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> nopl   <span class="hljs-number">0</span>x0(%rax)<br></code></pre></td></tr></table></figure><blockquote><p>因为virtual析构函数的加入，我将打印的步骤简化了，否则显示会混乱。运行结果如下：<br><img src="/img%5C00006%5C13.png" alt="在这里插入图片描述"><br>这种情况下GDB打印出来的虚表内容有错误，或者是它故意隐瞒，其原因不得而知，我将补充后的结果贴在这里：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&gt;gef➤  info vtbl *new_pderived<br>&gt;vtable <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;Derived&#x27;</span> @ <span class="hljs-number">0</span>x4020b0 (subobject @ <span class="hljs-number">0</span>x416eb0):<br>&gt;<span class="hljs-selector-attr">[0]</span>: <span class="hljs-number">0</span>x401500 &lt;Derived::<span class="hljs-built_in">f</span>()&gt;<br>&gt;<span class="hljs-selector-attr">[1]</span>: <span class="hljs-number">0</span>x401540 &lt;Derived::~<span class="hljs-built_in">Derived</span>()&gt;<br>&gt;<span class="hljs-selector-attr">[2]</span>: <span class="hljs-number">0</span>x401580 &lt;Derived::~<span class="hljs-built_in">Derived</span>()&gt;<br>&gt;<span class="hljs-selector-attr">[3]</span>: <span class="hljs-number">0</span>x4015b0 &lt;Derived::<span class="hljs-built_in">h</span>()&gt;<br>&gt;vtable <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;Base2&#x27;</span> @ <span class="hljs-number">0</span>x4020e0 (subobject @ <span class="hljs-number">0</span>x416ec0):<br>&gt;<span class="hljs-selector-attr">[0]</span>: <span class="hljs-number">0</span>x4015f0 &lt;non-virtual thunk to Derived::<span class="hljs-built_in">h</span>()&gt;<br>&gt;<span class="hljs-selector-attr">[1]</span>: <span class="hljs-number">0</span>x401610 &lt;non-virtual thunk to Derived::~<span class="hljs-built_in">Derived</span>()&gt;<span class="hljs-comment">//笔者补充上的</span><br>&gt;<span class="hljs-selector-attr">[2]</span>: <span class="hljs-number">0</span>x401630 &lt;non-virtual thunk to Derived::~<span class="hljs-built_in">Derived</span>()&gt;<span class="hljs-comment">//笔者补充上的</span><br></code></pre></td></tr></table></figure><p>我们重点关注最后两行：<code>Base2 *new_pbase2 = new Derived();delete new_pbase2;</code>看编译如何完成this指针的回调：<br><img src="/img%5C00006%5C14.png" alt="在这里插入图片描述"><br>反汇编代码运行到<code>0x4013c3 &lt;main+419&gt;       mov    rax, QWORD PTR [rbp-0x58]</code>之前发生的事情有：Derived类对象在<code>0x416eb0</code>堆内存地址上进行构造，<code>0x416eb0+0x10</code>后的堆指针（Base2类对象的this指针）存储在<code>$rbp-0x58</code>（0x7fffffffe0d8）栈内存中。这一过程的结果我用一张图进行表达：<br><img src="/img%5C00006%5C15.png" alt="请添加图片描述"></p></blockquote><blockquote><p><img src="/img%5C00006%5C16.png" alt="在这里插入图片描述"><br>该图在<code>0x4013e5 &lt;main+453&gt;       call   QWORD PTR [rcx+0x10]</code>还未执行时发生的事情有：编译器将Base2类对象的this指针存储在<code>rdi</code>参数寄存器中，作为<code>&lt;non-virtual thunk to Derived::~Derived()&gt;</code>函数（<code>rcx+0x10</code>）的第一参数。该函数指针指向文本段<code>0x401630</code>处。<br><img src="/img%5C00006%5C17.png" alt="在这里插入图片描述"><br>反汇编代码运行到<code>0x401644 &lt;non-virtual+0&gt;  jmp    0x401580 &lt;Derived::~Derived()&gt;</code>之前发生的事情有：rdi参数寄存器将其值保存到<code>rax</code>临时寄存器中，<code>rax</code>将该值（<code>0x416ec0</code>）加上<code>0xfffffffffffffff0</code>，由于溢出，相当于<code>-0x10</code>，得到的新值（<code>0x416eb0</code>）存储到<code>rax</code>寄存器中。随后调用带<code>operator delete(void*)</code>的virtual析构函数。<br>至此完成this指针回调，delete可以正常销毁掉new出来Derived类对象。</p></blockquote><hr><h1 id="多重虚继承下的访问虚基类成员变量时虚表的工作原理，以及子类成员布局"><a href="#多重虚继承下的访问虚基类成员变量时虚表的工作原理，以及子类成员布局" class="headerlink" title="多重虚继承下的访问虚基类成员变量时虚表的工作原理，以及子类成员布局"></a>多重虚继承下的访问虚基类成员变量时虚表的工作原理，以及子类成员布局</h1><blockquote><p>在分析之前，咱们先回顾一下《深度探索c++对象模型》p120提出来的一个问题：<br>每一个对象必须针对其每一个virtual base class背负一个额外的指针，然而理想上我们却希望class object有固定的负担，不因为其virtual base classes的个数而有所变化。想想看这该如何解决？</p><ul><li>一般而言有两种解决方法。Microsoft 编译器引入所谓的virtual base class table。每一个class object如果有一个或者多个virtual base classes，就会由编译器安插一个指针，指向virtual base class table。至于真正的virtual base class指针，当然是被放在该表格中。</li><li>第二个解决方法，是在virtual function table 中放置virtual base class 的 offset（而不是第一种办法中说的virtual base class指针）。编译器可以通过virtual function table的正负值来索引该offset。如果是正值，显然索引到的是virtual function；如果是负值，则是索引到virtual base class offsets。</li></ul><p>正如上面第二种方法所述，clang编译器采取的就是基于vtbl的offset来获取虚基类的this指针，进而完成虚基类数据成员的访问。<br>咱们来看具体分析过程，如下：<br>先设计一个菱形继承的Derived类。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//爷爷类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">grandpa</span><span class="hljs-comment">//类名首字母忘记大写了，抱歉</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">grandpa</span>():<span class="hljs-built_in">pa</span>(<span class="hljs-number">1</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;grandpa::f()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;grandpa::g()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">grandpa</span>() &#123;&#125;<br>    <span class="hljs-type">int</span> pa;<br>&#125;;<br><span class="hljs-comment">//父类1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span>:<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> grandpa<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base1</span>():<span class="hljs-built_in">b1</span>(<span class="hljs-number">2</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;base1::h()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">i</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;base1::i()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base1</span>() &#123;&#125;<br>    <span class="hljs-type">int</span> b1;<br>&#125;;<br><span class="hljs-comment">//父类2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base2</span>:<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> grandpa<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base2</span>():<span class="hljs-built_in">b2</span>(<span class="hljs-number">3</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">j</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;base2::j()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">k</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;base2::k()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base2</span>() &#123;&#125;<br>    <span class="hljs-type">int</span> b2;<br>&#125;;<br><span class="hljs-comment">//子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>:<span class="hljs-keyword">public</span> Base1,<span class="hljs-keyword">public</span> Base2<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>():<span class="hljs-built_in">m</span>(<span class="hljs-number">4</span>),<span class="hljs-built_in">n</span>(<span class="hljs-number">5</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span><span class="hljs-comment">//覆盖爷爷类的虚函数</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;derived::f()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span><span class="hljs-comment">//覆盖父类1的虚函数</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;derived::h()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">j</span><span class="hljs-params">()</span><span class="hljs-comment">//覆盖父类2的虚函数</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;derived::j()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">l</span><span class="hljs-params">()</span><span class="hljs-comment">//derived类自己的虚函数</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;derived::l()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Derived</span>() &#123;&#125;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> n;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Derived *new_pderived = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    new_pderived-&gt;pa = <span class="hljs-number">11</span>;<br>    <span class="hljs-keyword">delete</span> new_pderived;<br><br>    Base1 *new_pbase1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    new_pbase1-&gt;pa = <span class="hljs-number">11</span>;<br>    <span class="hljs-keyword">delete</span> new_pbase1;<br><br>    Base2 *new_pbase2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    new_pbase2-&gt;pa = <span class="hljs-number">11</span>;<br>    <span class="hljs-keyword">delete</span> new_pbase2;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>需要用到的反汇编代码如下：</p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs apache">  <span class="hljs-attribute">Derived</span> *new_pderived = new Derived();<br><span class="hljs-attribute">401227</span>:e8 <span class="hljs-number">44</span> fe ff ff       callq  <span class="hljs-number">401070</span> &lt;operator new(unsigned long)@plt&gt;<br><span class="hljs-attribute">40122c</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c1             mov    %rax,%rcx<br><span class="hljs-attribute">40122f</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c2             mov    %rax,%rdx<br><span class="hljs-attribute">401232</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br><span class="hljs-attribute">401235</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">4</span>d c8          mov    %rcx,-<span class="hljs-number">0</span>x38(%rbp)<br><span class="hljs-attribute">401239</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">55</span> c0          mov    %rdx,-<span class="hljs-number">0</span>x40(%rbp)<br><span class="hljs-attribute">40123d</span>:e8 <span class="hljs-number">7</span>e <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">4013</span>c0 &lt;Derived::Derived()&gt;<br><span class="hljs-attribute">401242</span>:e9 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       jmpq   <span class="hljs-number">401247</span> &lt;main+<span class="hljs-number">0</span>x37&gt;<br><span class="hljs-attribute">401247</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> c0          mov    -<span class="hljs-number">0</span>x40(%rbp),%rax<br><span class="hljs-attribute">40124b</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">45</span> f0          mov    %rax,-<span class="hljs-number">0</span>x10(%rbp)<br>  <span class="hljs-attribute">new_pderived</span>-&gt;pa = <span class="hljs-number">11</span>;<br><span class="hljs-attribute">40124f</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">4</span>d f0          mov    -<span class="hljs-number">0</span>x10(%rbp),%rcx<br><span class="hljs-attribute">401253</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">11</span>             mov    (%rcx),%rdx<br><span class="hljs-attribute">401256</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">52</span> e8          mov    -<span class="hljs-number">0</span>x18(%rdx),%rdx<br><span class="hljs-attribute">40125a</span>:c7 <span class="hljs-number">44</span> <span class="hljs-number">11</span> <span class="hljs-number">08</span> <span class="hljs-number">0</span>b <span class="hljs-number">00</span> <span class="hljs-number">00</span> movl   $<span class="hljs-number">0</span>xb,<span class="hljs-number">0</span>x8(%rcx,%rdx,<span class="hljs-number">1</span>)<br><span class="hljs-attribute">401261</span>:<span class="hljs-number">00</span> <br>  <span class="hljs-attribute">delete</span> new_pderived;<br><span class="hljs-attribute">401262</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">4</span>d f0          mov    -<span class="hljs-number">0</span>x10(%rbp),%rcx<br><span class="hljs-attribute">401266</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> f9 <span class="hljs-number">00</span>          cmp    $<span class="hljs-number">0</span>x0,%rcx<br><span class="hljs-attribute">40126a</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">4</span>d b8          mov    %rcx,-<span class="hljs-number">0</span>x48(%rbp)<br><span class="hljs-attribute">40126e</span>:<span class="hljs-number">0</span>f <span class="hljs-number">84</span> <span class="hljs-number">0</span>d <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    je     <span class="hljs-number">401281</span> &lt;main+<span class="hljs-number">0</span>x71&gt;<br><span class="hljs-attribute">401274</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> b8          mov    -<span class="hljs-number">0</span>x48(%rbp),%rax<br><span class="hljs-attribute">401278</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">08</span>             mov    (%rax),%rcx<br><span class="hljs-attribute">40127b</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br><span class="hljs-attribute">40127e</span>:ff <span class="hljs-number">51</span> <span class="hljs-number">18</span>             callq  *<span class="hljs-number">0</span>x18(%rcx)<br><span class="hljs-attribute">401281</span>:bf <span class="hljs-number">38</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x38,%edi<br><br>  <span class="hljs-attribute">Base1</span> *new_pbase1 = new Derived();<br><span class="hljs-attribute">401286</span>:e8 e5 fd ff ff       callq  <span class="hljs-number">401070</span> &lt;operator new(unsigned long)@plt&gt;<br><span class="hljs-attribute">40128b</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c1             mov    %rax,%rcx<br><span class="hljs-attribute">40128e</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c2             mov    %rax,%rdx<br><span class="hljs-attribute">401291</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br><span class="hljs-attribute">401294</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">4</span>d b0          mov    %rcx,-<span class="hljs-number">0</span>x50(%rbp)<br><span class="hljs-attribute">401298</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">55</span> a8          mov    %rdx,-<span class="hljs-number">0</span>x58(%rbp)<br><span class="hljs-attribute">40129c</span>:e8 <span class="hljs-number">1</span>f <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">4013</span>c0 &lt;Derived::Derived()&gt;<br><span class="hljs-attribute">4012a1</span>:e9 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       jmpq   <span class="hljs-number">4012</span>a6 &lt;main+<span class="hljs-number">0</span>x96&gt;<br><span class="hljs-attribute">4012a6</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> a8          mov    -<span class="hljs-number">0</span>x58(%rbp),%rax<br><span class="hljs-attribute">4012aa</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">45</span> d8          mov    %rax,-<span class="hljs-number">0</span>x28(%rbp)<br>  <span class="hljs-attribute">new_pbase1</span>-&gt;pa = <span class="hljs-number">11</span>;<br><span class="hljs-attribute">4012ae</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> d8          mov    -<span class="hljs-number">0</span>x28(%rbp),%rax<br><span class="hljs-attribute">4012b2</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">08</span>             mov    (%rax),%rcx<br><span class="hljs-attribute">4012b5</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">49</span> e8          mov    -<span class="hljs-number">0</span>x18(%rcx),%rcx<br><span class="hljs-attribute">4012b9</span>:c7 <span class="hljs-number">44</span> <span class="hljs-number">08</span> <span class="hljs-number">08</span> <span class="hljs-number">0</span>b <span class="hljs-number">00</span> <span class="hljs-number">00</span> movl   $<span class="hljs-number">0</span>xb,<span class="hljs-number">0</span>x8(%rax,%rcx,<span class="hljs-number">1</span>)<br><span class="hljs-attribute">4012c0</span>:<span class="hljs-number">00</span> <br>  <span class="hljs-attribute">delete</span> new_pbase1;<br><span class="hljs-attribute">4012c1</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> d8          mov    -<span class="hljs-number">0</span>x28(%rbp),%rax<br><span class="hljs-attribute">4012c5</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> f8 <span class="hljs-number">00</span>          cmp    $<span class="hljs-number">0</span>x0,%rax<br><span class="hljs-attribute">4012c9</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">45</span> a0          mov    %rax,-<span class="hljs-number">0</span>x60(%rbp)<br><span class="hljs-attribute">4012cd</span>:<span class="hljs-number">0</span>f <span class="hljs-number">84</span> <span class="hljs-number">0</span>d <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    je     <span class="hljs-number">4012</span>e0 &lt;main+<span class="hljs-number">0</span>xd0&gt;<br><span class="hljs-attribute">4012d3</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> a0          mov    -<span class="hljs-number">0</span>x60(%rbp),%rax<br><span class="hljs-attribute">4012d7</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">08</span>             mov    (%rax),%rcx<br><span class="hljs-attribute">4012da</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br><span class="hljs-attribute">4012dd</span>:ff <span class="hljs-number">51</span> <span class="hljs-number">18</span>             callq  *<span class="hljs-number">0</span>x18(%rcx)<br><span class="hljs-attribute">4012e0</span>:bf <span class="hljs-number">38</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x38,%edi<br><br>  <span class="hljs-attribute">Base2</span> *new_pbase2 = new Derived();<br><span class="hljs-attribute">4012e5</span>:e8 <span class="hljs-number">86</span> fd ff ff       callq  <span class="hljs-number">401070</span> &lt;operator new(unsigned long)@plt&gt;<br><span class="hljs-attribute">4012ea</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c1             mov    %rax,%rcx<br><span class="hljs-attribute">4012ed</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c2             mov    %rax,%rdx<br><span class="hljs-attribute">4012f0</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br><span class="hljs-attribute">4012f3</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">4</span>d <span class="hljs-number">98</span>          mov    %rcx,-<span class="hljs-number">0</span>x68(%rbp)<br><span class="hljs-attribute">4012f7</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">55</span> <span class="hljs-number">90</span>          mov    %rdx,-<span class="hljs-number">0</span>x70(%rbp)<br><span class="hljs-attribute">4012fb</span>:e8 c0 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">4013</span>c0 &lt;Derived::Derived()&gt;<br><span class="hljs-attribute">401300</span>:e9 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       jmpq   <span class="hljs-number">401305</span> &lt;main+<span class="hljs-number">0</span>xf5&gt;<br><span class="hljs-attribute">401305</span>:<span class="hljs-number">31</span> c0                xor    %eax,%eax<br><span class="hljs-attribute">401307</span>:<span class="hljs-number">89</span> c1                mov    %eax,%ecx<br><span class="hljs-attribute">401309</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">55</span> <span class="hljs-number">90</span>          mov    -<span class="hljs-number">0</span>x70(%rbp),%rdx<br><span class="hljs-attribute">40130d</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> fa <span class="hljs-number">00</span>          cmp    $<span class="hljs-number">0</span>x0,%rdx<br><span class="hljs-attribute">401311</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">4</span>d <span class="hljs-number">88</span>          mov    %rcx,-<span class="hljs-number">0</span>x78(%rbp)<br><span class="hljs-attribute">401315</span>:<span class="hljs-number">0</span>f <span class="hljs-number">84</span> <span class="hljs-number">0</span>e <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    je     <span class="hljs-number">401329</span> &lt;main+<span class="hljs-number">0</span>x119&gt;<br><span class="hljs-attribute">40131b</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> <span class="hljs-number">90</span>          mov    -<span class="hljs-number">0</span>x70(%rbp),%rax<br><span class="hljs-attribute">40131f</span>:<span class="hljs-number">48</span> <span class="hljs-number">05</span> <span class="hljs-number">10</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    add    $<span class="hljs-number">0</span>x10,%rax<br><span class="hljs-attribute">401325</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">45</span> <span class="hljs-number">88</span>          mov    %rax,-<span class="hljs-number">0</span>x78(%rbp)<br><span class="hljs-attribute">401329</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> <span class="hljs-number">88</span>          mov    -<span class="hljs-number">0</span>x78(%rbp),%rax<br><span class="hljs-attribute">40132d</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">45</span> d0          mov    %rax,-<span class="hljs-number">0</span>x30(%rbp)<br>  <span class="hljs-attribute">new_pbase2</span>-&gt;pa = <span class="hljs-number">11</span>;<br><span class="hljs-attribute">401331</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> d0          mov    -<span class="hljs-number">0</span>x30(%rbp),%rax<br><span class="hljs-attribute">401335</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">08</span>             mov    (%rax),%rcx<br><span class="hljs-attribute">401338</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">49</span> e8          mov    -<span class="hljs-number">0</span>x18(%rcx),%rcx<br><span class="hljs-attribute">40133c</span>:c7 <span class="hljs-number">44</span> <span class="hljs-number">08</span> <span class="hljs-number">08</span> <span class="hljs-number">0</span>b <span class="hljs-number">00</span> <span class="hljs-number">00</span> movl   $<span class="hljs-number">0</span>xb,<span class="hljs-number">0</span>x8(%rax,%rcx,<span class="hljs-number">1</span>)<br><span class="hljs-attribute">401343</span>:<span class="hljs-number">00</span> <br>  <span class="hljs-attribute">delete</span> new_pbase2;<br><span class="hljs-attribute">401344</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> d0          mov    -<span class="hljs-number">0</span>x30(%rbp),%rax<br><span class="hljs-attribute">401348</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> f8 <span class="hljs-number">00</span>          cmp    $<span class="hljs-number">0</span>x0,%rax<br><span class="hljs-attribute">40134c</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">45</span> <span class="hljs-number">80</span>          mov    %rax,-<span class="hljs-number">0</span>x80(%rbp)<br><span class="hljs-attribute">401350</span>:<span class="hljs-number">0</span>f <span class="hljs-number">84</span> <span class="hljs-number">0</span>d <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    je     <span class="hljs-number">401363</span> &lt;main+<span class="hljs-number">0</span>x153&gt;<br><span class="hljs-attribute">401356</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">45</span> <span class="hljs-number">80</span>          mov    -<span class="hljs-number">0</span>x80(%rbp),%rax<br><span class="hljs-attribute">40135a</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">08</span>             mov    (%rax),%rcx<br><span class="hljs-attribute">40135d</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br><span class="hljs-attribute">401360</span>:ff <span class="hljs-number">51</span> <span class="hljs-number">18</span>             callq  *<span class="hljs-number">0</span>x18(%rcx)<br><span class="hljs-attribute">401363</span>:<span class="hljs-number">8</span>b <span class="hljs-number">45</span> fc             mov    -<span class="hljs-number">0</span>x4(%rbp),%eax<br><span class="hljs-attribute">401366</span>:<span class="hljs-number">48</span> <span class="hljs-number">81</span> c4 <span class="hljs-number">80</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> add    $<span class="hljs-number">0</span>x80,%rsp<br><span class="hljs-attribute">40136d</span>:<span class="hljs-number">5</span>d                   pop    %rbp<br><span class="hljs-attribute">40136e</span>:c3                   retq   <br><span class="hljs-attribute">40136f</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">45</span> e8          mov    %rax,-<span class="hljs-number">0</span>x18(%rbp)<br><span class="hljs-attribute">401373</span>:<span class="hljs-number">89</span> <span class="hljs-number">55</span> e4             mov    %edx,-<span class="hljs-number">0</span>x1c(%rbp)<br><span class="hljs-attribute">401376</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">7</span>d c8          mov    -<span class="hljs-number">0</span>x38(%rbp),%rdi<br></code></pre></td></tr></table></figure><blockquote><p>Derived类的vtbl内容如下(编译器没有完全打印出来，笔者将补充后的列在下面)：</p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gef➤  info vtbl *new_pderived<br>vtable <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;Derived&#x27;</span> @ <span class="hljs-number">0</span>x402020 (subobject @ <span class="hljs-number">0</span>x416eb0):<br><span class="hljs-selector-attr">[0]</span>: <span class="hljs-number">0</span>x401850 &lt;Derived::<span class="hljs-built_in">h</span>()&gt;<br><span class="hljs-selector-attr">[1]</span>: <span class="hljs-number">0</span>x4015b0 &lt;Base1::<span class="hljs-selector-tag">i</span>()&gt;<br><span class="hljs-selector-attr">[2]</span>: <span class="hljs-number">0</span>x401890 &lt;Derived::~<span class="hljs-built_in">Derived</span>()&gt;<br><span class="hljs-selector-attr">[3]</span>: <span class="hljs-number">0</span>x4018d0 &lt;Derived::~<span class="hljs-built_in">Derived</span>()&gt;<br><span class="hljs-selector-attr">[4]</span>: <span class="hljs-number">0</span>x401900 &lt;Derived::<span class="hljs-built_in">f</span>()&gt;<br><span class="hljs-selector-attr">[5]</span>: <span class="hljs-number">0</span>x401940 &lt;Derived::<span class="hljs-built_in">j</span>()&gt;<br><span class="hljs-selector-attr">[6]</span>: <span class="hljs-number">0</span>x401980 &lt;Derived::<span class="hljs-built_in">l</span>()&gt;<br>vtable <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;Base2&#x27;</span> @ <span class="hljs-number">0</span>x402070 (subobject @ <span class="hljs-number">0</span>x416ec0):<br><span class="hljs-selector-attr">[0]</span>: <span class="hljs-number">0</span>x4019c0 &lt;non-virtual thunk to Derived::<span class="hljs-built_in">j</span>()&gt;<br><span class="hljs-selector-attr">[1]</span>: <span class="hljs-number">0</span>x401760 &lt;Base2::<span class="hljs-built_in">k</span>()&gt;<br><span class="hljs-selector-attr">[2]</span>: <span class="hljs-number">0</span>x4019e0 &lt;non-virtual thunk to Derived::~<span class="hljs-built_in">Derived</span>()&gt;<span class="hljs-comment">//笔者补充的</span><br><span class="hljs-selector-attr">[3]</span>: <span class="hljs-number">0</span>x401a00 &lt;non-virtual thunk to Derived::~<span class="hljs-built_in">Derived</span>()&gt;<span class="hljs-comment">//笔者补充的</span><br>vtable <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;grandpa&#x27;</span> @ <span class="hljs-number">0</span>x4020b8 (subobject @ <span class="hljs-number">0</span>x416ed8):<br><span class="hljs-selector-attr">[0]</span>: <span class="hljs-number">0</span>x401a20 &lt;virtual thunk to Derived::<span class="hljs-built_in">f</span>()&gt;<br><span class="hljs-selector-attr">[1]</span>: <span class="hljs-number">0</span>x4016a0 &lt;grandpa::<span class="hljs-built_in">g</span>()&gt;<br><span class="hljs-selector-attr">[2]</span>: <span class="hljs-number">0</span>x401a40 &lt;virtual thunk to Derived::~<span class="hljs-built_in">Derived</span>()&gt;<span class="hljs-comment">//笔者补充的</span><br><span class="hljs-selector-attr">[3]</span>: <span class="hljs-number">0</span>x401a60 &lt;virtual thunk to Derived::~<span class="hljs-built_in">Derived</span>()&gt;<span class="hljs-comment">//笔者补充的</span><br></code></pre></td></tr></table></figure><blockquote><p>至于为什么Base2类和grandpa类会多出两个thunk函数，上一小节已经分析过。这里补充一点，因为Derived类对象的数据布局最上面是Base1类对象，中间是Base2类对象，virtual grandpa对象永远是在最下面。这样就导致Base2类在支持多态时调用被重写的虚函数以及调用Derived类的virtual析构函数时，需要调整this指针。grandpa类道理一样。<br>咱们用GDB查看Derived类对象的内存布局，并用图画方式直观表达出来：<br><img src="/img%5C00006%5C18.png" alt="在这里插入图片描述"><br><img src="/img%5C00006%5C19.png" alt="请添加图片描述"><br>上图中，笔者将offset出现的地方明确标明出来了，下面咱们就来看下编译是如何取出这个offsets的！<br><img src="/img%5C00006%5C20.png" alt="请添加图片描述"><br>反汇编代码<code>0x401256 &lt;main+70&gt;        mov    rdx, QWORD PTR [rdx-0x18]</code>还未执行时，发生的事情有：Derived类对象在<code>0x416eb0</code>堆内存中进行了构造。new_pderived指针的地址为<code>rbp-0x10</code>，它指向<code>0x416eb0</code>堆内存。编译器将Derived类<code>vptr1</code>指向的虚表地址存储到<code>rdx</code>中。<br>接下来将会发生的事情有：编译器将该虚表地址偏移<code>-0x18</code>字节并获取该地址中的内容（<code>offset</code>），将其值（<code>0x28</code>）存入<code>rdx</code>寄存器中。最后将<code>十进制11</code>存入this指针偏移后的地址中（<code>rcx+rdx*1+0x8</code>：<code>0x416eb0+0x28*1+0x8 = 0x416ee0</code>，即<code>pa</code>的地址）。<br><img src="/img%5C00006%5C21.png" alt="在这里插入图片描述"><br>代码段<code>new_pbase1-&gt;pa = 11;</code>和<code>new_pbase2-&gt;pa = 11;</code>同样会出现取<code>offset</code>进行偏移后，然后存取grandpa的成员变量pa的情况。<code>new_pbase1-&gt;pa</code>取到的<code>offset</code>值和<code>new_pderived-&gt;pa</code>一样是<code>0x28</code>。而<code>new_pbase2-&gt;pa</code>取到的值为<code>0x18</code>。<br><img src="/img%5C00006%5C22.png" alt="在这里插入图片描述"><br>如果是虚基类grandpa在支持多态时，且<code>new_pgrandpa-&gt;pa</code>进行存取操作，则不用偏移this指针，也就不需要取<code>offset</code>。该虚基类的虚表中也没有存<code>offset</code>。<br><img src="/img%5C00006%5C23.png" alt="在这里插入图片描述"><br>可以看到<code>0x4020b8-0x18</code>地址上的值是个牛马值 :)</p></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++11,14,17中auto和decltype相关知识及拓展</title>
    <link href="/2022/02/09/00005.%20C++11,14,17%E4%B8%ADauto%E5%92%8Cdecltype%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E5%8F%8A%E6%8B%93%E5%B1%95/"/>
    <url>/2022/02/09/00005.%20C++11,14,17%E4%B8%ADauto%E5%92%8Cdecltype%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E5%8F%8A%E6%8B%93%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p><strong>本篇文章为笔者的读书笔记，未经允许请勿转载。</strong><br>这篇文章是上篇文章《<a href="https://blog.csdn.net/Howl_1/article/details/122625409">C++prvalue，xvalue和lvalue的相关知识</a>》的续作，上次我们已经把prvalue，xvalue和lvalue说清楚了，本篇文章就来探讨一下prvalue，xvalue和lvalue与decltype之间的联系。顺便咱们也把auto类型说明符也都拓展一下。</p></blockquote><hr><h1 id="从初始化器和表达式中推导（-Deduction-from-Initializers-and-Expressions）"><a href="#从初始化器和表达式中推导（-Deduction-from-Initializers-and-Expressions）" class="headerlink" title="从初始化器和表达式中推导（ Deduction from Initializers and Expressions）"></a>从初始化器和表达式中推导（ Deduction from Initializers and Expressions）</h1><blockquote><p>C++11包括声明一个类型是从其初始化器推导出变量类型的能力（auto）。它还提供了一种机制来表示已命名对象（变量或函数）或表达式的类型（decltype）。这些设施原来非常方便，而C++14和C++17在这个主题上增加了额外的变体。</p></blockquote><hr><h1 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h1><blockquote><p>编程时常常需要把表达式的值赋给变量，这就要求在声明变量的时候清楚地知道表达式的类型。c++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-comment">//由val1和val2相加的结果可以推断出item的类型</span><br>&gt;<span class="hljs-keyword">auto</span> item = val1 + val2; <span class="hljs-comment">// item初始化为val1和val2相加的结果</span><br></code></pre></td></tr></table></figure><p>此处编译器将根据<code>val1</code>和 <code>val2</code>相加的结果来推断<code>item</code>的类型。如果<code>val1</code>和<code>val2</code>是类<code>sales_item</code>的对象，则<code>item </code>的类型就是<code>sales_item</code>;如果这两个变量的类型是<code>double</code>，则<code>item</code>的类型就是<code>double</code>，以此类推。</p></blockquote><hr><h2 id="复合类型，常量和auto"><a href="#复合类型，常量和auto" class="headerlink" title="复合类型，常量和auto"></a>复合类型，常量和auto</h2><blockquote><p>编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。</p><p>首先，正如我们所熟知的，使用引用其实是使用引用的对象，特别是当引用被用作初始值时,真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>,&amp;r = i;<br>&gt;<span class="hljs-keyword">auto</span> a = r;<br>&gt;<span class="hljs-comment">// a的类型为int(r是i的别名，而i是一个整数）</span><br></code></pre></td></tr></table></figure><p>其次，auto一般会忽略掉<code>顶层const</code>，同时<code>底层const</code>则会保留下来，比如当初始值是一个指向常量的指针时:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = i, &amp;cr = ci;<br>&gt;<span class="hljs-keyword">auto</span> b = ci;<span class="hljs-comment">// b的类型为int（ci的顶层const 特性被忽略掉了)</span><br>&gt;<span class="hljs-keyword">auto</span> c = cr;<span class="hljs-comment">// c的类型为int（ cr是ci的别名，ci本身是一个顶层const )</span><br>&gt;<span class="hljs-keyword">auto</span> d = &amp;i;<span class="hljs-comment">// d是一个整型指针(int *)</span><br>&gt;<span class="hljs-keyword">auto</span> e = &amp;ci;<span class="hljs-comment">// e是一个指向整数常量的指针（const int *）（对常量对象取完地址后，常量对象的顶层const在auto处转变为底层const)</span><br></code></pre></td></tr></table></figure><p>如果希望推断出的auto类型是一个<code>顶层const</code>，需要明确指出:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> f = ci;<span class="hljs-comment">// ci的推演类型是int，f是const int</span><br></code></pre></td></tr></table></figure><p>还可以将引用的类型设为auto，此时原来的初始化规则仍然适用:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">auto</span> &amp;g = ci;<span class="hljs-comment">// g是一个整型常量引用，绑定到ci</span><br>&gt;<span class="hljs-keyword">auto</span> &amp;h = <span class="hljs-number">42</span>;<span class="hljs-comment">//错误:不能为非常量引用绑定字面值(42的类型为int，左值引用不能绑定到右值)</span><br>&gt;<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;j=<span class="hljs-number">42</span>;<span class="hljs-comment">//正确:可以为常量引用绑定字面值（42发生临时物化，产生一个xvalue的临时对象让常量引用绑定）</span><br></code></pre></td></tr></table></figure><p>设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留。和往常一样，如果我们给初始值绑定一个引用(<code>auto &amp;g = ci;</code>)，则此时的const就不是<code>顶层const</code>了（g的类型为<code>const int &amp;</code>，此处的const为<code>底层const</code>）。<br>要在一条语句中定义多个变量，切记，符号<code>&amp;</code>和<code>*</code>只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">auto</span> k = ci, &amp;l = i;<span class="hljs-comment">// k是int，l是int&amp;</span><br>&gt;<span class="hljs-keyword">auto</span> &amp;m = ci,*p = &amp;ci;<span class="hljs-comment">// m是对整型常量的引用（const int &amp;），p是指向整型常量的指针（const int *）。</span><br>&gt;<span class="hljs-keyword">auto</span> &amp;n= i, *p2 = &amp;ci;<span class="hljs-comment">//错误:i的基本数据类型是int而&amp;ci的基本数据类型是const int</span><br></code></pre></td></tr></table></figure><p>以上部分为auto类型说明符的基础部分，大部分例子为《c++primer》p61页的，我在其基础上添加了注释以及对其进行部分修改，以便读者能快速领悟其含义。其他基础部分若有不懂请自行补充，不再赘述。</p></blockquote><hr><h2 id="进一步探讨auto类型说明符"><a href="#进一步探讨auto类型说明符" class="headerlink" title="进一步探讨auto类型说明符"></a>进一步探讨auto类型说明符</h2><blockquote><p>auto类型说明符可用于许多地方（主要是namespace作用域和local作用域），以从其初始化器推导变量的类型。在这种情况下，auto被称为占位符类型（<a href="https://en.cppreference.com/w/cpp/language/auto">a placeholder type</a>）(另一种占位符类型<code>deltype(auto)</code>，文章后面将会描述)。例如，您可以使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container&gt; <br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useContainer</span><span class="hljs-params">(Container <span class="hljs-type">const</span>&amp; container)</span> </span><br><span class="hljs-function">&gt;</span>&#123; <br><span class="hljs-keyword">auto</span> pos = container.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">//auto示例一</span><br><span class="hljs-keyword">while</span> (pos != &gt;container.<span class="hljs-built_in">end</span>()) <br>&#123; <br><span class="hljs-keyword">auto</span>&amp; element = *pos++; <span class="hljs-comment">//auto示例二</span><br>… <span class="hljs-comment">// operate on the element </span><br>&#125; <br>&gt;&#125;<br></code></pre></td></tr></table></figure><p>上面示例中auto的两种使用消除了编写两种长且可能复杂的类型，即容器的迭代器类型和迭代器的值类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">typename</span> Container::const_iterator pos = container.<span class="hljs-built_in">begin</span>();<br>…<br><span class="hljs-keyword">typename</span> std::iterator_traits&lt;<span class="hljs-keyword">typename</span> Container::iterator&gt;::reference element = *pos++;<br></code></pre></td></tr></table></figure><p>自动推导使用与模板参数推导相同的机制。auto类型说明符可以被一个虚构的模板类型参数<code>T</code>取代，然后推导继续进行，就好像该变量是一个函数形参，它的初始化器相当于函数实参。对于第一个auto示例，它对应于以下情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deducePos</span><span class="hljs-params">(T pos)</span></span>; <br>&gt;<span class="hljs-built_in">deducePos</span>(container.<span class="hljs-built_in">begin</span>());<br></code></pre></td></tr></table></figure><p>这里<code>T</code>看作<code>auto</code>，是要被推导出的类型。这样做的直接后果之一是，auto类型的变量永远不会是引用类型。<br>在第二个auto示例中使用<code>auto&amp;</code>说明了如何生成一个引用类型的推导。其推导相当于以下函数模板和调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-title">deduceElement</span><span class="hljs-params">(T&amp; element)</span></span>;<br>&gt;<span class="hljs-built_in">deduceElement</span>(*pos++);<br></code></pre></td></tr></table></figure><p>在这里，<code>element </code>总是引用类型，并且它的初始化器不能生成一个临时对象。</p></blockquote><hr><h3 id="auto与右值引用"><a href="#auto与右值引用" class="headerlink" title="auto与右值引用"></a>auto与右值引用</h3><blockquote><p>也可以将auto与右值引用组合起来，但这样做使其行为像一个转发的引用（a forwarding reference），例如：<br>auto&amp;&amp; fr &#x3D; …;<br>我们还是基于函数模板来看待它：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; fr)</span></span>;<span class="hljs-comment">// auto replaced by template parameter T</span><br></code></pre></td></tr></table></figure><p>解释如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-type">int</span> x; <br>&gt;<span class="hljs-keyword">auto</span>&amp;&amp; rr = <span class="hljs-number">42</span>; <span class="hljs-comment">// OK: rvalue reference binds to an rvalue </span><br>&gt;个(<span class="hljs-keyword">auto</span> = <span class="hljs-type">int</span>)<br>&gt;<span class="hljs-keyword">auto</span>&amp;&amp; lr = x; <span class="hljs-comment">// Also OK:reference collapsing makes. lr an lvalue reference</span><br>&gt;个(<span class="hljs-keyword">auto</span> = <span class="hljs-type">int</span>&amp;)<br></code></pre></td></tr></table></figure><p>这种技术经常用于代码中绑定函数或操作符调用的结果对象，且不知道结果对象的值类别(lvalue vs.rvarue)，进而不必复制该结果对象。<br>例如，它通常是在基于范围的循环中声明迭代值的首选方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container&gt; <br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(Container c)</span></span><br><span class="hljs-function">&gt;</span>&#123; <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;&amp; x: c) &#123; … &#125; <br>&gt;&#125;<br></code></pre></td></tr></table></figure><p>这里我们不知道容器迭代接口的签名( the signatures of the container’s iteration interfaces)，但是通过使用<code>auto&amp;&amp;</code>，我们可以确信我们正在遍历的值没有产生额外的副本。如果需要完美转发绑定值，则可以像往常一样在变量上调用<code>std::forward&lt;T&gt;()</code>。这使得一种“延迟”的完美转发成为可能。有关示例，请参见《c++ template 2nd》p167。<br>除了引用之外，还可以组合auto说明符来创建const对象、指针、成员指针等等，但auto必须声明成“main”类型说明符（基本数据类型）。它不能嵌套在模板参数中或跟在基本数据类型后面的声明部分中（ part of the declarator that follows the type specifier）。具体请看下面的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> &#123; T <span class="hljs-type">const</span> m; &#125;; <br>&gt;<span class="hljs-keyword">auto</span> <span class="hljs-type">const</span> N = <span class="hljs-number">400u</span>; <span class="hljs-comment">// OK: constant of type </span><br><br>&gt;<span class="hljs-keyword">auto</span>* gp = (<span class="hljs-type">void</span>*)<span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// OK: gp has type void* </span><br><br>&gt;X&lt;<span class="hljs-keyword">auto</span>&gt; xa = <span class="hljs-built_in">X</span>&lt;<span class="hljs-type">int</span>&gt;(); <span class="hljs-comment">// ERROR: auto in template </span><br><br>&gt;<span class="hljs-type">int</span> <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>::*pm2 = &amp;X&lt;<span class="hljs-type">int</span>&gt;::m; <span class="hljs-comment">// ERROR: auto is &gt;part of the “declarator”</span><br></code></pre></td></tr></table></figure><p>最后两个例子不让通过的原因在于C++委员会认为，额外的实施成本和滥用潜力超过了好处 :(。</p></blockquote><hr><h3 id="推导返回类型-c-14"><a href="#推导返回类型-c-14" class="headerlink" title="推导返回类型 c++14"></a>推导返回类型 c++14</h3><blockquote><p>C++14增加了另一种情况，其中可推导auto占位符类型可以出现在函数返回类型中。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;<br></code></pre></td></tr></table></figure><p>定义一个返回类型为int(42)的函数。这也可以使用后置返回类型的语法来表示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> -&gt; <span class="hljs-keyword">auto</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;<br></code></pre></td></tr></table></figure><p>在后一种情况下，第一个auto宣告有尾置返回类型，而第二个auto是要推导出的占位符类型。但是直接这么写会显得很冗长。<br>默认情况下，<code>lambda</code>也存在相同的机制：如果没有明确指定返回类型，则lambda的返回类型会像auto一样被推导出来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">auto</span> lm = [] (<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(x); &#125;; <br><span class="hljs-comment">// same as:auto lm = [] (int x) -&gt; auto &#123; return f(x); &#125;;</span><br></code></pre></td></tr></table></figure><p>函数可以单独声明。对于返回类型是被推导出来的函数也一样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// forward declaration </span><br>&gt;<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;<br></code></pre></td></tr></table></figure><p>但是，在这样的情况下，forward declaration的用途非常有限，因为该定义必须在使用该函数的任何地方都可见。也许令人惊讶的是，提供带有“resolved”返回类型的forward declaration是无效的。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">known</span><span class="hljs-params">()</span></span>; <br>&gt;<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">known</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125; <span class="hljs-comment">//ERROR: incompatible return type</span><br></code></pre></td></tr></table></figure><p>大多数情况下，提前声明一个具有推导返回类型的函数，只有在能够将成员函数定义移动到类定义之外时才有用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span> &#123; <br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// the definition will follow the class definition </span><br>&gt;&#125;;<br>&gt;<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">S::f</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;<br></code></pre></td></tr></table></figure></blockquote><hr><h3 id="可推导的非类型参数（Deducible-Nontype-Parameter）until-c-17"><a href="#可推导的非类型参数（Deducible-Nontype-Parameter）until-c-17" class="headerlink" title="可推导的非类型参数（Deducible Nontype Parameter）until c++17"></a>可推导的非类型参数（Deducible Nontype Parameter）until c++17</h3><blockquote><p>在C++17之前，非类型模板参数必须用特定的类型来声明。但是，该类型可以是一个模板参数类型。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, T V&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span>; <br>&gt;S&lt;<span class="hljs-type">int</span>, <span class="hljs-number">42</span>&gt;* ps;<br></code></pre></td></tr></table></figure><p>在本例中，必须指定非类型模板参数的类型，即在42之外指定int，可能非常繁琐。因此，C++17增加了声明非类型模板参数的能力，这些参数的实际类型是从相应的模板参数推导出来的。它们声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span> V&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span>;<br>&gt;S&lt;<span class="hljs-number">42</span>&gt;* ps;<span class="hljs-comment">//这样的话就简洁多了</span><br></code></pre></td></tr></table></figure><p>这里<code>S&lt;42&gt;</code>的V类型被推断为int，因为<code>42</code>的类型为<code>int</code>。如果我们写的是<code>S&lt;42u&gt;</code>，<code>V</code>的类型就会被推导为<code>无符号int</code>（《c++ template 2nd》p294）。<br>请注意，对非类型模板参数的类型的一般约束仍然有效。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;S&lt;<span class="hljs-number">3.14</span>&gt;* pd;<span class="hljs-comment">// ERROR: floating-point nontype argument</span><br></code></pre></td></tr></table></figure><p>最后auto只在c++17中被允许用在模板参数中，c++20开始被移除，原因是弊大于利，滥用它会让程序变得更难读懂。</p></blockquote><hr><h1 id="用decltype表示表达式的类型（Expressing-the-Type-of-an-Expression-with-decltype）"><a href="#用decltype表示表达式的类型（Expressing-the-Type-of-an-Expression-with-decltype）" class="headerlink" title="用decltype表示表达式的类型（Expressing the Type of an Expression with decltype）"></a>用decltype表示表达式的类型（Expressing the Type of an Expression with decltype）</h1><blockquote><p>虽然auto避免了写出变量的类型的需要，但它不容易允许人们使用该变量的类型(不能确定为某一指定类型)。deltype关键字解决了这个问题：它允许程序员表达表达式或声明的精确类型。但是，程序员应该小心decltype类型产生的<code>细微差别</code>，这取决于传递的参数是一个声明定义出的实体（eg：<code>int a;</code>&#x2F;&#x2F;这里a属于被定义出的实体）还是一个表达式（eg：<code>1+1;</code>&#x2F;&#x2F;这里1+1这个整体是一个表达式）：</p><ul><li>如果<code>e</code>是实体的名称（如变量、函数签名、枚举器或数据成员）或类成员访问过程，则<code>delltype(e)</code>生成该实体的声明类型或表示类成员的类型。因此，decltype类型可以用来检查变量的类型。<br> 当希望精确匹配现有声明的类型时，这一点很有用。例如，请考虑以下变量<code>y1</code>和<code>y2</code>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> x = …; <br><span class="hljs-keyword">auto</span> y1 = x + <span class="hljs-number">1</span>; <br><span class="hljs-keyword">decltype</span>(x) y2 = x + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>根据<code>x</code>的初始化器，<code>y1</code>可能具有也可能不具有与<code>x</code>相同的类型：它取决于<code>+</code>的行为。如果<code>x</code>被推导出为<code>int</code>，<code>y1</code>也会是<code>int</code>。如果<code>x</code>被推导为<code>char</code>，那么<code>y1</code>将是<code>int</code>，因为<code>char</code>与<code>1</code>的和是<code>int</code>。在<code>y2</code>类型中使用<code>deltype(x)</code>确保它始终具有与<code>x</code>相同的类型。</li></ul><h2 id="prvalue-xvalue和lvalue与decltype的关系："><a href="#prvalue-xvalue和lvalue与decltype的关系：" class="headerlink" title="prvalue,xvalue和lvalue与decltype的关系："></a>prvalue,xvalue和lvalue与decltype的关系：</h2><ul><li>如果<code>e</code>是任何其他表达式，则<code>deltype(e)</code>将生成一个反映该表达式的类型(type)和值类别(value category)，如下所示：<br>一 If e is an lvalue of type <code>T</code>, decltype(e) produces <code>T&amp;</code>.<br>一 If e is an xvalue of type <code>T</code>, decltype(e) produces <code>T&amp;&amp;</code>.<br>一 If e is a prvalue of type <code>T</code>, decltype(e) produces <code>T</code>.<br>参考《c++ template 2nd》的附录B可以了解更多value category的知识。</li></ul></blockquote><hr><blockquote><p>这种细微差别可以通过以下例子来证明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span> <span class="hljs-params">(std::string&amp;&amp; s)</span></span><br><span class="hljs-function">&gt;</span>&#123;<br><span class="hljs-comment">// check the type of s:</span><br>std::is_lvalue_reference&lt;<span class="hljs-keyword">decltype</span>(s)&gt;::value; <span class="hljs-comment">// false</span><br>std::is_rvalue_reference&lt;<span class="hljs-keyword">decltype</span>(s)&gt;::value; <span class="hljs-comment">// true (s as declared)</span><br>std::is_same&lt;<span class="hljs-keyword">decltype</span>(s),std::string&amp;&gt;::value; <span class="hljs-comment">// false</span><br>std::is_same&lt;<span class="hljs-keyword">decltype</span>(s),std::string&amp;&amp;&gt;::value; <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// check the value category of s used as expression:</span><br>std::is_lvalue_reference&lt;<span class="hljs-keyword">decltype</span>((s))&gt;::value; <span class="hljs-comment">// true (s is an lvalue)</span><br>std::is_rvalue_reference&lt;<span class="hljs-keyword">decltype</span>((s))&gt;::value; <span class="hljs-comment">// false</span><br>std::is_same&lt;<span class="hljs-keyword">decltype</span>((s)),std::string&amp;&gt;::value; <span class="hljs-comment">// true (T&amp; signals an lvalue)</span><br>std::is_same&lt;<span class="hljs-keyword">decltype</span>((s)),std::string&amp;&amp;&gt;::value; <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>在前四个表达式中，为变量<code>s</code>调用delctype：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">decltype</span>(s) <span class="hljs-comment">//declared type of entity e designated by s</span><br></code></pre></td></tr></table></figure><p>这意味着deltype产生了<code>s</code>的声明类型<code>std::sting&amp;&amp;</code>。在最后四个表达式中，decltype类型构造的操作数不仅仅是一个名称，因为在每种情况下，该表达式都是<code>(s)</code>，它是一个用括号表示的名称。在这种情况下，该类型将反映<code>(s)</code>的值类别：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">decltype</span>((s)) <span class="hljs-comment">//check the value category of (s)</span><br></code></pre></td></tr></table></figure><p>我们的表达式指的是一个变量，因此是一个<code>lvalue</code>：根据上面的规则，这意味着<code>decltype((s))</code>是对<code>std::string</code>的普通引用(lvalue reference)。这是C++中为数不多的用括号表示表达式会改变程序含义的地方之一，而不是影响操作符的关联性。<br>decltype类型计算任意表达式e的类型，这一事实在不同的地方都有帮助。具体来说，<code>deltype(e)</code>保留了关于表达式的足够信息，可以使它描述返回表达式<code>e</code>本身的函数的返回类型：deltype计算该表达式的类型，但它也将表达式的值类别传播给函数的调用者。例如，考虑一个简单的转发函数g()，它返回调用f()的结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;??? <span class="hljs-built_in">f</span>(); <br>&gt;<span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">f</span>()) <span class="hljs-built_in">g</span>() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(); <br>&#125;<br></code></pre></td></tr></table></figure><p><code>g()</code>的返回类型取决于<code>f()</code>的返回类型。如果<code>f()</code>返回<code>int&amp;</code>，那么计算<code>g()</code>的返回类型将首先确定表达式<code>f()</code>具有类型<code>int</code>。这个表达式是一个<code>lvalue</code>，因为<code>f()</code>返回一个左值引用，因此声明的返回类型变为<code>int&amp;</code>。类似地，如果<code>f()</code>的返回类型是右值引用类型，则调用<code>f()</code>将是<code>xvalue</code>，decltype将生成与<code>f()</code>返回的类型完全匹配的右值引用类型。本质上，这种形式的decltype类型采用了任意表达式的主要特征——它的类型和值类别——并以一种能够完美转发返回值的方式在类型系统中对它们进行编码。<br>当 value-producing <code>auto </code>的推导不足时，decltype也可能很有用。例如，假设我们有一个未知迭代器类型的变量<code>pos</code>，并且我们希望创建一个变量元素来引用<code>pos</code>存储的元素。我们可以使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">auto</span> element = *pos;<span class="hljs-comment">//这将始终有元素的副本产生。</span><br>&gt;<span class="hljs-keyword">auto</span>&amp; element = *pos;<span class="hljs-comment">//引用pos存储的元素！</span><br></code></pre></td></tr></table></figure><p>我们将总是会收到一个对元素的引用，但是如果迭代器的操作符 <code>* </code>返回一个值，那么程序将会失败。为了解决这个问题，我们可以使用decltype类型，以保持迭代器的运算符<code>*</code>的值或引用性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">decltype</span>(*pos) element = *pos;<br></code></pre></td></tr></table></figure><p>是使用内置类型解引用<code>pos</code>时<code>使用引用</code>（*pos表达式的结果为左值，则decltype推断出来的类型为左值引用！），是迭代器的操作符<code>*</code>返回一个值时<code>复制值</code>。它的主要缺陷是它需要将初始化器表达式写入两次：一次在decltype中（不计算它），另一次在实际的初始化器中。C++14引入了<code>decltype(auto)</code>来解决这个问题，我们接下来将讨论这个问题。</p></blockquote><hr><h1 id="decltype-auto-c-14"><a href="#decltype-auto-c-14" class="headerlink" title="decltype(auto) c++14"></a>decltype(auto) c++14</h1><blockquote><p>C++14增加了一个功能，它是auto和decltype的组合：<code>decltype(auto)</code>。与auto类型说明符一样，它是一个<code>占位符类型</code>，并且变量、返回类型或模板参数的类型是由相关表达式的类型(initializer, return value, or template argument)确定的。但是，与仅使用auto不同，它使用模板参数推断的规则来确定感兴趣的类型，实际的类型是通过将decltype直接应用于表达式来确定的。举例说明了这一点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-type">int</span> i = <span class="hljs-number">42</span>; <span class="hljs-comment">// i has type int</span><br>&gt;<span class="hljs-type">int</span> <span class="hljs-type">const</span>&amp; ref = i; <span class="hljs-comment">// ref has type int const&amp; and refers to i</span><br>&gt;<span class="hljs-keyword">auto</span> x = ref; <span class="hljs-comment">// x has type int and is a new independent object</span><br>&gt;<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) y = ref; <span class="hljs-comment">// y has type int const&amp; and also refers to i</span><br></code></pre></td></tr></table></figure><p><code>y</code>的类型是通过将decltype应用到初始化器表达式中得到的，这里是<code>ref</code>，它是<code>int const&amp;</code>。相比之下，auto类型推导的规则产生的则是类型<code>int</code>。<br>另一个示例显示了索引<code>std::vector</code>(索引出来的是一个lvalue《c++primer》p121)时的差异：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123; <span class="hljs-number">42</span> &#125;;<br>&gt;<span class="hljs-keyword">auto</span> x = v[<span class="hljs-number">0</span>]; <span class="hljs-comment">// x denotes a new object of type int</span><br>&gt;<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) y = v[<span class="hljs-number">0</span>]; <span class="hljs-comment">// y is a reference (type int&amp;)（Because [ ] operator produces an lvalue）</span><br></code></pre></td></tr></table></figure><p>这很好地解决了前面示例中的冗余写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">decltype</span>(*pos) element = *pos;<span class="hljs-comment">//Redundant writing</span><br>&gt;<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) element = *pos;<span class="hljs-comment">//which can now be rewritten as</span><br></code></pre></td></tr></table></figure><p>它通常用在返回类型上。参考以下示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapt</span><br>&gt;&#123;<br>C container;<br>…<br><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-keyword">operator</span>[] (std::<span class="hljs-type">size_t</span> idx) &#123;<br><span class="hljs-keyword">return</span> container[idx];<br>&#125;<br>&gt;&#125;;<br></code></pre></td></tr></table></figure><p>如果<code>container[idx] </code>生成一个<code>lvalue</code>，我们希望将该左值传递给调用者（他可能希望获取其地址或修改它）：这需要一个左值引用类型，这正是<code>decltype(auto)</code>解析到的类型。如果生成出来的是<code>prvalue</code>(内置下表运算符只可能产生<code>lvalue</code>和<code>xvalue</code>，这里说的是如果，原因在《<a href="https://blog.csdn.net/Howl_1/article/details/122625409">C++prvalue，xvalue和lvalue的相关知识</a>》中已阐述)，则引用类型将导致悬空引用(dangling references)，但幸运的是，<code>deltype(auto)</code>将生成这种情况下的对象类型（而不是引用类型）。</p><hr><h2 id="在递归模板中延迟返回类型推断（Delaying-return-type-deduction-in-recursive-templates）"><a href="#在递归模板中延迟返回类型推断（Delaying-return-type-deduction-in-recursive-templates）" class="headerlink" title="在递归模板中延迟返回类型推断（Delaying return type deduction in recursive templates）"></a>在递归模板中延迟返回类型推断（<a href="https://stackoverflow.com/questions/24109737/what-are-some-uses-of-decltypeauto#Delaying-return-type-deduction-in-recursive-templates">Delaying return type deduction in recursive templates</a>）</h2><p>当模板的返回类型被指定为<code>decltype(iter(Int&lt;i-1&gt;&#123;&#125;))</code>而不是<code>decltype(auto)</code>时，在模板实例化过程中会遇到无限递归。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> i&gt; <br>&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Int</span> &#123;&#125;;<br><br>&gt;<span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">iter</span><span class="hljs-params">(Int&lt;<span class="hljs-number">0</span>&gt;)</span> -&gt; Int&lt;0&gt;</span>;<span class="hljs-comment">//递归模板结束地方的声明</span><br><br>&gt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> i&gt;<span class="hljs-comment">//非类型参数（Nontype Parameter）《c++primer》p580</span><br>&gt;<span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">iter</span><span class="hljs-params">(Int&lt;i&gt;)</span> -&gt; <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">iter</span>(Int&lt;i<span class="hljs-number">-1</span>&gt;&#123;&#125;);<br>&gt;&#125;<br>&gt;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">iter</span>(Int&lt;<span class="hljs-number">10</span>&gt;&#123;&#125;)) a;<br>&gt;&#125;<br></code></pre></td></tr></table></figure><p>这里使用<code>decltype(auto)</code>来延迟返回类型模板实例化的推断,从而解决返回类型实例化过早引发无限递归的问题。</p><hr><p>与auto不同，<code>delltype(auto)</code>不允许修改其类型的说明符或声明符操作符。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>)* p = (<span class="hljs-type">void</span>*)<span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// invalid</span><br>&gt;<span class="hljs-type">int</span> <span class="hljs-type">const</span> N = <span class="hljs-number">100</span>;<br>&gt;<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-type">const</span> NN = N*N; <span class="hljs-comment">// invalid</span><br></code></pre></td></tr></table></figure><p>还要注意，初始化器中的圆括号可能很重要:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-type">int</span> x;<br>&gt;<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) z = x; <span class="hljs-comment">// object of type int</span><br>&gt;<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) r = (x); <span class="hljs-comment">// reference of type int&amp;</span><br></code></pre></td></tr></table></figure><p>这尤其意味着括号可能会严重影响<code>return statements</code>的有效性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>;<br>&gt;…<br>&gt;<span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> r = <span class="hljs-built_in">g</span>();<br><span class="hljs-keyword">return</span> (r); <span class="hljs-comment">// run-time ERROR: returns reference to temporary</span><br>&gt;&#125;<br></code></pre></td></tr></table></figure><p>until C++17，<code>decltype(auto)</code>也可以用于可推导的<code>非类型参数</code>，由于后面c++20将其剔除，所以这里就不继续深入探讨了，原因是一样，弊大于利，滥用将导致程序难以理解。</p></blockquote><hr><blockquote><p>最后问大家一个小问题，auto会不会计算出表达式结果的值？，decltype会不会计算出表达式结果的值？，decltype(auto)呢？相信大家看完本篇文章后，这些问题就会不攻自破了 :) 。如果本篇文章帮您解决了理论上难以理解的问题，记得点个赞哦！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>用反汇编分析c++RVO开启和关闭时的底层原理以及C++prvalue，xvalue和lvalue的相关知识</title>
    <link href="/2022/01/28/00004.%20%E7%94%A8%E5%8F%8D%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90c++RVO%E5%BC%80%E5%90%AF%E5%92%8C%E5%85%B3%E9%97%AD%E6%97%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8AC++prvalue%EF%BC%8Cxvalue%E5%92%8Clvalue%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/01/28/00004.%20%E7%94%A8%E5%8F%8D%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90c++RVO%E5%BC%80%E5%90%AF%E5%92%8C%E5%85%B3%E9%97%AD%E6%97%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8AC++prvalue%EF%BC%8Cxvalue%E5%92%8Clvalue%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p><strong>本篇文章为笔者的读书笔记，未经允许请勿转载。</strong><br>本篇文章主要讲述C++prvalue，xvalue和lvalue的相关知识，会用到部分intel式和ATT式汇编的知识。我会在文章末尾给出测试代码的反汇编代码以及右值引用（Rvalue references）官方文档 :)。</p></blockquote><hr><h1 id="三五法则"><a href="#三五法则" class="headerlink" title="三五法则"></a>三五法则</h1><blockquote><p>三五法则：有析构就应该有拷贝构造函数和拷贝赋值运算法（3）。<br>c++11下，一个类还可以有移动构造函数和移动赋值运算符（3+2）。<br>三五法则时候一般情况，如果不想某个函数被普通或者友元使用可以将其定义为&#x3D;delete或者在private里面声明但不定义，具体参考C++ primer p449。<br>移动函数的出现提高了类内存转让的效率，而支承这一技术的基础就是prvalue,xvalue,lvalue.<br>(xvalue和prvalue统称为rvalue，lvalue和xvalue统称为glvalue。只需要记住上面说的三种就可以，这两个统称可以不用记)。<br>这三种值的出现场合和特点在后文详细说明。</p></blockquote><hr><h1 id="未开启RVO优化与xvalue和prvalue的关系"><a href="#未开启RVO优化与xvalue和prvalue的关系" class="headerlink" title="未开启RVO优化与xvalue和prvalue的关系"></a>未开启RVO优化与xvalue和prvalue的关系</h1><blockquote><p>关闭RVO的方法:<br>eg:<code>clang++ -g -fno-elide-constructors /home/dengye/test/test.cpp -o /home/dengye/test/test</code><br>先设计一个三五法则的类，再分析关闭和开启RVO时程序的堆栈分布图。<br>废话不多说开整！</p></blockquote><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> val=<span class="hljs-number">0</span>):<span class="hljs-built_in">bVal</span>(val)&#123;&#125;<br>    <span class="hljs-comment">// B(const B&amp; tmp):bVal(tmp.bVal)&#123;&#125;</span><br>    ~<span class="hljs-built_in">B</span>()&#123;&#125;<br>    <span class="hljs-type">int</span> bVal;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>):<span class="hljs-built_in">ptrb</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>(tmp))<br>    &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;构造函数&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-type">const</span> Foo&amp; src):<span class="hljs-built_in">ptrb</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>(*(src.ptrb)))<span class="hljs-comment">//会继续调用B的拷贝构造函数</span><br>    &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;拷贝构造函数&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br>    Foo&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Foo&amp; src)<br>    &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;拷贝赋值函数&quot;</span>&lt;&lt;std::endl;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;src)<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//防止自己给自己赋值。</span><br>        <span class="hljs-keyword">delete</span> ptrb;<span class="hljs-comment">//先把自己的这块内存干掉</span><br>        ptrb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>(*(src.ptrb));<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    <br>    &#125;<br>    <span class="hljs-built_in">Foo</span>(Foo&amp;&amp; src) <span class="hljs-keyword">noexcept</span> :<span class="hljs-built_in">ptrb</span>(src.ptrb)<span class="hljs-comment">//noexcept:通知标准库我们这个移动构造函数不抛出任何异常（如果编译器确认函数不会抛出异常，它就能执行某些特殊的优化操作，而这些操作不适合用于可能出错的代码），例如我们希望在vector重新分配内存这类情况下对我们自定义类型的对象进行移动而不是拷贝，就必须显式地告诉标准库我们的移动构造函数可以安全使用。《c++primer》p474，690。</span><br>    &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;移动构造函数&quot;</span>&lt;&lt;std::endl;        <br>        src.ptrb = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//记得将原来指向堆内存的指针置空.</span><br>    &#125;<br>    Foo&amp; <span class="hljs-keyword">operator</span>=(Foo&amp;&amp; src) <span class="hljs-keyword">noexcept</span><br>    &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;移动赋值函数&quot;</span>&lt;&lt;std::endl;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;src)<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">delete</span> ptrb;<br>        ptrb = src.ptrb;<span class="hljs-comment">//这里不需要在new，直接从src那里拿来</span><br>        src.ptrb = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//记得置空</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">Foo</span>()<br>    &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;析构函数&quot;</span>&lt;&lt;std::endl;<br>        <span class="hljs-keyword">delete</span> ptrb;<span class="hljs-comment">//删一个空指针没任何反应</span><br>    &#125;<br>    B *ptrb;<br>&#125;;<br><span class="hljs-function">Foo <span class="hljs-title">RVO_test</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Foo <span class="hljs-title">foo</span><span class="hljs-params">(val)</span></span>;<br>    <span class="hljs-keyword">return</span> foo;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Foo fooRvo = <span class="hljs-built_in">RVO_test</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在分析之前我先把该程序的内存分布图画出来帮大家理解，见下图：</p></blockquote><h2 id="像这种random-offset的出现，就是为了避免溢出攻击。画这张图要用到nm命令（寻找代码段，bss段和data段的起始地址），gdb的vmmap命令（寻找堆栈的起始和结束地址）。灰色部分表示这些范围在进程虚拟地址空间中不可用，也就是说，没有为这些区域创建页表（page-table）。"><a href="#像这种random-offset的出现，就是为了避免溢出攻击。画这张图要用到nm命令（寻找代码段，bss段和data段的起始地址），gdb的vmmap命令（寻找堆栈的起始和结束地址）。灰色部分表示这些范围在进程虚拟地址空间中不可用，也就是说，没有为这些区域创建页表（page-table）。" class="headerlink" title="&gt;像这种random offset的出现，就是为了避免溢出攻击。画这张图要用到nm命令（寻找代码段，bss段和data段的起始地址），gdb的vmmap命令（寻找堆栈的起始和结束地址）。灰色部分表示这些范围在进程虚拟地址空间中不可用，也就是说，没有为这些区域创建页表（page table）。"></a><img src="/img%5C00004%5C1.png" alt="在这里插入图片描述"><br>&gt;像这种random offset的出现，就是为了避免溢出攻击。画这张图要用到<code>nm</code>命令（寻找代码段，bss段和data段的起始地址），gdb的<code>vmmap</code>命令（寻找堆栈的起始和结束地址）。灰色部分表示这些范围在进程虚拟地址空间中不可用，也就是说，没有为这些区域创建页表（page table）。</h2><h2 id="反汇编配合堆栈图分析流程"><a href="#反汇编配合堆栈图分析流程" class="headerlink" title="反汇编配合堆栈图分析流程"></a>反汇编配合堆栈图分析流程</h2><p><strong>友情提醒：请配合附件中的反汇编代码进行分析。</strong><br><img src="/img%5C00004%5C2.png" alt="在这里插入图片描述"><br><img src="/img%5C00004%5C3.png" alt="在这里插入图片描述"></p><blockquote><p>到达这一步以前发生的事情有：main函数开辟出了0x20字节的空间，将rbp-0x18的地址（临时对象prvalue）给了rdi，然后将0x64给了esi，接着调用了RVO_test(int)函数，还没push rbp。</p></blockquote><hr><p><img src="/img%5C00004%5C4.png" alt="在这里插入图片描述"></p><p><img src="/img%5C00004%5C5.png" alt="在这里插入图片描述"></p><blockquote><p>到达这一步以前发生的事情有：RVO_test(int)函数开辟了0x30字节的空间，rdi寄存器存着临时对象prvalue的地址，然后将其赋给了rbp-0x8，rbp-0x20，rbp-0x28，又将0x64赋给了rbp-0xc（形参val），最后在临时对象foo的地址上进行了构造。</p></blockquote><hr><p><img src="/img%5C00004%5C6.png" alt="在这里插入图片描述"></p><p><img src="/img%5C00004%5C7.png" alt="在这里插入图片描述"></p><blockquote><p>到达这一步以前发生的事情有：编译器将rbp-0x18（局部对象foo）的内容移动到了临时对象的里面。此时局部对象的指针数据成员指向空，在RVO_test(int)函数返回时，会析构这个局部对象，而delete一个空指针没任何反应。最后RVO_test(int)函数将rbp-0x28地址上的内容赋给rax作为返回值。</p></blockquote><hr><p><img src="/img%5C00004%5C8.png" alt="在这里插入图片描述"></p><p><img src="/img%5C00004%5C9.png" alt="在这里插入图片描述"></p><blockquote><p>到达这一步以前发生的事情有：RVO_test(int)函数回收了0x30字节的空间，pop rbp时会将保存的main函数的rbp地址取出来放到rbp栈基址寄存器里面，同时rsp会+8，指向要跳转的代码段。最后一步没执行，不难看出ret是让rip指令寄存器指向rsp的内容，即跳转到&lt;main+29&gt;。</p></blockquote><hr><p><img src="/img%5C00004%5C10.png" alt="在这里插入图片描述"></p><p><img src="/img%5C00004%5C11.png" alt="在这里插入图片描述"></p><blockquote><p>到达这一步以前发生的事情有：临时对象的内容被移动赋值函数转移到了main函数的局部对象fooRvo。然后临时对象就被析构了，接着main函数将返回值0赋给rbp-0x4所指的空间，最后fooRvo对象也被析构。程序随之结束。</p></blockquote><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote><p>无RVO返回优化，编译器会生成一个prvalue或者xvalue的<a href="https://en.cppreference.com/w/cpp/language/implicit_conversion">临时对象（Temporary materialization）</a>（《深度探索c++对象模型》p267），取决于prvalue是否出现在丢弃值表达式（<a href="https://en.cppreference.com/w/cpp/language/expressions#Discarded-value_expressions">Discarded-value expressions</a>）里。像这样写<code>Foo fooRvo = RVO_test(100);</code>RVO_test(100)产生的临时对象就是prvalue，这种prvalue被称为”有一个结果对象”（<a href="https://en.cppreference.com/w/cpp/language/value_category">such prvalue is said to have a result object</a>）。而这样写<code>Foo fooRvo;fooRvo = RVO_test(100);</code>RVO_test(100)产生的临时对象就是xvalue，原因就是prvalue出现在了丢弃值表达式里。这种表达式包括了任何完整表达式语句（<a href="https://en.cppreference.com/w/cpp/language/expressions#Discarded-value_expressions">Such expressions include the full expression of any expression statement</a>）。然后临时对象的地址会被传入到RVO_test(int)函数中，该函数中的局部对象foo在返回时触发移动构造函数将foo的内存转让给临时对象。为什么会触发移动构造函数呢？归功于return语句，一个拷贝操作发生在return语句时，会被忽略或者被对待成rvalue，目的在于选择一个重载后的构造函数（Note:A copy operation associated with a return statement may be elided or considered as an rvalue for the purpose of overload resolution in selecting a constructor (12.8). —end note,本句子出自<a href="https://en.cppreference.com/w/cpp/compiler_support/11">c++标准手册文档-N2118的6.6.3 - The return statement</a>）。由于右值引用可以接受一个rvalue，这个被return转化后的rvalue选择了移动构造函数。至此临时对象被构造出来，RVO_test(int)函数的局部对象foo被析构。而临时对象prvalue，由于赋值运算符的存在，会去调用移动构造函数，（细心的小伙伴肯定要问为啥不是调用重载后的移动赋值函数，很简单！赋值运算符在定义处表现出来的形式为构造而不是拷贝）。待main函数中的fooRvo对象被构造出来后，临时对象也被析构。最后fooRvo对象被析构。<br>.<br>这是clang编译器下运行完代码的结果:<br><img src="/img%5C00004%5C12.png" alt="这是运行完代码的结果"></p><p>注意：MSVC编译有接住这个民间概念，也就说<code>Foo fooRvo = RVO_test(100);</code>这条语句中，RVO_test产生的临时对象会被fooRvo对象接住，从而不执行对临时对象的析构。或者说fooRvo的空间和临时对象的空间合二为一了。我平时写代码都是用的clang编译器，以前刚开始学c++是在MSVC所以这里就稍微提及一下MSVC的不同之处。<br>.<br>这是MSVC编译器下运行完代码的结果：<br><img src="/img%5C00004%5C13.png" alt="在这里插入图片描述"></p></blockquote><hr><h1 id="开启RVO优化"><a href="#开启RVO优化" class="headerlink" title="开启RVO优化"></a>开启RVO优化</h1><blockquote><p>代码还是用上面的代码</p></blockquote><p><img src="/img%5C00004%5C14.png" alt="在这里插入图片描述"><br><img src="/img%5C00004%5C15.png" alt="在这里插入图片描述"></p><blockquote><p>上面已经带着大家分析过一遍了，这里就直接跳到最后看结果。<br>对比关闭RVO来说，RVO_test(int)函数的局部对象就是直接构造到fooRvo对象里面去了，中间一个移动构造都没有。通过分析反汇编代码不难发现，它为了优化返回局部对象，直接让fooRvo对象的内存接管了局部对象foo的，可以说是合二为一了。但是有一个问题，局部对象foo一定要执行析构函数呀！别急，它这里妙手回春一手，将一字节的标志位放在了RVO_test(int)函数的栈帧中，然后通过判断标志位跳过对局部对象foo的析构函数执行。这玩意儿有点像加了if的goto :)。<br>.<br>这是clang编译器下运行完代码的结果:<br><img src="/img%5C00004%5C16.png" alt="在这里插入图片描述"><br>有关临时对象的认识可以参考《深度探索c++对象模型》p267</p></blockquote><hr><h1 id="xvalue-prvalue和lvalue"><a href="#xvalue-prvalue和lvalue" class="headerlink" title="xvalue,prvalue和lvalue"></a>xvalue,prvalue和lvalue</h1><blockquote><p>这里笔者就帮大家把坑填上，相信大家对上面测试代码分析过后会对prvalue和xvalue有个初步的印象，即函数返回时可能会涉及到它们。<br>对于这三种值的概述：<br>每一个c++的表达式（作用在运算对象上的重载操作符，字面常量，一个变量名，”a &#x3D; b”（an assignment expression），etc.）都会有两个独立的属性：一种类型，一个值的类别。每个表达式都有一些非引用类型，并且每个表达式都恰好属于三个主要值类别中的一个:prvalue、xvalue和lvalue。这三种值没有一个确切的定义，或者说你要废很大功夫去定义它们，亦或者描述个大概即可。<br>下面我们来看这三种值类型的概要定义以及特性（完整请参考<a href="https://en.cppreference.com/w/cpp/language/value_category">Value categories</a>）：<br>（补充一句，检测表达式的值类别的相关代码，我放在了附录中，感兴趣的读者可以自行验证感到疑惑的地方）</p></blockquote><ul><li>lvalue<blockquote><p>lvalue：所谓左值，从历史的角度来考虑，它可以出现在一个赋值表达式的左边。资源可以被重用（resources can be reused）。有空间地址但不能被移动</p><ul><li>一般有名字，除了 unamed lvalue（<code>*ptr </code>是一个没有名字的lvalue，一个返回值为lvalue reference的函数调用表达式也是没名字的lvalue），如果有单独的一个 identifier 来表示它，它一定是 lvalue</li><li>可以用 &amp; 符号取其地址，除了bit field（<a href="https://en.cppreference.com/w/cpp/language/bit_field">The type of a bit field can only be integral or enumeration type.</a>）</li><li>一个函数或者重载操作符的返回值为lvalue reference<br>例如 <code>std::getline(std::cin, str) or std::cout &lt;&lt; 1 or str1 = str2 or ++iter</code></li><li>其生命周期为其所在的 scope</li><li>一些内置操作符表达式<br>内置前自增自减，解引用，内置下标表达式（<code>a[n]</code>是一个lvalue的情况下），类类型的内置成员访问表达式（除了访问枚举数据成员和非静态成员函数，还有一些特例请参考<a href="https://en.cppreference.com/w/cpp/language/value_category">Primary categories</a>），逗号表达式（最右边的操作数为lvalue的情况下），三元条件表达式（第二个和第三个操作数为lvalue的情况下）</li><li>将表达式强制转换为左值引用类型和右值引用函数署名类型（<a href="https://en.cppreference.com/book/intro/functions">The signature of a function</a>）<br>例如 <code>static_cast&lt;int&amp;&gt;(x)</code><br>例如 <code>static_cast&lt;void (&amp;&amp;)(int)&gt;(x)</code></li><li>在所有 literal 中，只有 string literal 是 lvalue：<code>cout &lt;&lt; &amp;&quot;dy&quot; &lt;&lt; endl</code>;（其他 literal 是 rvalue：<code>cout &lt;&lt; &amp;&#39;d&#39; &lt;&lt; endl</code>; 非法）</li></ul><h2 id="lvalue的特性："><a href="#lvalue的特性：" class="headerlink" title="lvalue的特性："></a>lvalue的特性：</h2></blockquote></li></ul><blockquote><ul><li>可以通过取址运算符获取其地址，<code>&amp;++i[1]</code> and <code>&amp;std::endl </code>像这样的表达式都是合法的</li><li>可修改的左值可用作内置赋值和<a href="https://en.cppreference.com/w/cpp/language/operator_assignment#Builtin_compound_assignment">内置复合赋值运算</a>符的左操作数</li><li>可以用来初始化左值引用，这个左值引用将是lvalue的别名。</li><li>lvalue可以被隐式地转换为prvalue就像lvalue-to-rvalue, array-to-pointer, or function-to-pointer的隐式转换。（<code>int ival1 = 1;int ival2 = -ival1;</code>，这里减号可以lvalue隐式转换成prvalue）</li><li>可以是多态的（<a href="https://en.cppreference.com/w/cpp/language/object#Polymorphic_objects">Polymorphic</a>），它所对应的<a href="https://en.cppreference.com/w/cpp/language/type#Dynamic_type">动态类型</a>和静态类型可以不一样，例如：一个指向子类的父类指针</li><li>可以是<a href="https://en.cppreference.com/w/cpp/language/type#Incomplete_type">不完整类型</a>，只要表达式允许。例如：由前置声明但未定义的类类型</li></ul></blockquote><ul><li>xvalue<blockquote><p>xvalue：一个将要到期的值（生命周期被延长），资源可以被重用的对象。有空间地址可以被移动。</p><ul><li>一个函数调用或者重载操作符函数表达式的返回值为rvalue reference<br>例如 <code>std::move(x)</code>；</li><li>将表达式的类型强制转换为右值引用类型。<br>例如<code>(int&amp;&amp;)a</code>，<code>static_cast&lt;int&amp;&amp;&gt;(a)</code>。</li><li>内置下标表达式（<code>a[n]</code>为一个xvalue的情况下）。</li><li>类类型的内置成员访问表达式。<br>例如<code>a.m</code>是一个 xvalue，a是xvalue，m是非引用类型的非静态数据成员。<br>以及 <code>a.*mp </code>是一个 xvalue。a是xvalue，mp 叫做 pointer to data member（《c++primer》p739）。</li><li>三元条件表达式（第二个和第三个操作数为xvalue的情况下）</li><li>指定临时对象的任何表达式（除了prvalue initializes an object的情况）(since C++17)<h2 id="xvalue的特性："><a href="#xvalue的特性：" class="headerlink" title="xvalue的特性："></a>xvalue的特性：</h2></li></ul></blockquote></li></ul><blockquote><ul><li>可以被绑定到右值引用和const左值引用，同时生命周期被延长到这个引用的作用域结束</li><li>xvalue可以具有多态性（<a href="https://en.cppreference.com/w/cpp/language/object#Polymorphic_objects">Polymorphic</a>）</li><li>非类类型的xvalue可以被const和volatile修饰（<a href="https://en.cppreference.com/w/cpp/language/cv">cv type qualifiers</a>）</li><li>xvalue可以被隐式地转换为prvalue就像lvalue-to-rvalue, array-to-pointer, or function-to-pointer的隐式转换<br>（<code>int ival = 1;if((int&amp;&amp;)ival)&#123;putchar(&#39;Y&#39;);&#125;</code>xvalue被隐式转换成了prvalue）</li><li>可以是不完整类型</li><li>不能被取地址（通过内置取地址运算符）</li><li>不能是内置赋值和<a href="https://en.cppreference.com/w/cpp/language/operator_assignment#Builtin_compound_assignment">内置复合赋值运算</a>符的左操作数</li><li>当作用在函数参数时，有两个函数重载都可用，一个是右值引用参数，另一个是const左值引用参数，一个xrvalue会绑定到参数为右值引用的重载函数上（因此，拷贝和移动构造函数都存在时，一个xrvalue会去调用移动构造而不是拷贝构造，同理作用于拷贝和移动赋值运算符）</li></ul></blockquote><ul><li>prvalue<blockquote><p>prvalue：一个将要消亡的值（生命周期马上结束），资源不可以被重用（想要被重用必须转化成xvalue）的对象。一部分有空间地址但马上就会被回收（空间地址可以被后面的新数据覆盖），一部分没有空间地址。可以被移动。</p><ul><li>所有 literals：bool literal (例如<code> true</code>)，integer literal (例如 <code>42</code>) 等等（无空间地址）。</li><li>实质上的函数调用：(<strong>return non-reference</strong>)（有空间地址）<br><code>f() </code>function call<br><img src="/img%5C00004%5C17.png" alt="在这里插入图片描述"></li></ul><p><code>a.f() </code>static or non-static member function<br><code>A()</code> 包括各种构造函数<br><code>str1 + str2</code> 重载 operator 也相当于函数调用<br><code>functor()</code> (对应 operator() 重载)<br><code>[]&#123;&#125;() </code>lambda (对应 operator() 重载)</p><ul><li>一些内置操作符产生的运算结果（无空间地址）：<br><code>a++</code> 自增自减<br><code>a+b</code> 加减乘除<br><code>a&amp;b</code> 位运算<br><code>a&amp;&amp;b</code> 逻辑运算<br><code>a&lt;b</code> 关系运算<br><code>&amp;a</code> 取地址<br><code>a, b</code> comma expression (如果b 是 rvalue)<br><code>(int)a</code> 或 static_cast&lt; int&gt;(a) 强制类型转换<br><code>a ? b : c </code>（第二个和第三个操作数为rvalue的情况下）</li><li>enumerator 枚举值（无空间地址）：<br><code>enum &#123; yes, no &#125;;</code> 中的 yes, no<br><code>a.m</code> 或 <code>p-&gt;m</code>，其中 m 是 member enumerator</li><li>普通成员函数本身（<a href="https://en.cppreference.com/book/intro/functions">The signature of a function</a>）（无空间地址）<br><code>a.m</code> 或 <code>p-&gt;m</code> 或 <code>a.*pm</code> 或 <code>p-&gt;*pm</code>，其中 m 和 pm 都对应普通成员函数(non-static)</li><li>this 指针（有空间地址）<br>被当做参数传进去放在栈帧上。<h2 id="prvalue的特性："><a href="#prvalue的特性：" class="headerlink" title="prvalue的特性："></a>prvalue的特性：</h2></li><li>不会是多态的</li><li>非类非数组的prvalue不能被cv-qualified修饰，除非它为了被绑定到一个cv-qualified的引用类型上而转换化成xvalue (since C++17)，      例如 ：<code>const int&amp; i = 1；</code>(注意：一个函数调用或者强制类型转换表达式会导致生成一个非类cv-qualified类型，但是cv-qualifier通常会立即被剥离。)</li><li>prvalue不能有不完整的类型（使用decltype指示符时也不能有，除了void）</li><li>prvalue不能有抽象类类型或者an array thereof（不太懂官方要表达的意思，所以就以英文方式放在这里供大家参考）:(</li><li>不能被取地址（通过内置取地址运算符）</li><li>不能是内置赋值和<a href="https://en.cppreference.com/w/cpp/language/operator_assignment#Builtin_compound_assignment">内置复合赋值运算</a>符的左操作数</li><li>当作用在函数参数时，有两个函数重载都可用，一个是右值引用参数，另一个是const左值引用参数，一个prvalue会绑定到参数为右值引用的重载函数上（因此，拷贝和移动构造函数都存在时，一个prvalue会去调用移动构造而不是拷贝构造，同理作用于拷贝和移动赋值运算符）</li></ul></blockquote></li></ul><hr><h1 id="Temporary-materialization"><a href="#Temporary-materialization" class="headerlink" title="Temporary materialization"></a>Temporary materialization</h1><blockquote><p>经过对xvalue,prvalue和lvalue对认识后，咱们来聊聊临时对象，除了xvalue可以被称为临时对象，prvalue在某些情况下也可以被称为临时对象。从一个任何完整类型T的prvalue转换为相同类型T的xvalue的过程被称为临时物化（Temporary materialization）。该转换将prvalue作为其结果对象求值，从而将prvalue初始化为T类型的临时对象，并生成一个表示临时对象的xvalue(since C++17)。如果T是一个类或者类类型的数组，它必须具有可访问且未删除的析构函数。<br>Temporary materialization 会发生在下列情况中：**(since C++17)**</p><ul><li>绑定作用于prvalue时<br><code>int&amp;&amp; c = 1;const int&amp; c = 1;</code>c绑定的是一个xvalue</li><li>在一个prvalue类上使用成员访问运算符时<br><code>A().m; </code>pvalue A() 自动变成一个 xvlaue<br><code>A().*mp;</code> pvalue A() 自动变成一个 xvlaue</li><li>prvalue数组转变成一个指针或被绑定时，或者用下标访问一个prvalue数组<br>1.prvalue数组被绑定时<br><code>int (&amp;&amp; a)[2] = (int[])&#123;1, 2&#125;;</code><br>2.prvalue数组转变成一个指针时<br><code>[](int* iptr)&#123;std::cout&lt;&lt;*iptr;&#125;((int[])&#123;1,2&#125;);</code><br>对于一个对象或者一个表达式，如果可以对其使用调用运算符，则称它为可调用对象(《c++primer》p345)<br>3.用下标访问一个prvalue数组时<br><code>((int[])&#123;1, 2&#125;)[0];</code></li><li>当从带括号的列表初始化初始化std::initializer_list<T>类型的对象时;<br>《c++primer》p197</li><li>   typid作用于一个prvalue时<br>《c++primer》p732</li><li>sizeof作用于一个prvalue时</li><li>当一个prvalue出现在丢弃值表达式（<a href="https://en.cppreference.com/w/cpp/language/expressions#Discarded-value_expressions">Discarded-value expressions</a>）<br>上文研究开启RVO时讲过。</li><li>注意：当从相同类型的prvalue初始化一个对象时(通过直接初始化或复制初始化)不会发生临时物化:这样的对象是直接从初始化器初始化的。这确保了“拷贝副本的省略(RVO的工作机制)”。（上文研究开启RVO时讲过，prvalue可以用来初始化一个对象，这种prvalue被称为”有一个结果对象”（<a href="https://en.cppreference.com/w/cpp/language/value_category">such prvalue is said to have a result object</a>））<br><img src="/img%5C00004%5C18.png" alt="在这里插入图片描述"></li></ul><p>重要的事情说三遍！<br>从一个任何完整类型T的prvalue转换为相同类型T的xvalue的过程被称为临时物化<br>从一个任何完整类型T的prvalue转换为相同类型T的xvalue的过程被称为临时物化<br>从一个任何完整类型T的prvalue转换为相同类型T的xvalue的过程被称为临时物化</p></blockquote><hr><h1 id="引用折叠（万能引用，引用塌缩）"><a href="#引用折叠（万能引用，引用塌缩）" class="headerlink" title="引用折叠（万能引用，引用塌缩）"></a>引用折叠（万能引用，引用塌缩）</h1><blockquote><p>上面说过移动操作的出现提高了类内存转让的效率，而支承这一技术的基础就是prvalue,xvalue,lvalue。但右值引用才是移动操作能实现的根本原因。这里咱们好好讲一讲右值引用的相关知识引用折叠（关于右值引用的基础知识请参看《c++primer》p471这里不多赘述）。<br>引用折叠的两个规则被称为C++语言在正常绑定规则之外定义的两个例外规则，允许这种绑定。而这两个例外规则是move这种标准模板库设施正确工作的基础。<br>先介绍一下它的两个规则：</p><ul><li>.规则一：对于一个给定类型<code>T</code>，当我们将一个左值传给模板函数的右值引用参数时，编译器推断模板类型参数T为左值引用类型（T&amp;），例如对于<code>int</code>类型的左值时，推断<code>T</code>为<code>int&amp;</code>；当我们将一个右值传进去时，<code>T</code>被推断出来的类型为<code>T</code>，例如对于<code>int</code>类型的右值时，推断<code>T</code>为<code>int</code>。</li><li>例外规则二：如果我们间接创建了一个引用的引用，则这些引用形成了引用折叠。正常情况下，不能直接创建引用的引用，但是可以间接创建（如类型别名和模板参数）。大部分情况下，引用的引用会折叠为普通的左值引用（T&amp; &amp;、T&amp; &amp;&amp;、 T&amp;&amp; &amp;都会折叠成类型T&amp;），右值引用和右值引用，则折叠成右值引用（T&amp;&amp; &amp;&amp;折叠成T&amp;&amp;）。《c++primer》p608</li></ul></blockquote><hr><h2 id="对上面两个规则熟练后，我们来分析一下标准库move函数"><a href="#对上面两个规则熟练后，我们来分析一下标准库move函数" class="headerlink" title="对上面两个规则熟练后，我们来分析一下标准库move函数:"></a>对上面两个规则熟练后，我们来分析一下标准库move函数:</h2><blockquote><p>虽然不能直接将一个右值引用绑定到一个左值上，但可以用move获得一个绑定到左值上的xvalue。由于move本质上可以接受任何类型的实参，因此我们不会惊讶于他一个函数模板。</p><ul><li>std::move是如何定义的<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>&gt;<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp;<br>&gt;<span class="hljs-built_in">move</span>(T&amp;&amp; t) <span class="hljs-keyword">noexcept</span><br>&gt;&#123; <br>&gt;<span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t); <br>&gt;&#125;<br></code></pre></td></tr></table></figure>在返回类型和类型转换中也要用到<code>typename</code>（《c++primer》p593）。<code>std::remove_reference&lt;T&gt;::type</code>的用处就是去除类型的引用（《c++primer》p605）。<code>static_cast</code>静态类型转换（《c++primer》p145）。</li><li>std::move是如何工作的</li></ul><p>这段代码很短，但其中有些微妙之处。首先，move的函数参数<code>T&amp;&amp;</code>是一个指向模板类型参数的右值引用。通过引用折叠，此参数可以与任何类型的实参匹配。特别是，我们既可以传递给move一个左值，也可以传递给它一个右值:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-function">string <span class="hljs-title">s1</span> <span class="hljs-params">( <span class="hljs-string">&quot;hi! &quot;</span>)</span>,s2</span>;<br>&gt;s2 = std::<span class="hljs-built_in">move</span> (<span class="hljs-built_in">string</span> ( <span class="hljs-string">&quot;bye!&quot;</span>) );<span class="hljs-comment">//正确:从一个右值移动数据</span><br>&gt;s2 = std::<span class="hljs-built_in">move</span>(s1);<span class="hljs-comment">//正确:但在赋值之后，s1的值是不确定的(内容被移动赋值运算符移动过)。</span><br></code></pre></td></tr></table></figure><p>在第一个赋值中，传递给move的实参是string的构造函数的右值结果。在<code>std::move(string(&quot;bye!&quot;))</code>中:</p><ol><li>推断出的T的类型为string。</li><li>因此remove_reference用string进行实例化。</li><li>remove_reference<string>的type成员是string。</li><li>move的返回类型是string&amp;&amp;。</li><li>move的函数参数t的类型为string&amp;&amp;。</li></ol><p>因此，这个调用实例化move<string>，即函数<br><code>string&amp;&amp; move(string &amp;&amp;t)</code></p><p>函数体返回<code>static_cast&lt;string&amp;&amp;&gt;(t)</code>。<code>t</code>的类型已经是<code>string&amp;&amp;</code>,于是类型转换什么都不做。因此，此调用的结果就是它所接受的右值引用（返回值为右值引用类型有临时对象产生）。<br>.<br>.现在考虑第二个赋值，它调用了<code>std::move ()</code>。在此调用中，传递给move的实参是一个左值。这样:</p><ol><li>推断出的T的类型为string&amp; (string 的引用，而非普通string)。</li><li>因此，remove reference用string&amp;进行实例化。</li><li>remove reference&lt;string&amp;&gt;的type成员是string。</li><li>move的返回类型仍是string&amp;&amp; 。</li><li>move的函数参数t实例化为string&amp; &amp;&amp;，会折叠为string&amp;。</li></ol><p>因此，这个调用实例化<code>move&lt;string&amp;&gt;</code>，即<br><code>string&amp;&amp;  move(string &amp;t)</code><br>这正是我们所寻求的—我们希望将一个右值引用绑定到一个左值。这个实例的函数体返回<code>static_cast&lt;string&amp;&amp;&gt;(t)</code>。在此情况下，<code>t</code>的类型为<code>string&amp;</code>，cast将其转换为<code>string&amp;&amp;</code>(强转伴随临时对象xvalue的产生其空间地址与<code>std::move()</code>函数产生的临时对象xvalue的空间地址相同)。<br><img src="/img%5C00004%5C19.png" alt="在这里插入图片描述"><br>将右值引用绑定到一个被强转成xvalue的左值，这一特性被称为截断。（《c++primer》p612）</p><h3 id="std-move-函数总结"><a href="#std-move-函数总结" class="headerlink" title="std::move()函数总结"></a>std::move()函数总结</h3><p>说白了<code>std::move()</code>函数就是将一个prvalue或者lvalue转变成xvalue的过程，这样不管是prvalue还是lvalue都可以被右值引用接受。</p></blockquote><hr><h2 id="接下来咱们来分析标准库forward函数"><a href="#接下来咱们来分析标准库forward函数" class="headerlink" title="接下来咱们来分析标准库forward函数:"></a>接下来咱们来分析标准库forward函数:</h2><blockquote><p>在分析forward源码之前，咱们先来看看forward完成了一个什么样的功能。<br>我们知道某些函数需要将其一个或多个实参连同类型不变地转发给其他函数。在此情况下，我们需要保持被转发实参的所有性质,包括实参类型是否是<code>const</code>的以及实参是左值还是右值。<br>作为一个例子，我们将编写一个函数，它接受一个可调用表达式和两个额外实参。我们的函数将调用给定的可调用对象，将两个额外参数逆序传递给它。下面是我们的翻转函数的模样:</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//接受一个可调用对象和另外两个参数的模板</span><br><span class="hljs-comment">//对“翻转”的参数调用给定的可调用对象</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span> T1,<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flip2</span><span class="hljs-params">(F f,T1 &amp;&amp;t1,T2 &amp;&amp;t2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">f</span> (t2,t1);<br>)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> v1,<span class="hljs-type">int</span> &amp;v2)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; v1 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ++v2 &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>通过将一个函数参数定义为一个指向模板类型参数的右值引用，我们可以保持其对应实参的所有类型信息。而使用引用参数(无论是左值还是右值)使得我们可以保持<code>const</code>属性，因为在引用类型中的<code>const</code>是底层的。如果我们将函数参数定义为<code>T1&amp;&amp;</code>和<code>T2&amp;&amp;</code>, 通过引用折叠，就可以保持翻转后实参的左值&#x2F;右值属性（对应实参的<code>const</code>属性和左值&#x2F;右值属性将得到保持）:<br>例如，如果我们调用<code>flip2(f，j，42)</code>，将传递给参数<code>t1</code>一个左值<code>j</code>。但是，在<code>flip2</code>中，推断出的<code>T1</code>的类型为<code>int&amp;</code>，这意味着<code>t1</code>的类型会折叠为<code>int&amp;</code>。由于是引用类型，<code>t1</code>被绑定到<code>j</code>上。当<code>flip2</code>调用<code>f</code>时，<code>f</code>中的引用参数<code>v2</code>被绑定到<code>t1</code>，也就是被绑定到<code>j</code>。当<code>f</code>递增<code>v2</code>时，它也同时改变了<code>j</code>的值。<br>.<br>现在，咱们不用可调用对象<code>f</code>，用<code>g</code>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//接受一个可调用对象和另外两个参数的模板</span><br><span class="hljs-comment">//对“翻转”的参数调用给定的可调用对象</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span> T1,<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flip2</span><span class="hljs-params">(F f,T1 &amp;&amp;t1,T2 &amp;&amp;t2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">g</span>(t2,t1);<br>)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;&amp;i, <span class="hljs-type">int</span>&amp; j)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如果我们试图通过<code>flip2</code>调用<code>g</code>，则参数<code>t2</code>将被传递给<code>g</code>的右值引用参数。即使我们传递一个右值给<code>flip2</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">flip2</span>(g, i，<span class="hljs-number">42</span>);<span class="hljs-comment">//错误:不能从一个左值实例化int&amp;&amp;</span><br></code></pre></td></tr></table></figure><p>传递给<code>g </code>的将是<code>flip2</code>中名为<code>t2</code>的参数。函数参数与其他任何变量一样，都是左值表达式。因此，<code>flip2</code>中对 <code>g</code>的调用将传递给<code>g</code>的右值引用参数一个左值。<br>.<br>在调用中使用<code>std::forward</code>保持类型信息<br>.<br>我们可以使用一个名为forward 的新标准库设施来传递<code>flip2</code>的参数,它能保持原始实参的类型。类似move,forward定义在头文件utility中。与move不同,forward必须通过显式模板实参来调用。forward返回该显式实参类型的右值引用。即，<code>forward&lt;T&gt;</code>的返回类型是<code>T&amp;&amp;</code>。<br>通常情况下，我们使用forward传递那些定义为模板类型参数的右值引用的函数参数。通过其返回类型上的引用折叠，forward可以保持给定实参的左值&#x2F;右值属性(forward可以保持实参类型的所有细节)。<br>使用forward，我们可以再次重写翻转函数:</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> F,<span class="hljs-keyword">typename</span> T1,<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flip</span><span class="hljs-params">(F f,T1 &amp;&amp;t1,T2 &amp;&amp;t2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">g</span>(std::forward&lt;T2&gt;(t2),std::forward&lt;T1&gt;(t1)) ;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;&amp;i, <span class="hljs-type">int</span>&amp; j)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如果我们调用<code>flip(g, i，42)</code>，<code>i</code>将以<code>int&amp;</code>类型传递给<code>g</code>，<code>42</code>将以<code>int&amp;&amp;</code>类型的<code>xvalue</code>传递给<code>g</code>。（primer没说清楚，单纯因为42是int&amp;&amp;类型是无法传给可调用对象g。lvalue可以是int&amp;&amp;类型，xvalue也可以是int&amp;&amp;类型，但是lvalue不能传给右值引用，而xvalue可以。）</p></blockquote><hr><blockquote><p>现在咱们知道forward是干什么的了。废话不多说直接分析它的源码，看看它如何保持实参类型的所有细节。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> _Tp&amp;&amp;</span><br><span class="hljs-function"><span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="hljs-type">_t</span>)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123; <br><span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="hljs-type">_t</span>); <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> _Tp&amp;&amp;</span><br><span class="hljs-function"><span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="hljs-type">_t</span>)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">static_assert</span>(!std::is_lvalue_reference&lt;_Tp&gt;::value, <span class="hljs-string">&quot;template argument&quot;</span><br>    <span class="hljs-string">&quot; substituting _Tp is an lvalue reference type&quot;</span>);    <br><span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="hljs-type">_t</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>std::forward</code>有两个版本的重载，一个用于左值一个用于右值。不过咱们一般用的是第一个版本，因为用在形参上，形参不管怎么样都是个左值。那我们就只分析第一个版本的情况：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> F,<span class="hljs-keyword">typename</span> T1,<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flip</span><span class="hljs-params">(F f,T1 &amp;&amp;t1,T2 &amp;&amp;t2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">g</span>(std::forward&lt;T2&gt;(t2),std::forward&lt;T1&gt;(t1)) ;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;&amp;i, <span class="hljs-type">int</span>&amp; j)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>就拿上面这个例子来说，如果我们调用<code>flip(g, i，42)</code>。<br><code>T2</code>将被推导成<code>int</code>，<code>t2</code>的类型为<code>int&amp;&amp;</code>。调用<code>std::forward&lt;T2&gt;(t2)</code>时，forward函数将被实例化成：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span>&amp;&amp;</span><br><span class="hljs-function"><span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; <span class="hljs-type">_t</span>)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123; <br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&amp;&amp;&gt;(<span class="hljs-type">_t</span>); <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>_t</code>的类型为<code>int&amp;</code>，return时<code>_t</code>被强制转换成<code>int&amp;&amp;</code>，此时强转产生的<code>xvalue</code>和forward函数由返回类型<code>int&amp;&amp;</code>而产生的<code>xvalue</code>在同一空间地址。<code>xvalue</code>可以被函数<code>g</code>的形参 <code>i </code>所接受，完成<code>flip</code>实参<code>42</code>的类型保持。</p><p><code>T1</code>将被推导成<code>int&amp;</code>，<code>t1</code>的类型被折叠成<code>int&amp;</code>。调用<code>std::forward&lt;T1&gt;(t1)</code>时，forward函数将被实例化成：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span>&amp;</span><br><span class="hljs-function"><span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; <span class="hljs-type">_t</span>)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123; <br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&amp;&gt;(<span class="hljs-type">_t</span>); <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>返回类型折叠成<code>int&amp;</code>。<code>t1</code>传入<code>flip</code>中是左值引用传入，被forward转换后也是左值引用。完成类型保持。</p></blockquote><hr><h3 id="std-forward总结"><a href="#std-forward总结" class="headerlink" title="std::forward总结"></a>std::forward总结</h3><blockquote><p>不难看出forward函数跟move函数的工作原理都一样，用的引用折叠技术。</p><ul><li>forward将g函数的右值引用类型实参从左值转换成右值，保持rvalue能被int&amp;&amp;接收的性质（可调用对象的形参类型为int&amp;&amp;，接受实参值的类型为rvalue）。</li><li>而g函数的左值引用类型实参，进入forward是左值引用进入，函数返回也是左值引用传出，没变化。</li><li>最后g函数的形参为int类型时，接受实参值的类型为lvalue或rvalue。forward不管怎么转换，它都可以接受。</li></ul><p>这就是所谓的类型保持（可能叙述的不是特别详细，毕竟过程有点复杂，只是起一个抛砖引玉的作用，大家可以下去自己捣鼓捣鼓）。<br>.</p></blockquote><hr><h2 id="最后咱们来看下move和forword的不同之处。"><a href="#最后咱们来看下move和forword的不同之处。" class="headerlink" title="最后咱们来看下move和forword的不同之处。"></a>最后咱们来看下move和forword的不同之处。</h2><blockquote><p>std::move函数的源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>&gt;<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp;<br>&gt;<span class="hljs-built_in">move</span>(T&amp;&amp; t) <span class="hljs-keyword">noexcept</span><br>&gt;&#123; <br><span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t); <br>&gt;&#125;<br></code></pre></td></tr></table></figure><p>std::forward函数的源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>&gt;<span class="hljs-keyword">constexpr</span> _Tp&amp;&amp;<br>&gt;forward(<span class="hljs-keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="hljs-type">_t</span>) <span class="hljs-keyword">noexcept</span><br>&gt;&#123; <br><span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="hljs-type">_t</span>); <br>&gt;&#125;<br></code></pre></td></tr></table></figure><p>不难发现，move函数的<code>std::remove_reference&lt;T&gt;::type</code>，放在返回类型和<code>static_cast&lt;&gt;</code>中，而且后面都是直接接上两个<code>&amp;&amp;</code>。他这样写的目的在于，不管<code>t</code>接受的是一个右值还是一个左值，返回出来值的类型永远都是右值。永远能被<code>int&amp;&amp;</code>接受。<br>而forward函数的<code>std::remove_reference&lt;T&gt;::type</code>，放在形参<code>_t</code>上，而且返回类型和<code>static_cast&lt;&gt;</code>都用了引用折叠技术，值得注意的一点是move函数不需要显示指定模板的类型，而forward函数需要显示指定实参类型。forward函数的形参一定是引用传入，而且返回类型和<code>static_cast&lt;&gt;</code>可以根据实参类型动态改变。forward函数的实参类型为<code>int&amp;&amp;</code>，则返回类型为<code>int&amp;&amp;</code>，返回出去的就是一个<code>xvalue</code>。forward函数的实参类型为<code>int&amp;</code>，则返回类型也为<code>int&amp;</code>，返回出去的和传入进来的都是实参的引用。</p></blockquote><hr><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><blockquote><p>注意：下面的文件下载都是免费的，0积分下载，别被VIP字样吓到了蛤 :D<br><a href="https://download.csdn.net/download/Howl_1/77241824">右值引用相关文档</a><br><a href="https://download.csdn.net/download/Howl_1/77242257">测试代码的反汇编代码</a></p></blockquote><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><blockquote><p>摘取自《c++ template 2nd》附录中的内容，可以用来检查表达式的值类别（ value category of the expression：prvalue，xvalue或lvalue）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ISXVALUE(x) \</span><br><span class="hljs-meta">std::is_rvalue_reference<span class="hljs-string">&lt;decltype((x))&gt;</span>::value</span><br>&gt;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ISLVALUE(x)\</span><br><span class="hljs-meta">std::is_lvalue_reference<span class="hljs-string">&lt;decltype((x))&gt;</span>::value</span><br>&gt;<span class="hljs-meta">#<span class="hljs-keyword">define</span> CHEECK_VALUE_CATOGORIES(x) \</span><br><span class="hljs-meta"><span class="hljs-keyword">if</span>(ISXVALUE(x)) printf(<span class="hljs-string">&quot;%s is a xvalue\n&quot;</span>,#x);\</span><br><span class="hljs-meta"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ISLVALUE(x)) printf(<span class="hljs-string">&quot;%s is a lvalue\n&quot;</span>,#x);\</span><br><span class="hljs-meta"><span class="hljs-keyword">else</span> printf(<span class="hljs-string">&quot;%s is a prvalue\n&quot;</span>,#x);</span><br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用tcpdump观察TCP头部信息和三次握手四次挥手</title>
    <link href="/2021/07/25/00003.%20%E4%BD%BF%E7%94%A8tcpdump%E8%A7%82%E5%AF%9FTCP%E5%A4%B4%E9%83%A8%E4%BF%A1%E6%81%AF%EF%BC%88%E8%A1%A5%E5%85%85TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%EF%BC%89/"/>
    <url>/2021/07/25/00003.%20%E4%BD%BF%E7%94%A8tcpdump%E8%A7%82%E5%AF%9FTCP%E5%A4%B4%E9%83%A8%E4%BF%A1%E6%81%AF%EF%BC%88%E8%A1%A5%E5%85%85TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p><strong>本篇文章为笔者的读书笔记，未经允许请勿转载。</strong><br>本次实验是目的在于弄清tcp头部信息和三次握手四次挥手的细节，并且补充一些tcp协议的常用知识。读本文需要一些前置知识，具体请参照《linux高性能服务器编程》p32-p37。<br>实验测试机是阿里云ECS服务器和本地虚拟机。不同于书本上，它的测试机是在同一局域网内。</p></blockquote><hr><h1 id="实验开始"><a href="#实验开始" class="headerlink" title="实验开始"></a>实验开始</h1><ul><li><p>　<font color='red'>  在服务器上将echo服务打开，具体请看笔者写的tcpdump观察ARP通信过程，这里不多赘述。  </font></p></li><li><p>　<font color='red'>  在本地虚拟机上开启两个终端 </font></p></li><li><p>　<font color='red'>  监听终端</font></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@ubuntu:/<span class="hljs-comment"># tcpdump -S -i ens33 -ntx &#x27;(src 192.168.1.7 and dst 120.79.72.214) or (src 120.79.72.214 and dst 192.168.1.7)&#x27;</span><br>tcpdump: verbose output suppressed, use -v or -vv <span class="hljs-keyword">for</span> full protocol decode<br>listening on ens33, link-type EN10MB (Ethernet), capture size 262144 bytes<br></code></pre></td></tr></table></figure><blockquote><p>-S 序号和确认号以绝对值形式显示（如果是相对值显示，则从第三个报文开始，seq和ack相对ISN的偏移）, -i 监听指定网络接口ens33，-n 指定将每个监听到数据包中的域名转换成IP地址后显示，-t 在输出的每一行不打印时间戳, -x 把协议头和包内容都原原本本的显示出来（tcpdump会以16进制和ASCII的形式显示）。后面src表示源ip，dst表示目的ip，这样写可以起到一个滤包的作用。</p></blockquote><ul><li>　<font color='red'>  测试终端</font></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@ubuntu:/home/marvel<span class="hljs-comment"># telnet 120.79.72.214 7</span><br>Trying 120.79.72.214...<br>Connected to 120.79.72.214.<br>Escape character is <span class="hljs-string">&#x27;^]&#x27;</span>.<br>1<br>1<br>^]<br>telnet&gt; q<br>Connection closed.<br>root@ubuntu:/home/marvel<span class="hljs-comment"># </span><br><br></code></pre></td></tr></table></figure><ul><li>　<font color='red'>  监听终端</font></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@ubuntu:/home/marvel<span class="hljs-comment"># tcpdump -S -i ens33 -ntx &#x27;(src 192.168.1.7 and dst 120.79.72.214) or (src 120.79.72.214 and dst 192.168.1.7)&#x27;</span><br>tcpdump: verbose output suppressed, use -v or -vv <span class="hljs-keyword">for</span> full protocol decode<br>listening on ens33, link-type EN10MB (Ethernet), capture size 262144 bytes<br>1）IP 192.168.1.7.39804 &gt; 120.79.72.214.7: Flags [S], <span class="hljs-built_in">seq</span> 3843050562, win 64240, options [mss 1460,sackOK,TS val 2363801315 ecr 0,nop,wscale 7], length 0<br>0x0000:  4510 003c 3496 4000 4006 8341 c0a8 0107<br>0x0010:  784f 48d6 9b7c 0007 e510 4c42 0000 0000<br>0x0020:  a002 faf0 8303 0000 0204 05b4 0402 080a<br>0x0030:  8ce4 bee3 0000 0000 0103 0307<span class="hljs-comment">#60字节（16位，两字节，一组，一共30组），同步报文</span><br>2）IP 120.79.72.214.7 &gt; 192.168.1.7.39804: Flags [S.], <span class="hljs-built_in">seq</span> 3051969109, ack 3843050563, win 65160, options [mss 1400,sackOK,TS val 743316774 ecr 2363801315,nop,wscale 7], length 0<br>0x0000:  4514 003c 0000 4000 3406 c3d3 784f 48d6<br>0x0010:  c0a8 0107 0007 9b7c b5e9 5a55 e510 4c43<br>0x0020:  a012 fe88 547b 0000 0204 0578 0402 080a<br>0x0030:  2c4e 1d26 8ce4 bee3 0103 0307<span class="hljs-comment">#60字节（16位，两字节，一组，一共30组），同步确认报文</span><br>3）IP 192.168.1.7.39804 &gt; 120.79.72.214.7: Flags [.], ack 3051969110, win 502, options [nop,nop,TS val 2363801340 ecr 743316774], length 0<br>0x0000:  4510 0034 3497 4000 4006 8348 c0a8 0107<br>0x0010:  784f 48d6 9b7c 0007 e510 4c43 b5e9 5a56<br>0x0020:  8010 01f6 82fb 0000 0101 080a 8ce4 befc<br>0x0030:  2c4e 1d26<span class="hljs-comment">#52字节（16位，两字节，一组，一共26组），确认报文</span><br>4）IP 192.168.1.7.39804 &gt; 120.79.72.214.7: Flags [P.], <span class="hljs-built_in">seq</span> 3843050563:3843050566, ack 3051969110, win 502, options [nop,nop,TS val 2363810557 ecr 743316774], length 3<br>0x0000:  4510 0037 3498 4000 4006 8344 c0a8 0107<br>0x0010:  784f 48d6 9b7c 0007 e510 4c43 b5e9 5a56<br>0x0020:  8018 01f6 82fe 0000 0101 080a 8ce4 e2fd<br>0x0030:  2c4e 1d26 310d 0a<span class="hljs-comment">#55字节，length（数据长度）=55-52，</span><br>5）IP 120.79.72.214.7 &gt; 192.168.1.7.39804: Flags [.], ack 3843050566, win 510, options [nop,nop,TS val 743326016 ecr 2363810557], length 0<br>0x0000:  4514 0034 d00d 4000 3406 f3cd 784f 48d6<br>0x0010:  c0a8 0107 0007 9b7c b5e9 5a56 e510 4c46<br>0x0020:  8010 01fe 375f 0000 0101 080a 2c4e 4140<br>0x0030:  8ce4 e2fd<span class="hljs-comment">#52字节，确认报文</span><br>6）IP 120.79.72.214.7 &gt; 192.168.1.7.39804: Flags [P.], <span class="hljs-built_in">seq</span> 3051969110:3051969113, ack 3843050566, win 510, options [nop,nop,TS val 743326016 ecr 2363810557], length 3<br>0x0000:  4514 0037 d00e 4000 3406 f3c9 784f 48d6<br>0x0010:  c0a8 0107 0007 9b7c b5e9 5a56 e510 4c46<br>0x0020:  8018 01fe fc46 0000 0101 080a 2c4e 4140<br>0x0030:  8ce4 e2fd 310d 0a<span class="hljs-comment">#55字节，length（数据长度）=55-52。</span><br>7）IP 192.168.1.7.39804 &gt; 120.79.72.214.7: Flags [.], ack 3051969113, win 502, options [nop,nop,TS val 2363810582 ecr 743326016], length 0<br>0x0000:  4510 0034 3499 4000 4006 8346 c0a8 0107<br>0x0010:  784f 48d6 9b7c 0007 e510 4c46 b5e9 5a59<br>0x0020:  8010 01f6 82fb 0000 0101 080a 8ce4 e316<br>0x0030:  2c4e 4140<span class="hljs-comment">#52字节</span><br>8）IP 192.168.1.7.39804 &gt; 120.79.72.214.7: Flags [F.], <span class="hljs-built_in">seq</span> 3843050566, ack 3051969113, win 502, options [nop,nop,TS val 2363813862 ecr 743326016], length 0<br>0x0000:  4510 0034 349a 4000 4006 8345 c0a8 0107<br>0x0010:  784f 48d6 9b7c 0007 e510 4c46 b5e9 5a59<br>0x0020:  8011 01f6 82fb 0000 0101 080a 8ce4 efe6<br>0x0030:  2c4e 4140<span class="hljs-comment">#52字节，</span><br>9）IP 120.79.72.214.7 &gt; 192.168.1.7.39804: Flags [F.], <span class="hljs-built_in">seq</span> 3051969113, ack 3843050567, win 510, options [nop,nop,TS val 743329323 ecr 2363813862], length 0<br>0x0000:  4514 0034 d00f 4000 3406 f3cb 784f 48d6<br>0x0010:  c0a8 0107 0007 9b7c b5e9 5a59 e510 4c47<br>0x0020:  8011 01fe 1d86 0000 0101 080a 2c4e 4e2b<br>0x0030:  8ce4 efe6<span class="hljs-comment">#52字节</span><br>10）IP 192.168.1.7.39804 &gt; 120.79.72.214.7: Flags [.], ack 3051969114, win 502, options [nop,nop,TS val 2363813889 ecr 743329323], length 0<br>0x0000:  4510 0034 349b 4000 4006 8344 c0a8 0107<br>0x0010:  784f 48d6 9b7c 0007 e510 4c47 b5e9 5a5a<br>0x0020:  8010 01f6 82fb 0000 0101 080a 8ce4 f001<br>0x0030:  2c4e 4e2b<span class="hljs-comment">#52字节</span><br>^C<br>10 packets captured<br>10 packets received by filter<br>0 packets dropped by kernel<br>root@ubuntu:/home/marvel<span class="hljs-comment"># </span><br><br></code></pre></td></tr></table></figure><p><img src="/img%5C00003%5Ctcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="在这里插入图片描述"></p><blockquote><p>这里面信息量巨大，待我们来慢慢分析里面的细节！</p><h2 id="1-延迟确认"><a href="#1-延迟确认" class="headerlink" title="1. 延迟确认"></a>1. 延迟确认</h2><p>1）-3）是3次握手，8）-10）是4次挥手，但是这里只有三段报文段。原因是，<strong>延迟确认</strong>，即服务器不会马上确认收到的数据，而是在一段延迟时间后查看本端是否有数据要发送 ，如果有，则和确认信息一起发出。延迟确认可以减少发送tcp报文段的数量。这里的四次挥手中服务器的确认报文和结束报文一次性发送给客户端了。（书上是在局域网内进行的，没有延迟确认）</p><h2 id="2-序号（seq）和确认号（ack）之间的关系"><a href="#2-序号（seq）和确认号（ack）之间的关系" class="headerlink" title="2. 序号（seq）和确认号（ack）之间的关系"></a>2. 序号（seq）和确认号（ack）之间的关系</h2><p>序号的相对值是相对于自身发出第一个tcp报文段中的seq<br>确认号的相对值是相对于对方发出第一个tcp报文段中的seq（以绝对值显示的就不用管啦）<br>序号的值除了两次开头的同步报文是由系统初始化为某个随机ISN。<strong>其他序号为上一条对方发送报文段的确认号</strong>，由图中的红色线条为代表（一来一回）。如果是一方连续发送报文段（连续去没回），<strong>则序列号为ISN加上该报文段所携带数据的第一个字节在整个字节流中的偏移</strong>（这一点本文未涉及，读者在观察其他复杂通信过程中肯定会碰到）。<br>确认号的值，如果是在三次握手1）-3）和四次挥手8）-10）中，则ack&#x3D;对方发送报文段的seq+1；<strong>如果是在数据传输过程中4）-7）,ack&#x3D;上一条对方发送报文段的seq+数据长度。例如本例中报文段5）的确认号（3843050566）&#x3D;上一条对方发送报文段的seq（3843050563）+它的数据字节（3）</strong>,得到的也就是报文段4）seq 3843050563:3843050566，冒号后面那个值。冒号后面的值是由tcpdump自行添加的，其值刚好为接收端ack的值。<br>总结：<strong>序列号的相对值是对字节流的标识，根据序列号的差值可以确定两个数据报之间数据的大小</strong>。</p><h2 id="3-TS-val和ecr的关系"><a href="#3-TS-val和ecr的关系" class="headerlink" title="3.TS val和ecr的关系"></a>3.TS val和ecr的关系</h2><p>这两者的关系很少有人提及，咱们直接看维基百科的解释</p><p>There are two timestamp fields:<br><strong>TS val：a 4-byte sender timestamp value (my timestamp)</strong><br><strong>ecr：a 4-byte echo reply timestamp value (the most recent timestamp received from you).</strong><br><strong>TCP timestamps are used in an algorithm known as Protection Against Wrapped Sequence numbers, or PAWS (see RFC 1323 for details)</strong>. PAWS is used when the receive window crosses the sequence number wraparound boundary. In the case where a packet was potentially retransmitted it answers the question: <strong>“Is this sequence number in the first 4 GB or the second?” And the timestamp is used to break the tie</strong>.<br>TCP时间戳选项有助于在传输非常大的数据流时保护包装序列。TCP中的序列号字段只有32位，所以序列号大于2^32-1之后，序列号会绕回开始。<br>另一个作用计算RTT值。<br>The Timestamp option can be used to measure the round-trip time (RTT) of every packet that is acknowledged. This is done by including a Timestamp Value TSval in every segment that is sent. These TSval values are echoed by the opposite side of the connection in the Timestamp Echo Reply TSecr field. So, when a segment is ACKed, the sender of that segment can simply subtract their current timestamp from the TSecr value to compute an accurate Round Trip Time (RTT) measurement.<br>RTT &#x3D; 当前时间 -  数据包中Timestamp选项的回显时间（这个回显时间是该数据包发出去的时间）</p><h2 id="4-TCP状态转移（书上p41-p42原话）"><a href="#4-TCP状态转移（书上p41-p42原话）" class="headerlink" title="4. TCP状态转移（书上p41-p42原话）"></a>4. TCP状态转移（书上p41-p42原话）</h2><p><img src="/img%5C00003%5Ctcp%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%9B%BE.png" alt="在这里插入图片描述"></p><p><strong>重点掌握ESTABLISHED,FIN_WAIT_2&lt;–&gt;CLOSE_WAIT,TIME_WAIT(2MSL)</strong><br>&#x3D;&#x3D;首先&#x3D;&#x3D;讨论服务器的典型状态转移过程(<strong>虚线路径</strong>)，此时说的连接状态都是指该连接的服务器端的状态。<br>服务器通过listen系统调用<strong>进入LISTEN状态</strong>，被动等待客户端连接，因此执行的是所谓的被动打开。服务器一旦监听到某个连接请求（收到同步报文段），就将该连接放入内核等待队列中，并向客户端发送带SYN标志的确认报文段。此时该连接<strong>处于SYN_RCVD状态</strong>。如果服务器成功地接收到客户端发送回的确认报文段，则该连接转<strong>移到ESTABLISHED</strong>。ESTABLISHED状态是连接双方能够进行双向数据传输的状态。<br>当客户端主动关闭连接时，服务器通过返回确认报文段使连接<strong>进入CLOSE_WAIT状态</strong>。这个状态的含义很明确：等待服务器应用程序关闭连接。通常，服务器检测到客户端关闭连接后，也会立即给客户端发送一个结束报文段来关闭连接。这将使连接<strong>转移到LAST_ACK状态</strong>，以等待客户端对结束报文段的最后一次确认。一旦确认完成，连接彻底关闭了。<br>&#x3D;&#x3D;其次&#x3D;&#x3D;讨论客户端（<strong>粗黑线</strong>），客户端通过connect系统调用（见第5章）主动与服务器建立连接。connect系统调用首先给服务器发送一个同步报文段，使连接<strong>转移到SYN_SENT状态</strong>。connect调用失败将使连接立即返回到初始的CLOSED状态。如果客户端成功收到服务器的同步报文段和确认，则connect调用成功返回，连接<strong>转移至ESTABLISHED状态</strong>。<br>当客户端执行主动关闭时，它将向服务器发送一个结束报文段，同时连接<strong>进入FIN_WAIT_1状态</strong>（到达这个状态时，会发送FIN告诉对方我要关闭连接）。若此时客户端收到服务器专门用于确认目的的确认报文段（比如图3-6中的TCP报文段5)，则连接<strong>转移至FIN_WAIT_2状态</strong>（这个状态也称为半关闭状态，即客户端将自己的写buffer关闭了，但是读buffer还在）。当客户端处于FIN_WAIT_2状态时，服务器处于CLOSE_WAIT状态，这一对状态是可能发生半关闭的状态。此时如果服务器也关闭连接（发送结束报文段)，则客户端将给予确认并<strong>进入TIME_WAIT状态</strong>，在这个状态客户端要等待2MSL（报文最大生存时间），才能完全关闭。</p><h2 id="5-FIN-WAIT-2状态-半关闭状态"><a href="#5-FIN-WAIT-2状态-半关闭状态" class="headerlink" title="5. FIN_WAIT_2状态(半关闭状态)"></a>5. FIN_WAIT_2状态(半关闭状态)</h2><p>处于FIN_WAIT_2状态的客户端需要等待服务器发送结束报文段，才能转移至TIME_WAIT 状态，否则它将一直停留在这个状态。<strong>如果不是为了在半关闭状态下继续接收数据，连接长时间地停留在FIN_WAIT_2状态并无益处</strong>。连接停留在FIN_WAIT_2状态的情况可能发生在:客户端执行半关闭后，未等服务器关闭连接就强行退出了。此时客户端连接由内核来接管，可称之为<strong>孤儿连接</strong>（和孤儿进程类似)。Linux为了防止孤儿连接长时间存留在内核中，定义了两个内核变量:l&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_orphans 和 &#x2F;proc&#x2F;syslnet&#x2F;ipv4&#x2F;tcp_fin_timeout。前者指定内核能接管的孤儿连接数目，后者指定孤儿连接在内核中生存的时间。</p><h2 id="6-TIME-WAIT状态"><a href="#6-TIME-WAIT状态" class="headerlink" title="6. TIME_WAIT状态"></a>6. TIME_WAIT状态</h2><p>TIME_WAIT状态存在的原因有两<br>一：可靠地终止TCP连接。<br><strong>TIME_WAIT状态为2MSL可以保证最糟糕情况也可以收到超时重传的FIN报文</strong>（确认报文半路嗝屁，最大存活时间MSL，重传的FIN报文到客户端花费的最大时间MSL，即收到重传的FIN报文小于等于2MSL）。<br>二：保证让迟来的TCP报文段有足够的时间被识别并丢弃。<br>我们反过来思考，如果没有TIME_WAIT状态，则应用程序能够立即创立一个和刚关闭的连接相似的连接（具有相同IP，和端口号）。这个新的，和原来相似的连接被称为原来连接的化身。<strong>新的化身可能接收到属于原来的连接的，携带应用程序数据的TCP报文段（迟到的报文段）</strong>，这显然不应该发生的。</p><h2 id="7-细说4）TCP报文段的详细信息"><a href="#7-细说4）TCP报文段的详细信息" class="headerlink" title="7. 细说4）TCP报文段的详细信息"></a>7. 细说4）TCP报文段的详细信息</h2><p><img src="/img%5C00003%5Ctcp%E6%8A%A5%E6%96%87%E6%AE%B5%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF.png" alt="在这里插入图片描述"><br>1.该报文段是一个数据报文段. Flags[P. ]:提示接收端应用程序应该立即从TCP接收缓冲区中读<br>走数据，为后续数据腾出空间; seq是序列号，“: ”后面的数值是下条接收方确认报文的确<br>认号; ack是确认号; win是窗大小，是TCP流量控制的-一个手段，如果是一个RWND (接收通<br>告窗口)，它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样可以控制发送数据<br>的速度; options后面再说; length是指数据长度，没包括头部长度，即整个报文长度减去头<br>部长度。<br>2.十六进制数据具体分析。(16位一 组，一组两字节)</p></blockquote><p><img src="/img%5C00003%5Cip%E5%A4%B4%E9%83%A8.png" alt="在这里插入图片描述"><img src="/img%5C00003%5Cipv4%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84.png" alt="在这里插入图片描述"></p><blockquote><p>由于IP的选项很少用到，所以基本上都是20字节。</p></blockquote><table><thead><tr><th>十六进制</th><th>十进制</th><th>二进制</th><th>IP头部信息</th></tr></thead><tbody><tr><td>0x4</td><td>4</td><td></td><td>IP版本号</td></tr><tr><td>0x5</td><td>5</td><td></td><td>头部长度为5个32位（20字节）</td></tr><tr><td>0x10</td><td>16</td><td>0001 0000</td><td>TOS选项中最小延时服务被开启</td></tr><tr><td>0x0037</td><td>55</td><td></td><td>数据报总长度，55字节</td></tr><tr><td>0x3498</td><td></td><td></td><td>数据报标识</td></tr><tr><td>0x4</td><td>4</td><td>0100（前三位有用）</td><td>设置了禁止分片标志</td></tr><tr><td>0x000</td><td>0</td><td></td><td>分片偏移</td></tr><tr><td>0x40</td><td>64</td><td></td><td>TTL被设为64</td></tr><tr><td>0x06</td><td>6</td><td></td><td>协议字段为6，表示上层协议是TCP协议</td></tr><tr><td>0x8344</td><td></td><td></td><td>IP头部校验和</td></tr><tr><td>0xc0a8 0107</td><td></td><td>11000000.10101000.00000001.00000111</td><td>32位源端IP地址 192.168.1.7</td></tr><tr><td>0x784f 48d6</td><td></td><td>01111000.01001111.01001000.11010110</td><td>32位目的端IP地址 120.79.72.214</td></tr></tbody></table><p><img src="/img%5C00003%5Ctcp%E5%A4%B4%E9%83%A8.png" alt="在这里插入图片描述"><img src="/img%5C00003%5Ctcp%E5%A4%B4%E9%83%A8%E9%80%89%E9%A1%B9.png" alt="在这里插入图片描述"></p><table><thead><tr><th>十六进制</th><th>十进制</th><th>二进制</th><th>TCP头部信息</th></tr></thead><tbody><tr><td>0x9b7c</td><td>39804</td><td></td><td>源端口号</td></tr><tr><td>0x0007</td><td>7</td><td></td><td>目的端口号</td></tr><tr><td>0xe510 4c43</td><td></td><td></td><td>序列号</td></tr><tr><td>0xb5e9 5a56</td><td></td><td></td><td>确认号</td></tr><tr><td>0x8</td><td>8</td><td></td><td>TCP头部长度为8个32位（32字节）</td></tr><tr><td>0x018</td><td></td><td>00011000（后面6位有效）</td><td>ACK和PSH标志位开启</td></tr><tr><td>0x01f6</td><td>502</td><td></td><td>窗口大小</td></tr><tr><td>0x82fe</td><td></td><td></td><td>16位校验和</td></tr><tr><td>0x0000</td><td></td><td></td><td>没设置URG标志，紧急指针此处无意义</td></tr><tr><td>0x0101</td><td></td><td></td><td>两次kind的值均为1，两次nop操作，一般用于将TCP选项的总长度填充为4字节的整数倍</td></tr><tr><td>0x080a</td><td></td><td></td><td>kind&#x3D;8，length&#x3D;10（10字节），时间戳选项，较为准确的计算通信双方之间的RTT（回路时间）</td></tr><tr><td>0x8ce4 e2fd</td><td>2363810557</td><td></td><td>时间戳</td></tr><tr><td>0x2c4e 1d26</td><td>743316774</td><td></td><td>回显应答时间戳</td></tr></tbody></table><p><img src="/img%5C00003%5C%E6%95%B0%E6%8D%AE%E6%AE%B5.png" alt="在这里插入图片描述"></p><table><thead><tr><th>十六进制</th><th>十进制</th><th>二进制</th><th>数据段信息</th></tr></thead><tbody><tr><td>0x31</td><td>49</td><td></td><td>字符‘1’</td></tr><tr><td>0x0d</td><td>13</td><td></td><td>回车符</td></tr><tr><td>0x0a</td><td>10</td><td></td><td>换行符</td></tr></tbody></table><blockquote><p>一共三个字节。</p><h2 id="8-Flags-p-Flags-F-Flags-中的点的含义"><a href="#8-Flags-p-Flags-F-Flags-中的点的含义" class="headerlink" title="8.Flags[p.],Flags[F.],Flags[.]中的点的含义"></a>8.Flags[p.],Flags[F.],Flags[.]中的点的含义</h2><p>[.]这个点的含义通常是表示ACK(这个ACK和确认号不同，这是标志位)，还可以表示URG<br><strong>Flags[F.]、Flags[p.]和Flags[.]这里的点表示的就是ACK标志位开启</strong>。</p><h2 id="9-MSS-最大报文段长度"><a href="#9-MSS-最大报文段长度" class="headerlink" title="9.MSS(最大报文段长度)"></a>9.MSS(最大报文段长度)</h2><p>TCP模块通常将MSS设置为【MTU（最大传输单元）-40】字节，40字节是TCP和IP的头部总和。这样携带TCP报文段的IP数据报的长度就不会超过MTU（假设TCP和IP头部不包含选项字段），从而避免本机发生IP分片。以太网的MSS值是1460（1500-40）字节。</p></blockquote><h1 id="复位报文段"><a href="#复位报文段" class="headerlink" title="复位报文段"></a>复位报文段</h1><blockquote><p>携带RST标志的报文段，即复位报文段。<br>产生复位报文段的四种情况<br>1.当客户端访问一个不存在的端口时。<br>2.客户端程序向服务器的某个端口发起连接，而该端口仍被处于TIME_WAIT状态的连接所占用时。<br>3.异常终止连接，TCP提供了异常终止一个连接的方法，即给对方发送一个复位报文段，一旦发送了复位报文段，发送端所有排队等待发送的数据都将被丢弃。<br>4.服务器（或客户端）关闭或者异常终止了连接，而对方没接收到结束报文段（比如网络故障），此时，客户端（或服务器）还维持着原来的连接。这种状态称为半打开状态，处于这种状态的连接称为半打开连接。如果客户端（或服务器）往处于半打开状态的连接写入数据，则对方将回应一个复位报文段。</p></blockquote><h1 id="TCP超时重传"><a href="#TCP超时重传" class="headerlink" title="TCP超时重传"></a>TCP超时重传</h1><blockquote><p>TCP模块为每个TCP报文段都维护一个重传定时器，该定时器在TCP报文段第一次被发送时启动。如果超时时间内未收到接收方的应答，TCP模块将重传TCP报文段并重置定时器。至于下次重传的超时时间如何选择，以及最多执行多少次重传，就是TCP的重传策略。其实跟TCP超时重连的策略相似，在5次重传均失败的情况下，底层的IP和ARP开始接管，直到客户端放弃连接为止。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++A星寻路的实现</title>
    <link href="/2021/02/07/00002.%20C++A%E6%98%9F%E5%AF%BB%E8%B7%AF%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/02/07/00002.%20C++A%E6%98%9F%E5%AF%BB%E8%B7%AF%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p><strong>本篇文章为笔者的读书笔记，未经允许请勿转载。</strong><br>本文主要讲的A星寻路的代码实现，对A星寻路有一定的了解后再来阅读本文是个不错的选择。<br>本文还用到了图形库，编译器为vs2019。图形库没有的可以去官方网站下载，步骤很简单下载直接安装即可。<br>A星寻路的流程<br>1.准备存储的路径和终点标志位。<br>2.将起点放入closeList<br>3.将起点周围的格子放入openlist<br>4.寻找最小和值F和终点<br>5.找到后将它存入closelist同时将它从openlist中剔除<br>6.从终点标志位开始往父亲节点遍历，存入路径中。<br>7.输出路径。<br>剩下的解释全在代码注释中。</p></blockquote><hr><h1 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;easyx.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;AStart.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;Level.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;Draw.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LevelMap</span>:<span class="hljs-keyword">public</span> Level<br>&#123;<br><span class="hljs-keyword">public</span>:<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; level;<br><span class="hljs-comment">// 通过 Level 继承</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(Pos v)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> !((v.x&lt;<span class="hljs-number">0</span>||v.y&lt;<span class="hljs-number">0</span>)||<br>v.x&gt; level[v.x].<span class="hljs-built_in">size</span>()||v.y&gt; level.<span class="hljs-built_in">size</span>()||<br>level[v.y][v.x]==<span class="hljs-number">1</span>);<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector &lt; vector&lt;<span class="hljs-type">int</span>&gt;&gt; vec = &#123;<span class="hljs-comment">//15*15</span><br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,<span class="hljs-comment">//▶x </span><br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,<br><span class="hljs-comment">//▼y</span><br>&#125;;<br>LevelMap lm;<br>lm.level = vec;<br><span class="hljs-function">AStart <span class="hljs-title">a</span><span class="hljs-params">(lm)</span></span>;<br><span class="hljs-function">Draw <span class="hljs-title">draw</span><span class="hljs-params">(<span class="hljs-number">600</span>, vec)</span></span>;<br>draw.<span class="hljs-built_in">update</span>();<br>list&lt;Pos&gt; path;<br>Pos start&#123; <span class="hljs-number">-1</span>,<span class="hljs-number">-1</span> &#125;;<br>Pos end&#123; <span class="hljs-number">-1</span>,<span class="hljs-number">-1</span> &#125;;<br><span class="hljs-type">int</span> x;<span class="hljs-comment">//从鼠标的位置转换到</span><br><span class="hljs-type">int</span> y;<span class="hljs-comment">//贴图需要更改的位置</span><br><span class="hljs-type">bool</span> flag=<span class="hljs-literal">false</span>;<span class="hljs-comment">//起点和终点的标志位</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>&#123;<br>draw.level = lm.level;<br>draw.<span class="hljs-built_in">update</span>();<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>&#123;<br>MOUSEMSG msg = <span class="hljs-built_in">GetMouseMsg</span>();<br>x = msg.x / draw.<span class="hljs-built_in">getSize</span>();<br>y = msg.y / draw.<span class="hljs-built_in">getSize</span>();<br><span class="hljs-keyword">if</span> (msg.uMsg == WM_RBUTTONDOWN)<span class="hljs-comment">//右键按下，路变墙，墙变路。</span><br>&#123;<br>lm.level[y][x] = draw.level[y][x] =<br>draw.level[y][x] == Draw::road ? Draw::wall : Draw::road;<br>draw.<span class="hljs-built_in">update</span>();<br>&#125;<br><span class="hljs-keyword">if</span> (msg.uMsg == WM_LBUTTONDOWN)<span class="hljs-comment">//左键按下设置起点终点准备寻路。</span><br>&#123;<span class="hljs-comment">//这里不能将lm.level改变，需要还原用。</span><br><span class="hljs-keyword">if</span> (!flag &amp;&amp; draw.level[y][x] == Draw::road)<br>&#123;<br>start.x = x;<br>start.y = y;<br>draw.level[y][x] = Draw::visit;<br>flag = <span class="hljs-literal">true</span>;<br>draw.<span class="hljs-built_in">update</span>();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (draw.level[y][x] == Draw::road)<br>&#123;<br>end.x = x;<br>end.y = y;<br>draw.level[y][x] = Draw::end;<br>path = a.<span class="hljs-built_in">find</span>(start, end);<br>flag = <span class="hljs-literal">false</span>;<br>draw.<span class="hljs-built_in">update</span>();<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; e : path)<br>&#123;<br>draw.level[e.y][e.x] = Draw::visit;<br>draw.<span class="hljs-built_in">update</span>();<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Level-h"><a href="#Level-h" class="headerlink" title="Level.h"></a>Level.h</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pos</span><br>&#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-type">int</span> y;<br><span class="hljs-built_in">Pos</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>):<span class="hljs-built_in">x</span>(x),<span class="hljs-built_in">y</span>(y)&#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Level</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//外部规则</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(Pos v)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h1 id="Draw-h"><a href="#Draw-h" class="headerlink" title="Draw.h"></a>Draw.h</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">//取别名</span><br><span class="hljs-keyword">using</span> Vec2r = std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;;<br><br><span class="hljs-comment">//绘制地图的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Draw</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">/*使用图形库的接口实现地图绘制</span><br><span class="hljs-comment">   *length  屏幕长度</span><br><span class="hljs-comment">    level   地图关卡</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-built_in">Draw</span>(<span class="hljs-type">int</span> length, Vec2r&amp; level);<br>  ~<span class="hljs-built_in">Draw</span>();<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  0 路</span><br><span class="hljs-comment">  1 墙</span><br><span class="hljs-comment">  2 走过的路径</span><br><span class="hljs-comment">  3 终点</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">enum</span> &#123;<br>road=<span class="hljs-number">0</span>,<br>wall,<br>visit,<br>end,<br>  &#125;; <br>  Vec2r level;   <span class="hljs-comment">//绘制的地图上</span><br><br>  <span class="hljs-comment">//地图更新函数</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-comment">//获取瓦片大小</span><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">protected</span>:<br><br>  <span class="hljs-type">int</span> length;    <span class="hljs-comment">//宽度和高度</span><br>  <span class="hljs-type">int</span> size;    <span class="hljs-comment">//每个瓦片的大小</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;              <span class="hljs-comment">//绘制地图</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">text</span><span class="hljs-params">()</span></span>;              <span class="hljs-comment">//绘制文本</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rect</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>;   <span class="hljs-comment">//绘制瓦片</span><br><br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="Draw-cpp"><a href="#Draw-cpp" class="headerlink" title="Draw.cpp"></a>Draw.cpp</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Draw.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;easyx.h&gt;</span><span class="hljs-comment">//图形库文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>Draw::<span class="hljs-built_in">Draw</span>(<span class="hljs-type">int</span> length, Vec2r&amp; level)<br>  :<span class="hljs-built_in">length</span>(length)<br>&#123;<br>  <span class="hljs-built_in">initgraph</span>(length, length, EW_SHOWCONSOLE);<span class="hljs-comment">//初始化图形库,EW_SHOWCONSOLE表示显示控制台</span><br>  size = length / level.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//动态计算小方块的宽度</span><br>  <span class="hljs-keyword">this</span>-&gt;level=level;<span class="hljs-comment">//从外部传入地图</span><br>&#125;<br><br>Draw::~<span class="hljs-built_in">Draw</span>()<br>&#123;<br>  <span class="hljs-built_in">closegraph</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Draw::update</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">draw</span>();<br>  <span class="hljs-built_in">text</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Draw::getSize</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> size;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Draw::draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">BeginBatchDraw</span>();<span class="hljs-comment">//开始批量画图</span><br>  <span class="hljs-built_in">cleardevice</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; level.<span class="hljs-built_in">size</span>(); i++)<span class="hljs-comment">//level.size()等于7，</span><br>  &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; level[i].<span class="hljs-built_in">size</span>(); j++)<span class="hljs-comment">//level[i].size()等于7,这里不懂是因为二维vector没理解透。</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (level[i][j] == road)<span class="hljs-comment">//路</span><br>  &#123;<br><span class="hljs-built_in">setfillcolor</span>(<span class="hljs-built_in">RGB</span>(<span class="hljs-number">0xdd</span>, <span class="hljs-number">0xdd</span>, <span class="hljs-number">0xdd</span>)); <span class="hljs-comment">//设置路的颜色</span><br>  &#125;<br>  <span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span> (level[i][j] == wall)&#123;  <span class="hljs-comment">//墙</span><br><span class="hljs-built_in">setfillcolor</span>(<span class="hljs-built_in">RGB</span>(<span class="hljs-number">0x33</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0xcc</span>));<br>  &#125;<br>  <span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span> (level[i][j] == visit) &#123;  <span class="hljs-comment">//走过的路</span><br><span class="hljs-built_in">setfillcolor</span>(<span class="hljs-built_in">RGB</span>(<span class="hljs-number">0x33</span>, <span class="hljs-number">0xcc</span>, <span class="hljs-number">0x33</span>));<br>  &#125;<br>  <span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span> (level[i][j] == end) &#123;  <span class="hljs-comment">//终点</span><br><span class="hljs-built_in">setfillcolor</span>(<span class="hljs-built_in">RGB</span>(<span class="hljs-number">0xff</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0x33</span>));<br>  &#125;<br>  <span class="hljs-built_in">rect</span>(j, i);<span class="hljs-comment">//绘制瓦片，j代表x  i代表y.</span><br>&#125;<br>  &#125;<br>  <span class="hljs-built_in">EndBatchDraw</span>();<span class="hljs-comment">//结束批量画图</span><br>&#125;<br><span class="hljs-comment">//绘制瓦片</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Draw::rect</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">fillrectangle</span>(x * size, y * size, (x + <span class="hljs-number">1</span>) * size, (y + <span class="hljs-number">1</span>) * size);<br><span class="hljs-comment">/*void fillrectangle(</span><br><span class="hljs-comment">int left,</span><br><span class="hljs-comment">int top,</span><br><span class="hljs-comment">int right,</span><br><span class="hljs-comment">int bottom</span><br><span class="hljs-comment">);*/</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Draw::text</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  string m;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; level.<span class="hljs-built_in">size</span>(); i++)<br>  &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; level[i].<span class="hljs-built_in">size</span>(); j++)<br>&#123;<br>  <span class="hljs-keyword">if</span> (level[i][j] == road)<span class="hljs-comment">//路</span><br>  &#123;<br>m += <span class="hljs-string">&quot;  &quot;</span>; <span class="hljs-comment">//设置路的颜色</span><br>  &#125; <br>  <span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span> (level[i][j] == wall) <br>  &#123;  <span class="hljs-comment">//墙</span><br>m += <span class="hljs-string">&quot;+ &quot;</span>;<br>  &#125; <br>  <span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span> (level[i][j] == visit) <br>  &#123;  <span class="hljs-comment">//走过的路</span><br>m += <span class="hljs-string">&quot;. &quot;</span>;<br>  &#125; <br>  <span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span> (level[i][j] == end) <br>  &#123;  <span class="hljs-comment">//终点</span><br>m += <span class="hljs-string">&quot;= &quot;</span>;<br>  &#125;<br>&#125;<br>m += <span class="hljs-string">&quot;\n&quot;</span>;<br>  &#125;<br>  <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;cls&quot;</span>);  <span class="hljs-comment">//调用命令清屏</span><br>  cout &lt;&lt; m &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Astart-h"><a href="#Astart-h" class="headerlink" title="Astart.h"></a>Astart.h</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Level.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>Pos v;<span class="hljs-comment">//节点坐标</span><br><span class="hljs-type">int</span> G;<span class="hljs-comment">//从起点到当前位置的代价；</span><br><span class="hljs-type">int</span> H;<span class="hljs-comment">//从当前位置到终点的预估代价；</span><br>Node* pre;<span class="hljs-comment">//树的父亲节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getF</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> G + H; &#125;<span class="hljs-comment">//代价和值</span><br><span class="hljs-built_in">Node</span>(Pos v, <span class="hljs-type">int</span> G, <span class="hljs-type">int</span> H, Node* pre = <span class="hljs-literal">nullptr</span>) :<span class="hljs-built_in">v</span>(v), <span class="hljs-built_in">G</span>(G), <span class="hljs-built_in">H</span>(H), <span class="hljs-built_in">pre</span>(pre) &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AStart</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">AStart</span>(Level&amp; level) :<span class="hljs-built_in">level</span>(level) &#123;&#125;<span class="hljs-comment">//多态不能用基类实例化对象这里的引用不能掉</span><br><span class="hljs-function">std::list&lt;Pos&gt; <span class="hljs-title">find</span><span class="hljs-params">(Pos start, Pos end)</span></span>;<br><span class="hljs-keyword">private</span>:<br>Level&amp; level;<span class="hljs-comment">//多态</span><br>Pos end;<span class="hljs-comment">//保存终点坐标</span><br>std::list&lt;Node*&gt; openLsit;<span class="hljs-comment">//准备要走的路但是没有走；</span><br>std::list&lt;Node*&gt; closeList;<span class="hljs-comment">//走过的路，正在走的路；</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addRound</span><span class="hljs-params">(Node* now)</span></span>;<span class="hljs-comment">//将节点周围的节点加入openlist</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getH</span><span class="hljs-params">(Pos now)</span></span>;<span class="hljs-comment">//获取节点位置与终点的预估距离</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(Pos v)</span></span>;<span class="hljs-comment">//检查该坐标能不能加入openlist</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findList</span><span class="hljs-params">(Pos v)</span></span>;<span class="hljs-comment">//检查该坐标是否在openlist或者closelist中</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//释放内存。</span><br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="Astart-cpp"><a href="#Astart-cpp" class="headerlink" title="Astart.cpp"></a>Astart.cpp</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;AStart.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-function">std::list&lt;Pos&gt; <span class="hljs-title">AStart::find</span><span class="hljs-params">(Pos start, Pos end)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;end = end;<br>    std::list&lt;Pos&gt; path;<br>    closeList.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(start, <span class="hljs-number">0</span>, <span class="hljs-built_in">getH</span>(start)));<br>    Node* endNode = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//终点到达标志位,同时为遍历父亲节点做准备</span><br>    <br>    <span class="hljs-type">size_t</span> length = <span class="hljs-number">0</span>;<span class="hljs-comment">//做循环的判断条件用的</span><br>    <span class="hljs-keyword">while</span> (length &lt; closeList.<span class="hljs-built_in">size</span>()&amp;&amp;!endNode)<br>    &#123;<br>        length = closeList.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">addRound</span>(closeList.<span class="hljs-built_in">back</span>());<br>        <br>        <span class="hljs-comment">//找到openList里面和值最小的node</span><br>        <span class="hljs-keyword">auto</span> it = openLsit.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">//默认最小的是openList的第一个元素，如果找到了就将其替换。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = openLsit.<span class="hljs-built_in">begin</span>(); i != openLsit.<span class="hljs-built_in">end</span>(); i++)<br>        &#123;<br>            <span class="hljs-comment">//判断是否到达终点</span><br>            <span class="hljs-keyword">if</span> ((*i)-&gt;v.x == end.x &amp;&amp; (*i)-&gt;v.y == end.y)<br>            &#123;<br>                endNode=*i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">//找到最小的和值F</span><br>            <span class="hljs-keyword">if</span> ((*it)-&gt;<span class="hljs-built_in">getF</span>() &gt; (*i)-&gt;<span class="hljs-built_in">getF</span>())<br>            &#123;<br>                it = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//将找到的最小和值F的节点放入closeList中,同时需要将此节点从openlist中剔除；</span><br>        <span class="hljs-keyword">if</span> (it != openLsit.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            closeList.<span class="hljs-built_in">push_back</span>((*it));<br>            openLsit.<span class="hljs-built_in">erase</span>(it);<br>        &#125;<br>        <span class="hljs-comment">//break后将路径从终点往父亲节点遍历，逐个插入到path的头部，实现正序输出。</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (endNode)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (endNode)<br>        &#123;<br>            path.<span class="hljs-built_in">push_front</span>(endNode-&gt;v);<br>            endNode = endNode-&gt;pre;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//最后内存的清理</span><br>    <span class="hljs-built_in">destory</span>();<br>    <span class="hljs-keyword">return</span> path;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">AStart::getH</span><span class="hljs-params">(Pos now)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">abs</span>(now.x-end.x)+std::<span class="hljs-built_in">abs</span>(now.y-end.y);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">AStart::check</span><span class="hljs-params">(Pos v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (level.<span class="hljs-built_in">isValid</span>(v) &amp;&amp; !<span class="hljs-built_in">findList</span>(v))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">AStart::findList</span><span class="hljs-params">(Pos v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; e : openLsit)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (e-&gt;v.x == v.x &amp;&amp; e-&gt;v.y == v.y)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; e : closeList)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (e-&gt;v.x == v.x &amp;&amp; e-&gt;v.y == v.y)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AStart::destory</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : openLsit)<br>        <span class="hljs-keyword">delete</span> e;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : closeList)<br>        <span class="hljs-keyword">delete</span> e;<br>    openLsit.<span class="hljs-built_in">clear</span>();<br>    closeList.<span class="hljs-built_in">clear</span>();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AStart::addRound</span><span class="hljs-params">(Node* now)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> Pos dir[]<span class="hljs-comment">//使用花括号直接初始化不能有强转否则会报错</span><br>    &#123;<br>        &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<span class="hljs-comment">//下</span><br>        &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,<span class="hljs-comment">//右</span><br>        &#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,<span class="hljs-comment">//上</span><br>        &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;<span class="hljs-comment">//左</span><br>    &#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : dir)<br>    &#123;<br>        e = &#123; now-&gt;v.x + e.x,now-&gt;v.y + e.y &#125;;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(e))<br>        &#123;<br>            openLsit.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(e, now-&gt;G + <span class="hljs-number">1</span>, <span class="hljs-built_in">getH</span>(e), now));<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><h1 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h1><p><img src="/img/00002/Astar.gif" alt="在这里插入图片描述"></p></blockquote><h1 id="最近有小伙伴需要这整个工程，来满足一下大家。"><a href="#最近有小伙伴需要这整个工程，来满足一下大家。" class="headerlink" title="最近有小伙伴需要这整个工程，来满足一下大家。"></a>最近有小伙伴需要这整个工程，来满足一下大家。</h1><p><a href="https://download.csdn.net/download/Howl_1/86893463">A星寻路工程，vs2019，0积分下载</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++深度优先和广度优先的实现</title>
    <link href="/2021/01/27/00001.%20C++%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/01/27/00001.%20C++%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p><strong>本篇文章为笔者的读书笔记，未经允许请勿转载。</strong><br>本文主要讲的深度优先算法和广度优先算法的区别，其中深度优先有两种实现方式，一种是递归法，另一种是非递归（栈实现），而广度优先就是队列的实现；<br>后面还会以图形表述栈实现和队列实现；且用到了图形库easyx；</p></blockquote><hr><h1 id="源码如下："><a href="#源码如下：" class="headerlink" title="源码如下："></a>源码如下：</h1><h4 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;Draw.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;DFS.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;BFS.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;Search.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; map =<br>&#123;<br>    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>    &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>    &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,<br>    &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>    &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,<br>    &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>&#125;;<br><span class="hljs-comment">//检查数据的合法性</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//所走的路径不能越界，也不能走到地图为1的地方。</span><br>    <span class="hljs-keyword">if</span> ((y &lt; <span class="hljs-number">0</span> ||  x&lt;<span class="hljs-number">0</span>) || y &gt;= map.<span class="hljs-built_in">size</span>() ||x&gt;=map[y].<span class="hljs-built_in">size</span>() || map[y][x] == <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//测试图形库是否能正常运行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Draw <span class="hljs-title">draw</span><span class="hljs-params">(<span class="hljs-number">600</span>, map)</span></span>;<br>    draw.<span class="hljs-built_in">updata</span>();<br>&#125;<br><span class="hljs-comment">//深度优先算法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">DFS <span class="hljs-title">dfs</span><span class="hljs-params">(check)</span></span>;<br>    <span class="hljs-function">Draw <span class="hljs-title">draw</span><span class="hljs-params">(<span class="hljs-number">600</span>, map)</span></span>;<br>    Pos start&#123; <span class="hljs-number">0</span>,<span class="hljs-number">0</span> &#125;;<br>    Pos end&#123; <span class="hljs-number">1</span>,<span class="hljs-number">6</span> &#125;;<br>    draw.level[end.y][end.x] = Draw::end;<span class="hljs-comment">//设置终点位置</span><br>    draw.<span class="hljs-built_in">updata</span>();<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; path = dfs.<span class="hljs-built_in">recursive</span>(start,end);<span class="hljs-comment">//开始寻路，路径找完后用vector保存了</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; e : path)<br>    &#123;<br>        draw.level[e.y][e.x] = Draw::visit;<span class="hljs-comment">//路径设置为visit。注意x，y不要写反了</span><br>        draw.<span class="hljs-built_in">updata</span>();<br>        <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">500</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//广度优先算法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">BFS <span class="hljs-title">bfs</span><span class="hljs-params">(check)</span></span>;<br>    <span class="hljs-function">Draw <span class="hljs-title">draw</span><span class="hljs-params">(<span class="hljs-number">600</span>, map)</span></span>;<br>    Pos start&#123; <span class="hljs-number">1</span>,<span class="hljs-number">1</span> &#125;;<br>    Pos end&#123; <span class="hljs-number">3</span>,<span class="hljs-number">0</span> &#125;;<br>    draw.level[end.y][end.x] = Draw::end;<br>    draw.<span class="hljs-built_in">updata</span>();<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; path = bfs.<span class="hljs-built_in">queue</span>(start, end);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; e : path)<br>    &#123;<br>        draw.level[e.y][e.x] = Draw::visit;<br>        draw.<span class="hljs-built_in">updata</span>();<br>        <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">500</span>);<br>    &#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//test();</span><br>    <span class="hljs-comment">//test1();</span><br>    <span class="hljs-comment">//test2();</span><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Draw-h"><a href="#Draw-h" class="headerlink" title="Draw.h"></a>Draw.h</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;easyx.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">//区别名</span><br><span class="hljs-keyword">using</span> vec2 = std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;;<br><span class="hljs-comment">//绘制地图的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Draw</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Draw</span>(<span class="hljs-type">int</span>&amp;&amp; length, vec2&amp; map) :<span class="hljs-built_in">length</span>(length)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;level = map;<br><span class="hljs-keyword">this</span>-&gt;size = length / level.<span class="hljs-built_in">size</span>();<br><span class="hljs-built_in">initgraph</span>(length, length, EW_SHOWCONSOLE);<br>&#125;<br>~<span class="hljs-built_in">Draw</span>()<br>&#123;<br><span class="hljs-built_in">closegraph</span>();<br>&#125;<br><span class="hljs-keyword">enum</span> &#123;<br>road=<span class="hljs-number">0</span>,<span class="hljs-comment">//空地</span><br>wall,<span class="hljs-comment">//墙</span><br>visit,<span class="hljs-comment">//走过的路</span><br>end,<span class="hljs-comment">//终点</span><br>&#125;;<br><span class="hljs-comment">//绘制的地图。</span><br>vec2 level;<br><span class="hljs-comment">//游戏更新</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updata</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">draw</span>();<br><span class="hljs-built_in">test</span>();<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> length;<span class="hljs-comment">//宽度和高度</span><br><span class="hljs-type">int</span> size;<span class="hljs-comment">//每个瓦片的大小</span><br><span class="hljs-comment">//绘制地图</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">BeginBatchDraw</span>();<span class="hljs-comment">//开始批量画图</span><br><span class="hljs-built_in">cleardevice</span>();<span class="hljs-comment">//把之前的先清除</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; level.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; level[i].<span class="hljs-built_in">size</span>(); j++)<br>&#123;<br><span class="hljs-keyword">if</span> (level[i][j] == road)<br>&#123;<br><span class="hljs-built_in">setfillcolor</span>(<span class="hljs-built_in">RGB</span>(<span class="hljs-number">0xdd</span>, <span class="hljs-number">0xdd</span>, <span class="hljs-number">0xdd</span>));<span class="hljs-comment">//设置路的颜色</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (level[i][j] == wall)<br>&#123;<br><span class="hljs-built_in">setfillcolor</span>(<span class="hljs-built_in">RGB</span>(<span class="hljs-number">0x33</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0xcc</span>));<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (level[i][j] == visit)<br>&#123;<br><span class="hljs-built_in">setfillcolor</span>(<span class="hljs-built_in">RGB</span>(<span class="hljs-number">0x33</span>, <span class="hljs-number">0xcc</span>, <span class="hljs-number">0x33</span>));<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (level[i][j] == end)<br>&#123;<br><span class="hljs-built_in">setfillcolor</span>(<span class="hljs-built_in">RGB</span>(<span class="hljs-number">0xff</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0x33</span>));<br>&#125;<br><span class="hljs-built_in">rect</span>(j, i);<span class="hljs-comment">//绘制瓦片，j代表x，i代表y。</span><br><span class="hljs-comment">/*（0，0）----------▷ x的正方向</span><br><span class="hljs-comment">      |</span><br><span class="hljs-comment">  |</span><br><span class="hljs-comment">  |</span><br><span class="hljs-comment">  |</span><br><span class="hljs-comment"> ▽ y的正方向</span><br><span class="hljs-comment">图形库窗口的坐标*/</span><br>&#125;  <br>&#125;<br><span class="hljs-built_in">EndBatchDraw</span>();<br>&#125; <br><span class="hljs-comment">//绘制文本</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;cls&quot;</span>);<span class="hljs-comment">//清屏</span><br>std::string str=<span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; level.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; level[i].<span class="hljs-built_in">size</span>(); j++)<br>&#123;<br><span class="hljs-keyword">if</span> (level[i][j] == road)<br>&#123;<br>str += <span class="hljs-string">&quot;  &quot;</span>;<span class="hljs-comment">//设置路的标识符</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (level[i][j] == wall)<br>&#123;<br>str += <span class="hljs-string">&quot;+ &quot;</span>;<span class="hljs-comment">//墙</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (level[i][j] == visit)<br>&#123;<br>str += <span class="hljs-string">&quot;. &quot;</span>;<span class="hljs-comment">//走过的路</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (level[i][j] == end)<br>&#123;<br>str += <span class="hljs-string">&quot;= &quot;</span>;<span class="hljs-comment">//终点</span><br>&#125;<br>&#125;<br>str += <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br>std::cout &lt;&lt; str &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-comment">//绘制瓦片</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rect</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">fillrectangle</span>(x * size, y * size, (x + <span class="hljs-number">1</span>) * size, (y + <span class="hljs-number">1</span>) * size);<br><span class="hljs-comment">/* void fillrectangle(</span><br><span class="hljs-comment">int left,</span><br><span class="hljs-comment">int top,</span><br><span class="hljs-comment">int right,</span><br><span class="hljs-comment">int bottom</span><br><span class="hljs-comment">); */</span><br><br>&#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="Search-h"><a href="#Search-h" class="headerlink" title="Search.h"></a>Search.h</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pos</span><br>&#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-type">int</span> y;<br><span class="hljs-built_in">Pos</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>, <span class="hljs-type">int</span> y=<span class="hljs-number">0</span>) :<span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Search</span><br>&#123;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-keyword">using</span> Function = std::function&lt;<span class="hljs-built_in">bool</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt;;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Search</span>(Function fn) :<span class="hljs-built_in">fn</span>(fn) &#123;&#125;<br><span class="hljs-keyword">protected</span>:<br><br><span class="hljs-comment">//通过函数适配器调用外部规则，对数据进行判断；</span><br>Function fn;<br><span class="hljs-comment">//创建一个vector保存路径</span><br>std::vector&lt;Pos&gt; path;<br><span class="hljs-comment">//判断这条路是否走过</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isVisited</span><span class="hljs-params">(Pos pos)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; e : path)<br>&#123;<br><span class="hljs-keyword">if</span> (pos.x == e.x &amp;&amp; pos.y == e.y)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">//判断下次移动是否合法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(Pos pos)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">fn</span>(pos.x, pos.y) &amp;&amp; !<span class="hljs-built_in">isVisited</span>(pos);<span class="hljs-comment">//fn调用外部规则check</span><br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="DFS-h"><a href="#DFS-h" class="headerlink" title="DFS.h"></a>DFS.h</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Search.h&quot;</span></span><br><span class="hljs-comment">//深度优先算法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DFS</span> : <span class="hljs-keyword">public</span> Search<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">DFS</span>(std::function&lt;<span class="hljs-built_in">bool</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; fn):<span class="hljs-built_in">Search</span>(fn)<span class="hljs-comment">//构造子类的时候，需要初始化父类。</span><br>&#123;<br>    <br>&#125;<br><span class="hljs-comment">/*start 起点坐标</span><br><span class="hljs-comment">  end   终点坐标*/</span><br><span class="hljs-comment">//递归法</span><br><span class="hljs-function">std::vector&lt;Pos&gt; <span class="hljs-title">recursive</span><span class="hljs-params">(Pos start, Pos end)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;end = end;<br>    path.<span class="hljs-built_in">push_back</span>(start);<br>    _recursive(start);<br>    <span class="hljs-keyword">return</span> path;<br>&#125;<br><span class="hljs-comment">//非递归法（栈实现）</span><br><span class="hljs-function">std::vector&lt;Pos&gt; <span class="hljs-title">stack</span><span class="hljs-params">(Pos start, Pos end)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> Pos dir[<span class="hljs-number">4</span>] = &#123;<br>        &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<span class="hljs-comment">//y+1向下</span><br>        &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,<span class="hljs-comment">//x+1向右</span><br>        &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,<span class="hljs-comment">//x-1向左</span><br>        &#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,<span class="hljs-comment">//y-1向上</span><br>    &#125;;<br>    std::stack&lt;Pos&gt; st;<br>    st.<span class="hljs-built_in">push</span>(start);<br>    <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> now = st.<span class="hljs-built_in">top</span>();<br>        st.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        &#123;<br>            <span class="hljs-comment">//准备移动的路径</span><br>            <span class="hljs-function">Pos <span class="hljs-title">move</span><span class="hljs-params">(now.x + dir[i].x, now.y + dir[i].y)</span></span>;<br>            <span class="hljs-comment">//判断是否能移动</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(move))<br>            &#123;<br>                st.<span class="hljs-built_in">push</span>(move);<br>                path.<span class="hljs-built_in">push_back</span>(move);<br>                <span class="hljs-comment">//判断是否到达终点</span><br>                <span class="hljs-keyword">if</span> (move.x == end.x &amp;&amp; move.y == end.y)<br>                &#123;<br>                    <span class="hljs-keyword">return</span> path;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> path;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">bool</span> is_end=<span class="hljs-literal">false</span>;<span class="hljs-comment">//递归需要的标志位，默认位false</span><br>Pos end;  <span class="hljs-comment">//保存终点坐标</span><br><span class="hljs-type">void</span> _recursive(Pos now)<br>&#123;<br>    <span class="hljs-type">static</span> Pos dir[<span class="hljs-number">4</span>] = &#123;<br>        &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<span class="hljs-comment">//y+1向下</span><br>        &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,<span class="hljs-comment">//x+1向右</span><br>        &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,<span class="hljs-comment">//x-1向左</span><br>        &#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,<span class="hljs-comment">//y-1向上</span><br>    &#125;;<br>    <span class="hljs-comment">//判断是否到达终点</span><br>    <span class="hljs-keyword">if</span> (now.x == end.x &amp;&amp; now.y == end.y)<br>    &#123;<br>        is_end = <span class="hljs-literal">true</span>;<span class="hljs-comment">//找到终点标志位置1</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//循环遍历下右左上4个方向</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>    &#123;<br>        <span class="hljs-comment">//准备移动的路径</span><br>        <span class="hljs-function">Pos <span class="hljs-title">move</span><span class="hljs-params">(now.x + dir[i].x, now.y + dir[i].y)</span></span>;<br>        <span class="hljs-comment">//判断能否移动</span><br>            <span class="hljs-keyword">if</span> (!is_end &amp;&amp; <span class="hljs-built_in">isValid</span>(move))<br>            &#123;<br>                path.<span class="hljs-built_in">push_back</span>(move);<span class="hljs-comment">//保存走过的路径</span><br>                _recursive(move);<br>            &#125;<br>    &#125;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="BFS-h"><a href="#BFS-h" class="headerlink" title="BFS.h"></a>BFS.h</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Search.h&quot;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BFS</span> :<span class="hljs-keyword">public</span> Search<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">BFS</span>(Function fn):<span class="hljs-built_in">Search</span>(fn)<br>&#123;<br>&#125;<br><span class="hljs-function">std::vector&lt;Pos&gt; <span class="hljs-title">queue</span><span class="hljs-params">(Pos start, Pos end)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> Pos dir[<span class="hljs-number">4</span>] = &#123;<br>       &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<span class="hljs-comment">//y+1向下</span><br>       &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,<span class="hljs-comment">//x+1向右</span><br>       &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,<span class="hljs-comment">//x-1向左</span><br>       &#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,<span class="hljs-comment">//y-1向上</span><br>    &#125;;<br>    std::queue&lt;Pos&gt; qu;<br>    qu.<span class="hljs-built_in">push</span>(start);<br>    <span class="hljs-keyword">while</span> (!qu.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> now = qu.<span class="hljs-built_in">front</span>();<br>        qu.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        &#123;<br>            <span class="hljs-function">Pos <span class="hljs-title">move</span><span class="hljs-params">(now.x + dir[i].x, now.y + dir[i].y)</span></span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(move))<br>            &#123;<br>                qu.<span class="hljs-built_in">push</span>(move);<br>                path.<span class="hljs-built_in">push_back</span>(move);<br>                <span class="hljs-keyword">if</span> (move.x == end.x &amp;&amp; move.y == end.y)<br>                &#123;<br>                    <span class="hljs-keyword">return</span> path;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> path;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h1><blockquote><p><strong>递归实现：</strong><br><img src="/img/00001/dfs.gif" alt="在这里插入图片描述"></p></blockquote><blockquote><p><strong>深度优先（栈实现）：</strong><br><img src="/img/00001/bfs-stack.gif" alt="在这里插入图片描述"></p></blockquote><blockquote><p><strong>广度优先（队列实现）</strong><br><img src="/img/00001/bfs-queue.gif" alt="在这里插入图片描述"></p></blockquote><h1 id="深度优先（栈实现）和广度优先（队列实现）图解"><a href="#深度优先（栈实现）和广度优先（队列实现）图解" class="headerlink" title="深度优先（栈实现）和广度优先（队列实现）图解"></a>深度优先（栈实现）和广度优先（队列实现）图解</h1><blockquote><p><strong>深度优先：</strong><br><img src="/img/00001/dfs.png" alt="在这里插入图片描述"><br><strong>广度优先：</strong><br><img src="/img/00001/bfs.png" alt="在这里插入图片描述"></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
